{
  ArrayRealVector delta=new ArrayRealVector(weights.getDimension());
  if (weights.getDimension() < delta.getDimension()) {
    weights=weights.append(new double[delta.getDimension() - weights.getDimension()]);
  }
  double diff=0;
  double[] distanceSqrt=new double[goldVectors.length];
  RealVector[] distanceVec=new RealVector[goldVectors.length];
  double[] distanceDotWts=new double[goldVectors.length];
  int worstGuessIdx=0;
  double worstErrorTerm=Double.NEGATIVE_INFINITY;
  for (int i=0; i < alphas.length; i++) {
    distanceVec[i]=goldVectors[i].add(guessedVectors[i].mapMultiply(-1));
    distanceDotWts[i]=distanceVec[i].dotProduct(weights);
    double norm=distanceVec[i].getNorm();
    distanceSqrt[i]=norm * norm;
    if (losses[i] != 0) {
      double errTerm=losses[i] - distanceVec[i].dotProduct(weights);
      if (errTerm > worstErrorTerm) {
        worstErrorTerm=errTerm;
        worstGuessIdx=i;
      }
    }
  }
  if (worstErrorTerm < 0.0)   return new OpenMapRealVector(weights.getDimension());
  alphas[worstGuessIdx]=C;
  quickAddToSelf(delta,distanceVec[worstGuessIdx].mapMultiply(C));
  double[][] diffDist=new double[alphas.length][];
  for (int i=0; i < alphas.length; i++) {
    diffDist[i]=new double[alphas.length];
    for (int j=0; j < i; j++) {
      diffDist[i][j]=Math.pow((distanceVec[i].add(distanceVec[j].mapMultiply(-1))).getNorm(),2);
      diffDist[j][i]=diffDist[i][j];
    }
  }
  int iters=0;
  double dDdAlphaSum;
  do {
    iters++;
    diff=0;
    dDdAlphaSum=0;
    alphasI:     for (int i=0; i < alphas.length; i++) {
      double deltaI=(distanceDotWts[i] + delta.dotProduct(distanceVec[i]));
      double dDdAlpha=distanceSqrt[i] != 0 ? (losses[i] - deltaI) / distanceSqrt[i] : 0;
      dDdAlphaSum+=Math.abs(dDdAlpha);
      for (int j=i + 1; j < alphas.length; j++) {
        if (diffDist[i][j] == 0)         continue;
        if (alphas[i] == 0 && alphas[j] == 0)         continue;
        double deltaJ=(distanceDotWts[j] + delta.dotProduct(distanceVec[j]));
        double deltaAlpha=((losses[i] - losses[j]) - (deltaI - deltaJ)) / diffDist[i][j];
        deltaAlpha=Math.max(-alphas[i],deltaAlpha);
        deltaAlpha=Math.min(alphas[j],deltaAlpha);
        if (deltaAlpha != 0) {
          alphas[i]=alphas[i] + deltaAlpha;
          alphas[j]=alphas[j] - deltaAlpha;
          quickAddToSelf(delta,distanceVec[i].mapMultiply(deltaAlpha));
          quickAddToSelf(delta,distanceVec[j].mapMultiply(-deltaAlpha));
          diff+=Math.abs(2 * deltaAlpha);
          deltaI=(distanceDotWts[i] + delta.dotProduct(distanceVec[i]));
          if (alphas[i] == 0 && losses[i] - deltaI < 0)           continue alphasI;
        }
      }
    }
  }
 while (dDdAlphaSum / C > TOL && diff / C > DIFF_TOL);
  if (weights instanceof ArrayRealVector) {
    lastWeights=quickAddToSelf((ArrayRealVector)weights,delta);
  }
 else {
    lastWeights=weights.add(delta);
  }
  return delta;
}
