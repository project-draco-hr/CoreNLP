{
  if (other == edu.stanford.nlp.pipeline.CoreNLPProtos.OpenIETriple.getDefaultInstance())   return this;
  if (other.hasSubject()) {
    bitField0_|=0x00000001;
    subject_=other.subject_;
    onChanged();
  }
  if (other.hasRelation()) {
    bitField0_|=0x00000002;
    relation_=other.relation_;
    onChanged();
  }
  if (other.hasObject()) {
    bitField0_|=0x00000004;
    object_=other.object_;
    onChanged();
  }
  if (other.hasConfidence()) {
    setConfidence(other.getConfidence());
  }
  if (!other.subjectTokens_.isEmpty()) {
    if (subjectTokens_.isEmpty()) {
      subjectTokens_=other.subjectTokens_;
      bitField0_=(bitField0_ & ~0x00000010);
    }
 else {
      ensureSubjectTokensIsMutable();
      subjectTokens_.addAll(other.subjectTokens_);
    }
    onChanged();
  }
  if (!other.relationTokens_.isEmpty()) {
    if (relationTokens_.isEmpty()) {
      relationTokens_=other.relationTokens_;
      bitField0_=(bitField0_ & ~0x00000020);
    }
 else {
      ensureRelationTokensIsMutable();
      relationTokens_.addAll(other.relationTokens_);
    }
    onChanged();
  }
  if (!other.objectTokens_.isEmpty()) {
    if (objectTokens_.isEmpty()) {
      objectTokens_=other.objectTokens_;
      bitField0_=(bitField0_ & ~0x00000040);
    }
 else {
      ensureObjectTokensIsMutable();
      objectTokens_.addAll(other.objectTokens_);
    }
    onChanged();
  }
  if (other.hasTree()) {
    mergeTree(other.getTree());
  }
  if (other.hasIstmod()) {
    setIstmod(other.getIstmod());
  }
  if (other.hasPrefixBe()) {
    setPrefixBe(other.getPrefixBe());
  }
  if (other.hasSuffixBe()) {
    setSuffixBe(other.getSuffixBe());
  }
  if (other.hasSuffixOf()) {
    setSuffixOf(other.getSuffixOf());
  }
  this.mergeUnknownFields(other.unknownFields);
  onChanged();
  return this;
}
