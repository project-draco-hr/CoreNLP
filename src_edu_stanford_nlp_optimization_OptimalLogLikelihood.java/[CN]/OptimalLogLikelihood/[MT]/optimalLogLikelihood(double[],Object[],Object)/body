{
  Arrays.sort(scores);
  final int n=scores.length;
  final int m=2 * n + (n - 1);
  final boolean[] positiveInstance=new boolean[n];
  for (int i=0; i < n; ++i) {
    positiveInstance[i]=labels[i].equals(positiveLabel);
  }
  DiffFunction df=new AbstractCachingDiffFunction(){
    @Override public int domainDimension(){
      return n;
    }
    @Override public void calculate(    double[] p){
      value=0.0;
      System.out.print("\np: ");
      for (int i=0; i < derivative.length; ++i) {
        if (p[i] < 0 || p[i] > 1) {
          value=Double.POSITIVE_INFINITY;
          return;
        }
        System.out.print(p[i] + " ");
      }
      System.out.println();
      for (int i=0; i < p.length; ++i) {
        boolean pos=positiveInstance[i];
        value-=t * Math.log((pos ? p[i] : 1 - p[i]));
        value-=Math.log(p[i]);
        value-=Math.log((1 - p[i]));
        if (i < p.length - 1) {
          value-=Math.log(p[i + 1] - p[i]);
        }
      }
      for (int i=0; i < p.length; ++i) {
        boolean pos=positiveInstance[i];
        derivative[i]=(pos ? -1.0 / p[i] : 1.0 / (1.0 - p[i]));
        derivative[i]+=-1.0 / p[i];
        derivative[i]+=1.0 / (1.0 - p[i]);
        if (i < p.length - 1) {
          derivative[i]+=1.0 / (p[i + 1] - p[i]);
        }
        if (i > 0) {
          derivative[i]+=1.0 / (p[i - 1] - p[i]);
        }
      }
      System.out.println("Value: " + value);
      System.out.print("Derivative: ");
      for (int i=0; i < derivative.length; ++i)       System.out.print(derivative[i] + " ");
      System.out.println();
    }
  }
;
  Minimizer qnm=new QNMinimizer();
  double tol=1.0e-6;
  t=1.0;
  double[] p=new double[n];
  final double mu=1.3;
  for (int i=0; i < n; ++i)   p[i]=1.0 - 1.0 / (i + 2.0);
  for (int i=0; i < p.length; ++i)   System.out.print(p[i] + " ");
  while (m / t >= tol) {
    System.out.println("About to call qnm with t=" + t);
    p=qnm.minimize(df,tol,p);
    t*=mu;
  }
  return new Pair<double[],Double>(p,df.valueAt(p));
}
