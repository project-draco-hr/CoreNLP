{
  MemoryTreebank tb=new MemoryTreebank(new NPTmpRetainingTreeNormalizer(0,false,1,false));
  Iterable<Tree> trees=tb;
  Iterable<GrammaticalStructure> gsBank=null;
  Properties props=StringUtils.argsToProperties(args);
  String encoding=props.getProperty("encoding","utf-8");
  try {
    System.setOut(new PrintStream(System.out,true,encoding));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  String treeFileName=props.getProperty("treeFile");
  String sentFileName=props.getProperty("sentFile");
  String conllXFileName=props.getProperty("conllxFile");
  String altDepPrinterName=props.getProperty("altprinter");
  String altDepReaderName=props.getProperty("altreader");
  String altDepReaderFilename=props.getProperty("altreaderfile");
  String filter=props.getProperty("filter");
  boolean makeCopulaHead=props.getProperty("makeCopulaHead") != null;
  boolean generateOriginalDependencies=props.getProperty("originalDependencies") != null;
  String tLPP=props.getProperty("tLPP","edu.stanford.nlp.parser.lexparser.EnglishTreebankParserParams");
  TreebankLangParserParams params=ReflectionLoading.loadByReflection(tLPP);
  if (generateOriginalDependencies) {
    params.setGenerateOriginalDependencies(true);
  }
  if (makeCopulaHead) {
    String[] options={"-makeCopulaHead"};
    params.setOptionFlag(options,0);
  }
  if (sentFileName == null && (altDepReaderName == null || altDepReaderFilename == null) && treeFileName == null && conllXFileName == null && filter == null) {
    try {
      log.info("Usage: java GrammaticalStructure [options]* [-sentFile|-treeFile|-conllxFile file] [-testGraph]");
      log.info("  options: -basic, -collapsed, -CCprocessed [the default], -collapsedTree, -parseTree, -test, -parserFile file, -conllx, -keepPunct, -altprinter -altreader -altreaderfile -originalDependencies");
      TreeReader tr=new PennTreeReader(new StringReader("((S (NP (NNP Sam)) (VP (VBD died) (NP-TMP (NN today)))))"));
      tb.add(tr.readTree());
    }
 catch (    Exception e) {
      log.info("Horrible error: " + e);
      e.printStackTrace();
    }
  }
 else   if (altDepReaderName != null && altDepReaderFilename != null) {
    DependencyReader altDepReader=loadAlternateDependencyReader(altDepReaderName);
    try {
      gsBank=altDepReader.readDependencies(altDepReaderFilename);
    }
 catch (    IOException e) {
      log.info("Error reading " + altDepReaderFilename);
      return;
    }
  }
 else   if (treeFileName != null) {
    tb.loadPath(treeFileName);
  }
 else   if (filter != null) {
    tb.load(IOUtils.readerFromStdin());
  }
 else   if (conllXFileName != null) {
    try {
      gsBank=params.readGrammaticalStructureFromFile(conllXFileName);
    }
 catch (    RuntimeIOException e) {
      log.info("Error reading " + conllXFileName);
      return;
    }
  }
 else {
    String parserFile=props.getProperty("parserFile");
    String parserOpts=props.getProperty("parserOpts");
    boolean tokenized=props.getProperty("tokenized") != null;
    Function<List<? extends HasWord>,Tree> lp=loadParser(parserFile,parserOpts,makeCopulaHead);
    trees=new LazyLoadTreesByParsing(sentFileName,encoding,tokenized,lp);
    try {
      Method method=lp.getClass().getMethod("getTLPParams");
      params=(TreebankLangParserParams)method.invoke(lp);
    }
 catch (    Exception cnfe) {
      throw new RuntimeException(cnfe);
    }
  }
  boolean basic=props.getProperty("basic") != null;
  boolean collapsed=props.getProperty("collapsed") != null;
  boolean CCprocessed=props.getProperty("CCprocessed") != null;
  boolean collapsedTree=props.getProperty("collapsedTree") != null;
  boolean nonCollapsed=props.getProperty("nonCollapsed") != null;
  boolean extraSep=props.getProperty("extraSep") != null;
  boolean parseTree=props.getProperty("parseTree") != null;
  boolean test=props.getProperty("test") != null;
  boolean keepPunct=props.getProperty("keepPunct") != null;
  boolean conllx=props.getProperty("conllx") != null;
  boolean checkConnected=props.getProperty("checkConnected") != null;
  boolean portray=props.getProperty("portray") != null;
  if (conllx) {
    keepPunct=true;
  }
  DependencyPrinter altDepPrinter=null;
  if (altDepPrinterName != null) {
    altDepPrinter=loadAlternateDependencyPrinter(altDepPrinterName);
  }
  Method m=null;
  if (test) {
    try {
      Class sgf=Class.forName("edu.stanford.nlp.semgraph.SemanticGraphFactory");
      m=sgf.getDeclaredMethod("makeFromTree",GrammaticalStructure.class,boolean.class,boolean.class,boolean.class,boolean.class,boolean.class,boolean.class,Predicate.class,String.class,int.class);
    }
 catch (    Exception e) {
      log.info("Test cannot check for cycles in tree format (classes not available)");
    }
  }
  if (gsBank == null) {
    gsBank=new TreeBankGrammaticalStructureWrapper(trees,keepPunct,params);
  }
  for (  GrammaticalStructure gs : gsBank) {
    Tree tree;
    if (gsBank instanceof TreeBankGrammaticalStructureWrapper) {
      tree=((TreeBankGrammaticalStructureWrapper)gsBank).getOriginalTree(gs);
    }
 else {
      tree=gs.root();
    }
    if (test) {
      System.out.println("============= parse tree =======================");
      tree.pennPrint();
      System.out.println();
      System.out.println("------------- GrammaticalStructure -------------");
      System.out.println(gs);
      boolean allConnected=true;
      boolean connected;
      Collection<TypedDependency> bungRoots=null;
      System.out.println("------------- basic dependencies ---------------");
      List<TypedDependency> gsb=gs.typedDependencies(Extras.NONE);
      System.out.println(StringUtils.join(gsb,"\n"));
      connected=GrammaticalStructure.isConnected(gsb);
      if (!connected && bungRoots == null) {
        bungRoots=GrammaticalStructure.getRoots(gsb);
      }
      allConnected=connected && allConnected;
      System.out.println("------------- non-collapsed dependencies (basic + extra) ---------------");
      List<TypedDependency> gse=gs.typedDependencies(Extras.MAXIMAL);
      System.out.println(StringUtils.join(gse,"\n"));
      connected=GrammaticalStructure.isConnected(gse);
      if (!connected && bungRoots == null) {
        bungRoots=GrammaticalStructure.getRoots(gse);
      }
      allConnected=connected && allConnected;
      System.out.println("------------- collapsed dependencies -----------");
      System.out.println(StringUtils.join(gs.typedDependenciesCollapsed(Extras.MAXIMAL),"\n"));
      System.out.println("------------- collapsed dependencies tree -----------");
      System.out.println(StringUtils.join(gs.typedDependenciesCollapsedTree(),"\n"));
      System.out.println("------------- CCprocessed dependencies --------");
      List<TypedDependency> gscc=gs.typedDependenciesCollapsed(Extras.MAXIMAL);
      System.out.println(StringUtils.join(gscc,"\n"));
      System.out.println("-----------------------------------------------");
      connected=GrammaticalStructure.isConnected(gscc);
      if (!connected && bungRoots == null) {
        bungRoots=GrammaticalStructure.getRoots(gscc);
      }
      allConnected=connected && allConnected;
      if (allConnected) {
        System.out.println("dependencies form connected graphs.");
      }
 else {
        System.out.println("dependency graph NOT connected! possible offending nodes: " + bungRoots);
      }
      if (m != null) {
        try {
          Object semGraph=m.invoke(null,gs,false,true,false,false,false,false,null,null,0);
          Class sg=Class.forName("edu.stanford.nlp.semgraph.SemanticGraph");
          Method mDag=sg.getDeclaredMethod("isDag");
          boolean isDag=(Boolean)mDag.invoke(semGraph);
          System.out.println("tree dependencies form a DAG: " + isDag);
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
 else {
      if (parseTree) {
        System.out.println("============= parse tree =======================");
        tree.pennPrint();
        System.out.println();
      }
      if (basic) {
        if (collapsed || CCprocessed || collapsedTree|| nonCollapsed) {
          System.out.println("------------- basic dependencies ---------------");
        }
        if (altDepPrinter == null) {
          printDependencies(gs,gs.typedDependencies(Extras.NONE),tree,conllx,false);
        }
 else {
          System.out.println(altDepPrinter.dependenciesToString(gs,gs.typedDependencies(Extras.NONE),tree));
        }
      }
      if (nonCollapsed) {
        if (basic || CCprocessed || collapsed|| collapsedTree) {
          System.out.println("----------- non-collapsed dependencies (basic + extra) -----------");
        }
        printDependencies(gs,gs.allTypedDependencies(),tree,conllx,extraSep);
      }
      if (collapsed) {
        if (basic || CCprocessed || collapsedTree|| nonCollapsed) {
          System.out.println("----------- collapsed dependencies -----------");
        }
        printDependencies(gs,gs.typedDependenciesCollapsed(Extras.MAXIMAL),tree,conllx,false);
      }
      if (CCprocessed) {
        if (basic || collapsed || collapsedTree|| nonCollapsed) {
          System.out.println("---------- CCprocessed dependencies ----------");
        }
        List<TypedDependency> deps=gs.typedDependenciesCCprocessed(Extras.MAXIMAL);
        if (checkConnected) {
          if (!GrammaticalStructure.isConnected(deps)) {
            log.info("Graph is not connected for:");
            log.info(tree);
            log.info("possible offending nodes: " + GrammaticalStructure.getRoots(deps));
          }
        }
        printDependencies(gs,deps,tree,conllx,false);
      }
      if (collapsedTree) {
        if (basic || CCprocessed || collapsed|| nonCollapsed) {
          System.out.println("----------- collapsed dependencies tree -----------");
        }
        printDependencies(gs,gs.typedDependenciesCollapsedTree(),tree,conllx,false);
      }
      if (!basic && !collapsed && !CCprocessed&& !collapsedTree&& !nonCollapsed) {
        printDependencies(gs,gs.typedDependenciesCCprocessed(Extras.MAXIMAL),tree,conllx,false);
      }
    }
    if (portray) {
      try {
        Class sgu=Class.forName("edu.stanford.nlp.semgraph.SemanticGraphUtils");
        Method mRender=sgu.getDeclaredMethod("render",GrammaticalStructure.class,String.class);
        mRender.invoke(null,gs,"Collapsed, CC processed deps");
      }
 catch (      Exception e) {
        throw new RuntimeException("Couldn't use swing to portray semantic graph",e);
      }
    }
  }
}
