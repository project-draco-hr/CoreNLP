{
  String[] how=nonTerminalInfo.get(motherKey);
  Tree theHead=null;
  int headIdx=0;
  String childCat;
  boolean found=false;
  if (how == null) {
    if (DEBUG) {
      System.err.println("Warning: No rule found for " + motherKey);
    }
    return null;
  }
  String direction=how[0];
  if (coordSwitch) {
    if (how[0].equals("left")) {
      direction="right";
    }
    if (how[0].equals("right")) {
      direction="left";
    }
  }
  if (direction.equals("left")) {
    twoloop:     for (int i=1; i < how.length; i++) {
      for (headIdx=0; headIdx < daughterTrees.length; headIdx++) {
        childCat=tlp.basicCategory(daughterTrees[headIdx].label().value());
        if (how[i].equals(childCat)) {
          theHead=daughterTrees[headIdx];
          found=true;
          break twoloop;
        }
      }
    }
    if (!found) {
      if (deflt) {
        headIdx=0;
        theHead=daughterTrees[headIdx];
      }
 else {
        return null;
      }
    }
  }
 else   if (direction.equals("rightdis")) {
    twoloop:     for (headIdx=daughterTrees.length - 1; headIdx >= 0; headIdx--) {
      childCat=tlp.basicCategory(daughterTrees[headIdx].label().value());
      for (int i=1; i < how.length; i++) {
        if (DEBUG) {
          System.err.println("Testing for whether " + how[i] + " == "+ childCat+ ": "+ ((how[i].equals(childCat)) ? "true" : "false"));
        }
        if (how[i].equals(childCat)) {
          theHead=daughterTrees[headIdx];
          found=true;
          break twoloop;
        }
      }
    }
    if (!found) {
      if (deflt) {
        headIdx=daughterTrees.length - 1;
        theHead=daughterTrees[headIdx];
      }
 else {
        return null;
      }
    }
  }
 else {
    twoloop:     for (int i=1; i < how.length; i++) {
      for (headIdx=daughterTrees.length - 1; headIdx >= 0; headIdx--) {
        childCat=tlp.basicCategory(daughterTrees[headIdx].label().value());
        if (how[i].equals(childCat)) {
          theHead=daughterTrees[headIdx];
          found=true;
          break twoloop;
        }
      }
    }
    if (!found) {
      if (deflt) {
        headIdx=daughterTrees.length - 1;
        theHead=daughterTrees[headIdx];
      }
 else {
        return null;
      }
    }
  }
  if (DEBUG) {
    System.err.println("Head for " + motherKey + " chose index "+ headIdx+ " "+ theHead.label());
  }
  return theHead;
}
