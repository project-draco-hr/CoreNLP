{
  Annotation output=mr.annotate(annotation);
  List<CoreMap> outputSentences=output.get(SentencesAnnotation.class);
  List<CoreMap> origSentences=annotation.get(SentencesAnnotation.class);
  for (int i=0; i < outputSentences.size(); i++) {
    CoreMap outSent=outputSentences.get(i);
    CoreMap origSent=origSentences.get(i);
    List<EntityMention> entities=outSent.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);
    origSent.set(MachineReadingAnnotations.EntityMentionsAnnotation.class,entities);
    if (verbose && entities != null) {
      System.err.println("Extracted the following entities:");
      for (      EntityMention e : entities) {
        System.err.println("\t" + e);
      }
    }
    if (origSent.get(MachineReadingAnnotations.EntityMentionsAnnotation.class) != null) {
      for (      EntityMention em : origSent.get(MachineReadingAnnotations.EntityMentionsAnnotation.class)) {
        normalizeTeamName(em,origSentences,i);
      }
    }
    List<RelationMention> relations=outSent.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);
    origSent.set(MachineReadingAnnotations.RelationMentionsAnnotation.class,relations);
    if (verbose && relations != null) {
      System.err.println("Extracted the following relations:");
      for (      RelationMention r : relations) {
        if (!r.getType().equals(RelationMention.UNRELATED)) {
          System.err.println(r);
        }
      }
    }
    boolean verboseRevert=false;
    String origText=annotation.get(CoreAnnotations.TextAnnotation.class);
    if (origText == null)     throw new RuntimeException("Found corpus without text!");
    if (verboseRevert)     System.err.println("REVERTING SENT: " + origSent.get(TextAnnotation.class));
    List<CoreLabel> tokens=origSent.get(TokensAnnotation.class);
    List<Pair<Integer,String>> changes=new ArrayList<Pair<Integer,String>>();
    int position=0;
    for (    CoreLabel token : tokens) {
      String tokenText=token.word();
      if (verboseRevert)       System.err.println("TOKEN " + tokenText + " "+ token.beginPosition()+ " "+ token.endPosition());
      String origToken=origText.substring(token.beginPosition(),token.endPosition());
      if (!origToken.equals(tokenText)) {
        if (verboseRevert)         System.err.println("Found difference at position #" + position + ": token ["+ tokenText+ "] vs text ["+ origToken+ "]");
        token.set(TextAnnotation.class,origToken);
        changes.add(new Pair<Integer,String>(position,origToken));
      }
      position++;
    }
    Tree tree=origSent.get(TreeAnnotation.class);
    if (tree != null && changes.size() > 0) {
      List<Tree> leaves=tree.getLeaves();
      for (      Pair<Integer,String> change : changes) {
        Tree leaf=leaves.get(change.first);
        if (verboseRevert)         System.err.println("CHANGING LEAF " + leaf);
        leaf.setValue(change.second);
        if (verboseRevert)         System.err.println("NEW LEAF: " + leaf);
      }
    }
  }
}
