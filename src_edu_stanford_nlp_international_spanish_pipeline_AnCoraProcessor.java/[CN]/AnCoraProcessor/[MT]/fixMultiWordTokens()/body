{
  final boolean ner=PropertiesUtils.getBool(options,"ner",false);
  final TreeNormalizer tn=new SpanishTreeNormalizer(true,false,false);
  final TreeFactory tf=new LabeledScoredTreeFactory();
  int availableProcessors=Runtime.getRuntime().availableProcessors();
  ExecutorService pool=Executors.newFixedThreadPool(availableProcessors);
  int numChunks=availableProcessors * 20;
  List<Collection<Tree>> chunked=CollectionUtils.partitionIntoFolds(trees,numChunks);
  List<Future<List<Tree>>> futures=new ArrayList<Future<List<Tree>>>();
  for (  final Collection<Tree> coll : chunked) {
    futures.add(pool.submit(new Callable<List<Tree>>(){
      @Override public List<Tree> call(){
        List<Tree> ret=new ArrayList<Tree>();
        MultiWordTreeExpander expander=new MultiWordTreeExpander();
        for (        Tree t : coll) {
          MultiWordPreprocessor.traverseAndFix(t,null,unigramTagger,ner);
          t=expander.expandPhrases(t,tn,tf);
          t=tn.normalizeWholeTree(t,tf);
          ret.add(t);
        }
        return ret;
      }
    }
));
  }
  List<Tree> ret=new ArrayList<Tree>();
  for (  Future<List<Tree>> future : futures)   ret.addAll(future.get());
  pool.shutdown();
  return ret;
}
