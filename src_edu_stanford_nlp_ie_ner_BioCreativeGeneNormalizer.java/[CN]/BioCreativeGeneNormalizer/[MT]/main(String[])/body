{
  if (args.length < 2 || args.length > 6) {
    System.err.println("Usage: BioCreativeGeneNormalizer <synonymFile> <testFile> [-train <trainFile>] [-prop <properties file>]");
    System.exit(1);
  }
  int disambiguate=DA_REJECT;
  String synonymFile=args[0];
  String testFile=args[1];
  String trainFile=null;
  Properties props=defaultProperties();
  for (int index=2; index < args.length; index++) {
    if (args[index].equalsIgnoreCase("-prop") && args.length > index + 1) {
      index++;
      try {
        Properties newProps=new Properties();
        newProps.load(new BufferedInputStream(new FileInputStream(args[index])));
        props.putAll(newProps);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      continue;
    }
 else     if (args[index].equalsIgnoreCase("-train") && args.length > index + 1) {
      index++;
      trainFile=args[index];
      continue;
    }
 else {
      System.err.println("Unrecognized command-line argument: " + args[index]);
      System.exit(1);
    }
  }
  BioCreativeSynonymMap synMap=new BioCreativeSynonymMap();
  synMap.load(new File(synonymFile));
  if ("true".equals(props.getProperty(disambiguateProp))) {
    disambiguate=DA_DISAMBIGUATE;
  }
 else   if ("accept".equals(props.getProperty(disambiguateProp))) {
    disambiguate=DA_ACCEPT;
  }
  if (disambiguate == DA_DISAMBIGUATE) {
    if (props.containsKey(trainFileProp)) {
      trainFile=props.getProperty(trainFileProp);
    }
    if (trainFile != null) {
      cm=new CooccurrenceModel();
      System.err.println("Initializing co-occurrence matrix...");
      cm.initialize(trainFile);
      System.err.println("Done.");
    }
 else {
      System.err.println("trainFile must be specified if disambiguous is specified");
      System.exit(1);
    }
  }
  GeneMatcher[] matchers;
  if (!props.containsKey(matchersProp)) {
    matchers=new GeneMatcher[]{new RegexpGeneMatcher()};
  }
 else {
    String[] matcherClasses=props.getProperty(matchersProp).split(";");
    matchers=new GeneMatcher[matcherClasses.length];
    for (int i=0; i < matcherClasses.length; i++) {
      try {
        matchers[i]=(GeneMatcher)Class.forName(matcherClasses[i]).newInstance();
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  for (int i=0; i < matchers.length; i++) {
    matchers[i].setProperties(props);
    matchers[i].setSynonymMap(synMap);
  }
  String line;
  String curFile=null;
  Set<GeneEvidencePair> genes=new HashSet<GeneEvidencePair>();
  Set<GeneIDPair> ambiguous=new HashSet<GeneIDPair>();
  Set<String> ids=null;
  try {
    BufferedReader br=new BufferedReader(new FileReader(testFile));
    while ((line=br.readLine()) != null) {
      String[] fields=line.split("\\|");
      if (fields.length == 3) {
        if (curFile != null && !curFile.equals(fields[0])) {
          if (disambiguate == DA_DISAMBIGUATE && ambiguous.size() > 0) {
            disambiguate(genes,ambiguous);
          }
          printGenes(genes,curFile);
          genes=new HashSet<GeneEvidencePair>();
          ambiguous=new HashSet<GeneIDPair>();
        }
        curFile=fields[0];
        for (int i=0; i < matchers.length; i++) {
          ids=matchers[i].getIDs(fields[2]);
          if (ids.size() > 0) {
            break;
          }
        }
        if (ids.size() == 0) {
          System.err.println("NOT FOUND:" + fields[0] + ":"+ fields[2]);
        }
 else {
          if (ids.size() == 1) {
            String gene=ids.iterator().next();
            genes.add(new GeneEvidencePair(gene,fields[2]));
          }
 else           if (disambiguate == DA_ACCEPT) {
            for (Iterator<String> iter=ids.iterator(); iter.hasNext(); ) {
              genes.add(new GeneEvidencePair(iter.next(),fields[2]));
            }
          }
 else {
            if (disambiguate == DA_DISAMBIGUATE) {
              ambiguous.add(new GeneIDPair(fields[2],ids));
            }
 else {
              System.err.println("AMBIGUOUS:" + fields[0] + ":"+ fields[2]+ ":"+ ids.size());
            }
          }
        }
      }
    }
    if (genes.size() > 0) {
      printGenes(genes,curFile);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}
