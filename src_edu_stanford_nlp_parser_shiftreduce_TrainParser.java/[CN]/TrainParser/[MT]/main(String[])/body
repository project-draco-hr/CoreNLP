{
  List<String> remainingArgs=Generics.newArrayList();
  String trainTreebankPath=null;
  FileFilter trainTreebankFilter=null;
  for (int argIndex=0; argIndex < args.length; ) {
    if (args[argIndex].equalsIgnoreCase("-treebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-treebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      trainTreebankPath=treebankDescription.first();
      trainTreebankFilter=treebankDescription.second();
    }
 else {
      remainingArgs.add(args[argIndex]);
      ++argIndex;
    }
  }
  Options op=new Options();
  CompositeTreeTransformer transformer=LexicalizedParser.buildTrainTransformer(op);
  BasicCategoryTreeTransformer basicTransformer=new BasicCategoryTreeTransformer(op.langpack());
  transformer.addTransformer(basicTransformer);
  if (trainTreebankPath == null) {
    throw new IllegalArgumentException("Must specify a treebank to train from with -treebank");
  }
  System.err.println("Loading training trees from " + trainTreebankPath);
  Treebank treebank=op.tlpParams.memoryTreebank();
  ;
  treebank.loadPath(trainTreebankPath,trainTreebankFilter);
  treebank=treebank.transform(transformer);
  System.err.println("Read in " + treebank.size() + " trees from "+ trainTreebankPath);
  HeadFinder binaryHeadFinder=new BinaryHeadFinder(op.tlpParams.headFinder());
  List<Tree> binarizedTrees=Generics.newArrayList();
  for (  Tree tree : treebank) {
    Trees.convertToCoreLabels(tree);
    tree.percolateHeadAnnotations(binaryHeadFinder);
    binarizedTrees.add(tree);
  }
  FeatureFactory featureFactory=new BasicFeatureFactory();
  Index<Transition> transitionIndex=new HashIndex<Transition>();
  Index<String> featureIndex=new HashIndex<String>();
  for (  Tree tree : binarizedTrees) {
    List<Transition> transitions=CreateTransitionSequence.createTransitionSequence(tree);
    transitionIndex.addAll(transitions);
    State state=initialStateFromTrainingTree(tree);
    for (    Transition transition : transitions) {
      Set<String> features=featureFactory.featurize(state);
      featureIndex.addAll(features);
      state=transition.apply(state);
    }
  }
}
