{
  List<String> remainingArgs=Generics.newArrayList();
  String trainTreebankPath=null;
  FileFilter trainTreebankFilter=null;
  String testTreebankPath=null;
  FileFilter testTreebankFilter=null;
  int numTrainingIterations=10;
  String serializedPath=null;
  for (int argIndex=0; argIndex < args.length; ) {
    if (args[argIndex].equalsIgnoreCase("-trainTreebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-trainTreebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      trainTreebankPath=treebankDescription.first();
      trainTreebankFilter=treebankDescription.second();
    }
 else     if (args[argIndex].equalsIgnoreCase("-testTreebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-testTreebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      testTreebankPath=treebankDescription.first();
      testTreebankFilter=treebankDescription.second();
    }
 else     if (args[argIndex].equalsIgnoreCase("-numTrainingIterations")) {
      numTrainingIterations=Integer.valueOf(args[argIndex + 1]);
      argIndex+=2;
    }
 else     if (args[argIndex].equalsIgnoreCase("-serializedPath")) {
      serializedPath=args[argIndex + 1];
      argIndex+=2;
    }
 else {
      remainingArgs.add(args[argIndex]);
      ++argIndex;
    }
  }
  if (trainTreebankPath == null && serializedPath == null) {
    throw new IllegalArgumentException("Must specify a treebank to train from with -trainTreebank");
  }
  ShiftReduceParser parser=null;
  if (trainTreebankPath != null) {
    Options op=new Options();
    CompositeTreeTransformer transformer=LexicalizedParser.buildTrainTransformer(op);
    BasicCategoryTreeTransformer basicTransformer=new BasicCategoryTreeTransformer(op.langpack());
    transformer.addTransformer(basicTransformer);
    System.err.println("Loading training trees from " + trainTreebankPath);
    Treebank trainTreebank=op.tlpParams.memoryTreebank();
    ;
    trainTreebank.loadPath(trainTreebankPath,trainTreebankFilter);
    trainTreebank=trainTreebank.transform(transformer);
    System.err.println("Read in " + trainTreebank.size() + " trees from "+ trainTreebankPath);
    HeadFinder binaryHeadFinder=new BinaryHeadFinder(op.tlpParams.headFinder());
    List<Tree> binarizedTrees=Generics.newArrayList();
    for (    Tree tree : trainTreebank) {
      Trees.convertToCoreLabels(tree);
      tree.percolateHeadAnnotations(binaryHeadFinder);
      binarizedTrees.add(tree);
    }
    FeatureFactory featureFactory=new BasicFeatureFactory();
    Index<Transition> transitionIndex=new HashIndex<Transition>();
    Index<String> featureIndex=new HashIndex<String>();
    for (    Tree tree : binarizedTrees) {
      List<Transition> transitions=CreateTransitionSequence.createTransitionSequence(tree);
      transitionIndex.addAll(transitions);
      State state=initialStateFromGoldTagTree(tree);
      for (      Transition transition : transitions) {
        Set<String> features=featureFactory.featurize(state);
        featureIndex.addAll(features);
        state=transition.apply(state);
      }
    }
    System.err.println("Number of unique features: " + featureIndex.size());
    System.err.println("Number of transitions: " + transitionIndex.size());
    System.err.println("Feature space will be " + (featureIndex.size() * transitionIndex.size()));
    double[][] featureWeights=new double[transitionIndex.size()][featureIndex.size()];
    for (int i=0; i < numTrainingIterations; ++i) {
      int numCorrect=0;
      int numWrong=0;
      for (      Tree tree : binarizedTrees) {
        List<Transition> transitions=CreateTransitionSequence.createTransitionSequence(tree);
        State state=initialStateFromGoldTagTree(tree);
        for (        Transition transition : transitions) {
          int transitionNum=transitionIndex.indexOf(transition);
          Set<String> features=featureFactory.featurize(state);
          int predictedNum=findHighestScoringTransition(featureIndex,transitionIndex,featureWeights,state,features,false);
          Transition predicted=transitionIndex.get(predictedNum);
          if (transitionNum == predictedNum) {
            numCorrect++;
          }
 else {
            numWrong++;
            for (            String feature : features) {
              int featureNum=featureIndex.indexOf(feature);
              featureWeights[predictedNum][featureNum]-=1.0;
              featureWeights[transitionNum][featureNum]+=1.0;
            }
          }
          state=transition.apply(state);
        }
      }
      System.err.println("Iteration " + i + " complete");
      System.err.println("While training, got " + numCorrect + " transitions correct and "+ numWrong+ " transitions wrong");
    }
    parser=new ShiftReduceParser(transitionIndex,featureIndex,featureWeights,op,featureFactory);
    if (serializedPath != null) {
      try {
        IOUtils.writeObjectToFile(parser,serializedPath);
      }
 catch (      IOException e) {
        throw new RuntimeIOException(e);
      }
    }
  }
  if (serializedPath != null && parser == null) {
    try {
      parser=IOUtils.readObjectFromFile(serializedPath);
    }
 catch (    IOException e) {
      throw new RuntimeIOException(e);
    }
catch (    ClassNotFoundException e) {
      throw new RuntimeIOException(e);
    }
  }
  if (testTreebankPath != null) {
    System.err.println("Loading test trees from " + testTreebankPath);
    Treebank testTreebank=parser.op.tlpParams.memoryTreebank();
    testTreebank.loadPath(testTreebankPath,testTreebankFilter);
    for (    Tree tree : testTreebank) {
      State state=initialStateFromGoldTagTree(tree);
      List<Transition> transitions=Generics.newArrayList();
      while (!state.finished) {
        Set<String> features=parser.featureFactory.featurize(state);
        int predictedNum=findHighestScoringTransition(parser.featureIndex,parser.transitionIndex,parser.featureWeights,state,features,true);
        Transition transition=parser.transitionIndex.get(predictedNum);
        state=transition.apply(state);
        transitions.add(transition);
      }
      System.err.println("Input tree: " + tree);
      System.err.println("Parsed tree: " + state.stack.peek());
      System.err.println("Predicted transition sequence: " + transitions);
    }
  }
}
