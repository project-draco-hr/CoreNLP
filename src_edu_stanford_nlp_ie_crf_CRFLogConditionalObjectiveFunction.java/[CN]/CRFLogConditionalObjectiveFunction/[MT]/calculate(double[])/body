{
  double prob=0.0;
  to2D(x,weights);
  if (prior == DROPOUT_PRIOR) {
    if (weightSquare == null) {
      weightSquare=new double[weights.length][];
      for (int i=0; i < weights.length; i++)       weightSquare[i]=new double[weights[i].length];
    }
    double w=0;
    for (int i=0; i < weights.length; i++) {
      for (int j=0; j < weights[i].length; j++) {
        w=weights[i][j];
        weightSquare[i][j]=w * w;
      }
    }
  }
  clear2D(E);
  if (prior != DROPOUT_PRIOR) {
    if (multiThreadGrad == 1) {
      for (int m=0; m < data.length; m++) {
        prob+=expectedCountsAndValueForADoc(weights,E,m);
      }
    }
 else {
      MulticoreWrapper<Pair<Integer,List<Integer>>,Pair<Integer,Double>> wrapper=new MulticoreWrapper<Pair<Integer,List<Integer>>,Pair<Integer,Double>>(multiThreadGrad,threadProcessor);
      int batchSize=totalData.length / multiThreadGrad;
      int index=0;
      for (int tCount=0; tCount < multiThreadGrad; tCount++) {
        int endIndex=index + batchSize;
        if (tCount == multiThreadGrad - 1)         endIndex=totalData.length;
        List<Integer> docIndices=new ArrayList<Integer>(endIndex - index);
        for (int ind=index; ind < endIndex; ind++)         docIndices.add(ind);
        wrapper.put(new Pair<Integer,List<Integer>>(tCount,docIndices));
        while (wrapper.peek()) {
          Pair<Integer,Double> result=wrapper.poll();
          int doneTCount=result.first();
          double batchProb=result.second();
          prob+=batchProb;
          combine2DArr(E,batchE[doneTCount]);
        }
        index=endIndex;
      }
      wrapper.join();
      while (wrapper.peek()) {
        Pair<Integer,Double> result=wrapper.poll();
        int doneTCount=result.first();
        double batchProb=result.second();
        prob+=batchProb;
        combine2DArr(E,batchE[doneTCount]);
      }
    }
  }
 else {
    MulticoreWrapper<Triple<Integer,Boolean,double[][]>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>> wrapper=new MulticoreWrapper<Triple<Integer,Boolean,double[][]>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>>(multiThreadGrad,dropoutPriorThreadProcessor);
    for (int m=0; m < totalData.length; m++) {
      boolean submitIsUnsup=(m >= unsupDropoutStartIndex);
      wrapper.put(new Triple<Integer,Boolean,double[][]>(m,submitIsUnsup,weights));
      while (wrapper.peek()) {
        Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
        int docIndex=result.first();
        boolean isUnsup=docIndex >= unsupDropoutStartIndex;
        if (isUnsup) {
          prob+=unsupDropoutScale * result.second();
        }
 else {
          prob+=result.second();
        }
        Map<Integer,double[]> partialDropout=result.fourth();
        if (partialDropout != null) {
          if (isUnsup) {
            combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
          }
 else {
            combine2DArr(dropoutPriorGrad,partialDropout);
          }
        }
        if (!isUnsup) {
          Map<Integer,double[]> partialE=result.third();
          if (partialE != null)           combine2DArr(E,partialE);
        }
      }
    }
    wrapper.join();
    while (wrapper.peek()) {
      Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
      int docIndex=result.first();
      boolean isUnsup=docIndex >= unsupDropoutStartIndex;
      if (isUnsup) {
        prob+=unsupDropoutScale * result.second();
      }
 else {
        prob+=result.second();
      }
      Map<Integer,double[]> partialDropout=result.fourth();
      if (partialDropout != null) {
        if (isUnsup) {
          combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
        }
 else {
          combine2DArr(dropoutPriorGrad,partialDropout);
        }
      }
      if (!isUnsup) {
        Map<Integer,double[]> partialE=result.third();
        if (partialE != null)         combine2DArr(E,partialE);
      }
    }
  }
  if (Double.isNaN(prob)) {
    throw new RuntimeException("Got NaN for prob in CRFLogConditionalObjectiveFunction.calculate()" + " - this may well indicate numeric underflow due to overly long documents.");
  }
  value=-prob;
  if (VERBOSE) {
    System.err.println("value is " + Math.exp(-value));
  }
  int index=0;
  for (int i=0; i < E.length; i++) {
    for (int j=0; j < E[i].length; j++) {
      derivative[index]=(E[i][j] - Ehat[i][j]);
      if (prior == DROPOUT_PRIOR) {
        derivative[index]+=dropoutScale * dropoutPriorGrad[i][j];
      }
      if (VERBOSE) {
        System.err.println("deriv(" + i + ","+ j+ ") = "+ E[i][j]+ " - "+ Ehat[i][j]+ " = "+ derivative[index]);
      }
      index++;
    }
  }
  applyPrior(x,1.0);
}
