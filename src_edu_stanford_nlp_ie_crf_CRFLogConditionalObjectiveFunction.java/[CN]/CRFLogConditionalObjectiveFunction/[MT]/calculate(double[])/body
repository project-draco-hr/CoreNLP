{
  double prob=0.0;
  final double[][] weights=to2D(x);
  if (prior == DROPOUT_PRIOR) {
    if (weightSquare == null) {
      weightSquare=new double[weights.length][];
      for (int i=0; i < weights.length; i++)       weightSquare[i]=new double[weights[i].length];
    }
    double w=0;
    for (int i=0; i < weights.length; i++) {
      for (int j=0; j < weights[i].length; j++) {
        w=weights[i][j];
        weightSquare[i][j]=w * w;
      }
    }
  }
  double[][] E=empty2D();
  double[][] dropoutPriorGrad=null;
  if (prior == DROPOUT_PRIOR)   dropoutPriorGrad=empty2D();
  if (multiThreadGrad == 0) {
    for (int m=0; m < data.length; m++) {
      prob+=expectedCountsAndValueForADoc(weights,E,m);
    }
  }
 else {
    MulticoreWrapper<Triple<Integer,Boolean,double[][]>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>> wrapper=new MulticoreWrapper<Triple<Integer,Boolean,double[][]>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>>(multiThreadGrad,threadProcessor);
    for (int m=0; m < totalData.length; m++) {
      boolean submitIsUnsup=(m >= unsupDropoutStartIndex);
      wrapper.put(new Triple<Integer,Boolean,double[][]>(m,submitIsUnsup,weights));
      while (wrapper.peek()) {
        Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
        int docIndex=result.first();
        boolean isUnsup=docIndex >= unsupDropoutStartIndex;
        if (isUnsup) {
          prob+=unsupDropoutScale * result.second();
        }
 else {
          prob+=result.second();
        }
        Map<Integer,double[]> partialDropout=result.fourth();
        if (partialDropout != null) {
          if (isUnsup) {
            combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
          }
 else {
            combine2DArr(dropoutPriorGrad,partialDropout);
          }
        }
        if (!isUnsup) {
          Map<Integer,double[]> partialE=result.third();
          if (partialE != null)           combine2DArr(E,partialE);
        }
      }
    }
    wrapper.join();
    while (wrapper.peek()) {
      Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
      int docIndex=result.first();
      boolean isUnsup=docIndex >= unsupDropoutStartIndex;
      if (isUnsup) {
        prob+=unsupDropoutScale * result.second();
      }
 else {
        prob+=result.second();
      }
      Map<Integer,double[]> partialDropout=result.fourth();
      if (partialDropout != null) {
        if (isUnsup) {
          combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
        }
 else {
          combine2DArr(dropoutPriorGrad,partialDropout);
        }
      }
      if (!isUnsup) {
        Map<Integer,double[]> partialE=result.third();
        if (partialE != null)         combine2DArr(E,partialE);
      }
    }
  }
  if (Double.isNaN(prob)) {
    throw new RuntimeException("Got NaN for prob in CRFLogConditionalObjectiveFunction.calculate()" + " - this may well indicate numeric underflow due to overly long documents.");
  }
  value=-prob;
  if (VERBOSE) {
    System.err.println("value is " + Math.exp(-value));
  }
  int index=0;
  for (int i=0; i < E.length; i++) {
    for (int j=0; j < E[i].length; j++) {
      derivative[index]=(E[i][j] - Ehat[i][j]);
      if (prior == DROPOUT_PRIOR) {
        derivative[index]+=dropoutScale * dropoutPriorGrad[i][j];
      }
      if (VERBOSE) {
        System.err.println("deriv(" + i + ","+ j+ ") = "+ E[i][j]+ " - "+ Ehat[i][j]+ " = "+ derivative[index]);
      }
      index++;
    }
  }
  applyPrior(x,1.0);
}
