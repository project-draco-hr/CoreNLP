{
  double prob=0.0;
  to2D(x,weights);
  setWeights(weights);
  clear2D(E);
  MulticoreWrapper<Pair<Integer,List<Integer>>,Pair<Integer,Double>> wrapper=new MulticoreWrapper<Pair<Integer,List<Integer>>,Pair<Integer,Double>>(multiThreadGrad,gradientThreadProcessor);
  int totalLen=data.length;
  List<Integer> docIDs=new ArrayList<Integer>(totalLen);
  for (int m=0; m < totalLen; m++)   docIDs.add(m);
  int partLen=totalLen / multiThreadGrad;
  int currIndex=0;
  for (int part=0; part < multiThreadGrad; part++) {
    int endIndex=currIndex + partLen;
    if (part == multiThreadGrad - 1)     endIndex=totalLen;
    List<Integer> subList=docIDs.subList(currIndex,endIndex);
    wrapper.put(new Pair<Integer,List<Integer>>(part,subList));
    currIndex=endIndex;
  }
  wrapper.join();
  while (wrapper.peek()) {
    Pair<Integer,Double> result=wrapper.poll();
    int tID=result.first();
    prob+=result.second();
    combine2DArr(E,parallelE[tID]);
  }
  if (Double.isNaN(prob)) {
    throw new RuntimeException("Got NaN for prob in CRFLogConditionalObjectiveFunction.calculate()" + " - this may well indicate numeric underflow due to overly long documents.");
  }
  value=-prob;
  if (VERBOSE) {
    System.err.println("value is " + Math.exp(-value));
  }
  int index=0;
  for (int i=0; i < E.length; i++) {
    for (int j=0; j < E[i].length; j++) {
      derivative[index]=(E[i][j] - Ehat[i][j]);
      if (VERBOSE) {
        System.err.println("deriv(" + i + ","+ j+ ") = "+ E[i][j]+ " - "+ Ehat[i][j]+ " = "+ derivative[index]);
      }
      index++;
    }
  }
  applyPrior(x,1.0);
}
