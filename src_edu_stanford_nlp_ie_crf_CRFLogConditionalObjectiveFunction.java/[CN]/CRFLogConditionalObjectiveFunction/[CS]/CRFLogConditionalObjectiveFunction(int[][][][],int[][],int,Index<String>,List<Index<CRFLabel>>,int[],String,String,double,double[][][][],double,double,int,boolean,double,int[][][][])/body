{
  this.window=window;
  this.classIndex=classIndex;
  this.numClasses=classIndex.size();
  this.labelIndices=labelIndices;
  this.map=map;
  this.data=data;
  this.featureVal=featureVal;
  this.labels=labels;
  this.prior=getPriorType(priorType);
  this.backgroundSymbol=backgroundSymbol;
  this.sigma=sigma;
  this.delta=delta;
  this.dropoutScale=dropoutScale;
  this.dropoutApprox=dropoutApprox;
  this.multiThreadGrad=multiThreadGrad;
  Ehat=empty2D();
  E=empty2D();
  if (multiThreadGrad > 1 && prior != DROPOUT_PRIOR) {
    batchE=new double[multiThreadGrad][][];
    for (int t=0; t < multiThreadGrad; t++)     batchE[t]=empty2D();
  }
  weights=empty2D();
  if (prior == DROPOUT_PRIOR)   dropoutPriorGrad=empty2D();
  empiricalCounts(Ehat);
  int myDomainDimension=0;
  for (  int dim : map) {
    myDomainDimension+=labelIndices.get(dim).size();
  }
  this.unsupDropoutStartIndex=data.length;
  this.unsupDropoutScale=unsupDropoutScale;
  if (unsupDropoutData != null) {
    this.totalData=new int[data.length + unsupDropoutData.length][][][];
    for (int i=0; i < data.length; i++) {
      this.totalData[i]=data[i];
    }
    for (int i=0; i < unsupDropoutData.length; i++) {
      this.totalData[i + unsupDropoutStartIndex]=unsupDropoutData[i];
    }
  }
 else {
    this.totalData=data;
  }
  domainDimension=myDomainDimension;
  if (prior == DROPOUT_PRIOR) {
    initEdgeLabels();
    initializeDataFeatureHash();
  }
}
