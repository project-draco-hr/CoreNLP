{
  TwoDimensionalCounter<Pair<String,String>,SurfacePattern> wordsandLemmaPatExtracted=new TwoDimensionalCounter<Pair<String,String>,SurfacePattern>();
  if (constVars.doNotApplyPatterns) {
    for (    Entry<String,List<CoreLabel>> sentEn : Data.sents.entrySet()) {
      Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>> pat4Sent=patternsForEachToken.get(sentEn.getKey());
      if (pat4Sent == null) {
        throw new RuntimeException("How come there are no patterns for " + sentEn.getKey() + ". The total patternsForEachToken size is "+ patternsForEachToken.size()+ " and keys "+ patternsForEachToken.keySet());
      }
      for (      Entry<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>> en : pat4Sent.entrySet()) {
        CoreLabel token=null;
        Set<SurfacePattern> p1=en.getValue().first();
        Set<SurfacePattern> p2=en.getValue().second();
        Set<SurfacePattern> p3=en.getValue().third();
        for (        SurfacePattern p : patternsLearnedThisIter.keySet()) {
          if (p1.contains(p) || p2.contains(p) || p3.contains(p)) {
            if (token == null)             token=sentEn.getValue().get(en.getKey());
            wordsandLemmaPatExtracted.incrementCount(new Pair<String,String>(token.word(),token.lemma()),p);
          }
        }
      }
    }
  }
 else {
    if (constVars.batchProcessSents) {
      for (      File f : Data.sentsFiles) {
        Redwood.log(Redwood.DBG,"Applying patterns to sents from " + f);
        Map<String,List<CoreLabel>> sents=IOUtils.readObjectFromFile(f);
        this.runParallelApplyPats(sents,label,patternsLearnedThisIter,wordsandLemmaPatExtracted,matchedTokensByPat);
        if (computeDataFreq)         Data.computeRawFreqIfNull(sents,constVars.numWordsCompound);
      }
    }
 else {
      this.runParallelApplyPats(Data.sents,label,patternsLearnedThisIter,wordsandLemmaPatExtracted,matchedTokensByPat);
      Data.computeRawFreqIfNull(Data.sents,constVars.numWordsCompound);
    }
  }
  if (constVars.wordScoring.equals(WordScoring.WEIGHTEDNORM)) {
    for (    Pair<String,String> en : wordsandLemmaPatExtracted.firstKeySet()) {
      if (!constVars.getOtherSemanticClasses().contains(en.first()) && !constVars.getOtherSemanticClasses().contains(en.second())) {
        terms.addAll(en.first(),wordsandLemmaPatExtracted.getCounter(en));
      }
      wordsPatExtracted.addAll(en.first(),wordsandLemmaPatExtracted.getCounter(en));
    }
    removeKeys(terms,constVars.getStopWords());
    Counter<String> phraseScores=phraseScorer.scorePhrases(label,terms,wordsPatExtracted,allSelectedPatterns,alreadyIdentifiedWords,false);
    Set<String> ignoreWordsAll;
    if (ignoreWords != null && !ignoreWords.isEmpty()) {
      ignoreWordsAll=CollectionUtils.unionAsSet(ignoreWords,constVars.getOtherSemanticClasses());
    }
 else     ignoreWordsAll=constVars.getOtherSemanticClasses();
    Counter<String> finalwords=chooseTopWords(phraseScores,terms,phraseScores,ignoreWordsAll,constVars.thresholdWordExtract);
    scoreForAllWordsThisIteration.clear();
    Counters.addInPlace(scoreForAllWordsThisIteration,phraseScores);
    Redwood.log(ConstantsAndVariables.minimaldebug,"## Selected Words: " + Counters.toSortedString(finalwords,finalwords.size(),"%1$s:%2$.2f","\t"));
    if (constVars.outDir != null && !constVars.outDir.isEmpty()) {
      String outputdir=constVars.outDir + "/" + identifier+ "/"+ label;
      IOUtils.ensureDir(new File(outputdir));
      TwoDimensionalCounter<String,String> reasonForWords=new TwoDimensionalCounter<String,String>();
      for (      String word : finalwords.keySet()) {
        for (        SurfacePattern l : wordsPatExtracted.getCounter(word).keySet()) {
          for (          String w2 : patternsAndWords4Label.getCounter(l)) {
            reasonForWords.incrementCount(word,w2);
          }
        }
      }
      Redwood.log(ConstantsAndVariables.minimaldebug,"Saving output in " + outputdir);
      String filename=outputdir + "/words.json";
      JsonArrayBuilder obj=Json.createArrayBuilder();
      if (writtenInJustification.containsKey(label) && writtenInJustification.get(label)) {
        JsonReader jsonReader=Json.createReader(new BufferedInputStream(new FileInputStream(filename)));
        JsonArray objarr=jsonReader.readArray();
        for (        JsonValue o : objarr)         obj.add(o);
        jsonReader.close();
      }
      JsonArrayBuilder objThisIter=Json.createArrayBuilder();
      for (      String w : reasonForWords.firstKeySet()) {
        JsonObjectBuilder objinner=Json.createObjectBuilder();
        JsonArrayBuilder l=Json.createArrayBuilder();
        for (        String w2 : reasonForWords.getCounter(w).keySet()) {
          l.add(w2);
        }
        JsonArrayBuilder pats=Json.createArrayBuilder();
        for (        SurfacePattern p : wordsPatExtracted.getCounter(w)) {
          pats.add(p.toStringSimple());
        }
        objinner.add("reasonwords",l);
        objinner.add("patterns",pats);
        objinner.add("score",finalwords.getCount(w));
        objinner.add("entity",w);
        objThisIter.add(objinner.build());
      }
      obj.add(objThisIter);
      IOUtils.writeStringToFile(obj.build().toString(),filename,"utf8");
      writtenInJustification.put(label,true);
    }
    if (constVars.justify) {
      for (      String word : finalwords.keySet()) {
        Redwood.log(Redwood.DBG,word + "\t" + Counters.toSortedString(wordsPatExtracted.getCounter(word),wordsPatExtracted.getCounter(word).size(),"%1$s:%2$f","\n"));
      }
    }
    return finalwords;
  }
 else   if (constVars.wordScoring.equals(WordScoring.BPB)) {
    Counters.addInPlace(terms,wordsPatExtracted);
    Counter<String> maxPatWeightTerms=new ClassicCounter<String>();
    Map<String,SurfacePattern> wordMaxPat=new HashMap<String,SurfacePattern>();
    for (    Entry<String,ClassicCounter<SurfacePattern>> en : terms.entrySet()) {
      Counter<SurfacePattern> weights=new ClassicCounter<SurfacePattern>();
      for (      SurfacePattern k : en.getValue().keySet())       weights.setCount(k,patternsLearnedThisIter.getCount(k));
      maxPatWeightTerms.setCount(en.getKey(),Counters.max(weights));
      wordMaxPat.put(en.getKey(),Counters.argmax(weights));
    }
    Counters.removeKeys(maxPatWeightTerms,alreadyIdentifiedWords);
    double maxvalue=Counters.max(maxPatWeightTerms);
    Set<String> words=Counters.keysAbove(maxPatWeightTerms,maxvalue - 1e-10);
    String bestw=null;
    if (words.size() > 1) {
      double max=Double.NEGATIVE_INFINITY;
      for (      String w : words) {
        if (terms.getCount(w,wordMaxPat.get(w)) > max) {
          max=terms.getCount(w,wordMaxPat.get(w));
          bestw=w;
        }
      }
    }
 else     if (words.size() == 1)     bestw=words.iterator().next();
 else     return new ClassicCounter<String>();
    Redwood.log(ConstantsAndVariables.minimaldebug,"Selected Words: " + bestw);
    return Counters.asCounter(Arrays.asList(bestw));
  }
 else   throw new RuntimeException("wordscoring " + constVars.wordScoring + " not identified");
}
