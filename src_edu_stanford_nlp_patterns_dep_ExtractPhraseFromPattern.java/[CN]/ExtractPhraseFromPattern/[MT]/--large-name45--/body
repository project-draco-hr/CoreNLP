{
  try {
    if (seenNodes.contains(w))     return;
    seenNodes.add(w);
    if (doNotAddThese.contains(w))     return;
    List<IndexedWord> andNodes=new ArrayList<IndexedWord>();
    descendantsWithReln(g,w,"conj_and",new ArrayList<IndexedWord>(),andNodes);
    System.out.println("and nodes are " + andNodes);
    for (    IndexedWord w1 : andNodes) {
      printSubGraph(g,w1,additionalCutOffRels,textTokens,listOfOutput,listOfOutputIndices,seenNodes,doNotAddThese,findSubTrees,extractedPhrases,pattern,acceptWord,extractFeat);
    }
    doNotAddThese.addAll(andNodes);
    List<String> allCutOffRels=new ArrayList<String>();
    if (additionalCutOffRels != null)     allCutOffRels.addAll(additionalCutOffRels);
    allCutOffRels.addAll(cutoffRelations);
    Counter<String> feat=new ClassicCounter<String>();
    List<Pair<GrammaticalRelation,IndexedWord>> pt=g.parentPairs(w);
    for (    Pair<GrammaticalRelation,IndexedWord> en : pt) {
      feat.incrementCount("PARENTREL-" + en.first());
    }
    Set<IndexedWord> words=descendants(g,w,allCutOffRels,doNotAddThese,ignoreCommonTags,acceptWord,feat);
    feat.incrementCount("LENGTH-" + words.size());
    System.out.println("words are " + words);
    if (words.size() > 0) {
      int min=Integer.MAX_VALUE, max=-1;
      for (      IndexedWord word : words) {
        if (word.index() < min)         min=word.index();
        if (word.index() > max)         max=word.index();
      }
      IntPair indices;
      if ((max - min + 1) > maxPhraseLength) {
        max=min + maxPhraseLength - 1;
      }
      indices=new IntPair(min - 1,max - 1);
      String phrase=StringUtils.join(textTokens.subList(min - 1,max)," ");
      phrase=phrase.trim();
      System.out.println("phrase is " + phrase + " index is "+ indices+ " and maxphraselength is "+ maxPhraseLength+ " and descendentset is "+ words);
      ExtractedPhrase extractedPh=new ExtractedPhrase(min - 1,max - 1,pattern,phrase,feat);
      if (!listOfOutput.contains(phrase) && !doNotAddThese.contains(phrase)) {
        listOfOutput.add(phrase);
        if (!listOfOutputIndices.contains(indices)) {
          listOfOutputIndices.add(indices);
          extractedPhrases.add(extractedPh);
        }
        if (findSubTrees == true) {
          for (          IndexedWord word : words)           if (!seenNodes.contains(word))           printSubGraph(g,word,additionalCutOffRels,textTokens,listOfOutput,listOfOutputIndices,seenNodes,doNotAddThese,findSubTrees,extractedPhrases,pattern,acceptWord,extractFeat);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}
