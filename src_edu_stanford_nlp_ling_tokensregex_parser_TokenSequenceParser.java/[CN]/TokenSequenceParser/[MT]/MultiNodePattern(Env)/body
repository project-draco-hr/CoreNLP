{
  NodePattern pat;
  MultiNodePattern mp;
  Token v1, v2;
  int min=1, max=-1;
  jj_consume_token(50);
switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
case 22:
{
      if (jj_2_28(3)) {
        jj_consume_token(22);
        v1=jj_consume_token(NONNEGINT);
        jj_consume_token(24);
        min=Integer.parseInt(v1.image);
        max=Integer.parseInt(v1.image);
      }
 else       if (jj_2_29(4)) {
        jj_consume_token(22);
        v1=jj_consume_token(NONNEGINT);
        jj_consume_token(33);
        jj_consume_token(24);
        min=Integer.parseInt(v1.image);
      }
 else {
switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk) {
case 22:
{
            jj_consume_token(22);
            v1=jj_consume_token(NONNEGINT);
            jj_consume_token(33);
            v2=jj_consume_token(NONNEGINT);
            jj_consume_token(24);
            min=Integer.parseInt(v1.image);
            max=Integer.parseInt(v2.image);
            break;
          }
default :
        jj_la1[54]=jj_gen;
      jj_consume_token(-1);
    throw new ParseException();
}
}
break;
}
default :
jj_la1[55]=jj_gen;
;
}
pat=CoreMapWordPattern(env);
mp=new MultiCoreMapNodePattern(pat);
mp.setMinNodes(min);
mp.setMaxNodes(max);
{
if ("" != null) return mp;
}
throw new Error("Missing return statement in function");
}
