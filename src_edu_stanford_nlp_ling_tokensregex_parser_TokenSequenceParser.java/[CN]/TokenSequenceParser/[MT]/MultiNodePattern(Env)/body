{
  NodePattern pat;
  MultiNodePattern mp;
  Token v1, v2;
  int min=1, max=-1;
  jj_consume_token(49);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 21:
    if (jj_2_28(3)) {
      jj_consume_token(21);
      v1=jj_consume_token(NONNEGINT);
      jj_consume_token(23);
      min=Integer.parseInt(v1.image);
      max=Integer.parseInt(v1.image);
    }
 else     if (jj_2_29(4)) {
      jj_consume_token(21);
      v1=jj_consume_token(NONNEGINT);
      jj_consume_token(32);
      jj_consume_token(23);
      min=Integer.parseInt(v1.image);
    }
 else {
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
case 21:
        jj_consume_token(21);
      v1=jj_consume_token(NONNEGINT);
    jj_consume_token(32);
  v2=jj_consume_token(NONNEGINT);
jj_consume_token(23);
min=Integer.parseInt(v1.image);
max=Integer.parseInt(v2.image);
break;
default :
jj_la1[54]=jj_gen;
jj_consume_token(-1);
throw new ParseException();
}
}
break;
default :
jj_la1[55]=jj_gen;
;
}
pat=CoreMapWordPattern(env);
mp=new MultiCoreMapNodePattern(pat);
mp.setMinNodes(min);
mp.setMaxNodes(max);
{
if (true) return mp;
}
throw new Error("Missing return statement in function");
}
