{
  List<List<IN>> sentences=Generics.newArrayList();
  List<IN> currentSentence=new ArrayList<IN>();
  List<IN> lastSentence=null;
  boolean insideRegion=false;
  boolean lastTokenWasNewline=false;
  for (  IN o : words) {
    String word=getString(o);
    boolean forcedEnd=isForcedEndToken(o);
    if (DEBUG) {
      EncodingPrintWriter.err.println("Word is " + word,"UTF-8");
    }
    if (sentenceRegionBeginPattern != null && !insideRegion) {
      if (DEBUG) {
        System.err.println("  outside region; deleted");
      }
      if (sentenceRegionBeginPattern.matcher(word).matches()) {
        insideRegion=true;
        if (DEBUG) {
          System.err.println("  entering region");
        }
      }
      lastTokenWasNewline=false;
      continue;
    }
    if (lastSentence != null && currentSentence.isEmpty() && sentenceBoundaryFollowers.contains(word)) {
      lastSentence.add(o);
      if (DEBUG) {
        System.err.println("  added to last sentence");
      }
      lastTokenWasNewline=false;
      continue;
    }
    boolean newSent=false;
    if (sentenceBoundaryToDiscard.contains(word)) {
      if (newlineIsSentenceBreak == NewlineIsSentenceBreak.ALWAYS) {
        newSent=true;
      }
 else       if (newlineIsSentenceBreak == NewlineIsSentenceBreak.TWO_CONSECUTIVE) {
        if (lastTokenWasNewline) {
          newSent=true;
        }
      }
      lastTokenWasNewline=true;
      if (DEBUG) {
        System.err.println("  discarded sentence boundary");
      }
    }
 else {
      lastTokenWasNewline=false;
      if (xmlBreakElementsToDiscard != null && matchesXmlBreakElementToDiscard(word)) {
        newSent=true;
        if (DEBUG) {
          System.err.println("  is XML break element; discarded");
        }
      }
 else       if (sentenceRegionEndPattern != null && sentenceRegionEndPattern.matcher(word).matches()) {
        insideRegion=false;
        newSent=true;
        if (DEBUG) {
          System.err.println("  discarded; exiting region");
        }
      }
 else       if (sentenceBoundaryTokenPattern.matcher(word).matches()) {
        currentSentence.add(o);
        newSent=true;
        if (DEBUG) {
          System.err.println("  is sentence boundary; added to current");
        }
      }
 else       if (forcedEnd) {
        currentSentence.add(o);
        newSent=true;
        if (DEBUG) {
          System.err.println("  annotated to be the end of a sentence");
        }
      }
 else {
        currentSentence.add(o);
        if (DEBUG) {
          System.err.println("  added to current");
        }
      }
    }
    if (newSent && (!currentSentence.isEmpty() || allowEmptySentences)) {
      if (DEBUG) {
        System.err.println("  beginning new sentence");
      }
      sentences.add(currentSentence);
      lastSentence=currentSentence;
      currentSentence=new ArrayList<IN>();
    }
  }
  if (!currentSentence.isEmpty()) {
    sentences.add(currentSentence);
  }
  return sentences;
}
