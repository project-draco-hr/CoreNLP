{
  List<List<IN>> sentences=Generics.newArrayList();
  List<IN> currentSentence=new ArrayList<IN>();
  List<IN> lastSentence=null;
  boolean insideRegion=false;
  boolean inWaitForForcedEnd=false;
  for (  IN o : words) {
    String word;
    if (o instanceof HasWord) {
      HasWord h=(HasWord)o;
      word=h.word();
    }
 else     if (o instanceof String) {
      word=(String)o;
    }
 else     if (o instanceof CoreMap) {
      word=((CoreMap)o).get(CoreAnnotations.TextAnnotation.class);
    }
 else {
      throw new RuntimeException("Expected token to be either Word or String.");
    }
    boolean forcedEnd=false;
    boolean inMultiTokenExpr=false;
    if (o instanceof CoreMap) {
      CoreMap cm=(CoreMap)o;
      Boolean forcedEndValue=cm.get(CoreAnnotations.ForcedSentenceEndAnnotation.class);
      Boolean forcedUntilEndValue=cm.get(CoreAnnotations.ForcedSentenceUntilEndAnnotation.class);
      if (forcedEndValue != null)       forcedEnd=forcedEndValue;
 else       if (forcedUntilEndValue != null && forcedUntilEndValue)       inWaitForForcedEnd=true;
 else {
        MultiTokenTag mt=cm.get(CoreAnnotations.MentionTokenAnnotation.class);
        if (mt != null && !mt.isEnd()) {
          inMultiTokenExpr=true;
        }
      }
    }
    if (DEBUG) {
      EncodingPrintWriter.err.println("Word is " + word,"UTF-8");
    }
    if (!forcedEnd && sentenceRegionBeginPattern != null && !insideRegion) {
      if (sentenceRegionBeginPattern.matcher(word).matches()) {
        insideRegion=true;
      }
      if (DEBUG) {
        System.err.println("  outside region");
      }
      continue;
    }
    if (!forcedEnd && sentenceBoundaryFollowers.contains(word) && lastSentence != null && currentSentence.isEmpty()) {
      lastSentence.add(o);
      if (DEBUG) {
        System.err.println("  added to last");
      }
    }
 else {
      boolean newSent=false;
      if (inWaitForForcedEnd && !forcedEnd) {
        currentSentence.add(o);
        if (DEBUG) {
          System.err.println("  is in wait for forced end; added to current");
        }
      }
 else       if (inMultiTokenExpr && !forcedEnd) {
        currentSentence.add(o);
        if (DEBUG) {
          System.err.println("  is in multi token expr; added to current");
        }
      }
 else       if (matchesSentenceBoundaryToDiscard(word)) {
        newSent=true;
      }
 else       if (sentenceRegionEndPattern != null && sentenceRegionEndPattern.matcher(word).matches()) {
        insideRegion=false;
        newSent=true;
      }
 else       if (sentenceBoundaryTokenPattern.matcher(word).matches()) {
        currentSentence.add(o);
        if (DEBUG) {
          System.err.println("  is sentence boundary; added to current");
        }
        newSent=true;
      }
 else       if (forcedEnd) {
        currentSentence.add(o);
        inWaitForForcedEnd=false;
        newSent=true;
        if (DEBUG) {
          System.err.println("  annotated to be the end of a sentence");
        }
      }
 else {
        currentSentence.add(o);
        if (DEBUG) {
          System.err.println("  added to current");
        }
      }
      if (newSent && (!currentSentence.isEmpty() || allowEmptySentences())) {
        if (DEBUG) {
          System.err.println("  beginning new sentence");
        }
        sentences.add(currentSentence);
        lastSentence=currentSentence;
        currentSentence=new ArrayList<IN>();
      }
    }
  }
  if (!currentSentence.isEmpty()) {
    sentences.add(currentSentence);
  }
  return sentences;
}
