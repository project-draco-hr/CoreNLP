{
  if (!alreadySetUp)   setUp();
  Counter<String> externalWordWeightsNormalized=null;
  if (externalWordWeights != null)   externalWordWeightsNormalized=GetPatternsFromDataMultiClass.normalizeSoftMaxMinMaxScores(externalWordWeights,true,true,false);
  if (this.patternsForEachToken == null) {
    if (computeAllPatterns) {
      Redwood.log(Redwood.FORCE,channelNameLogger,"Computing all patterns");
      this.patternsForEachToken=createPats.getAllPatterns(label,Data.sents);
      if (allPatternsFile != null)       IOUtils.writeObjectToFile(this.patternsForEachToken,allPatternsFile);
    }
 else {
      this.patternsForEachToken=IOUtils.readObjectFromFile(allPatternsFile);
      Redwood.log(Redwood.FORCE,channelNameLogger,"Read all patterns from " + allPatternsFile);
    }
  }
  Class answerClass4Label=constVars.answerClass.get(label);
  String answerLabel4Label=label;
  if (patternsandWords == null)   patternsandWords=new HashMap<String,TwoDimensionalCounter<SurfacePattern,String>>();
  if (allPatternsandWords == null)   allPatternsandWords=new HashMap<String,TwoDimensionalCounter<SurfacePattern,String>>();
  if (currentPatternWeights == null)   currentPatternWeights=new HashMap<String,Counter<SurfacePattern>>();
  TwoDimensionalCounter<SurfacePattern,String> patternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> negPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> posnegPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> unLabeledPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> negandUnLabeledPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> allPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  Counter<SurfacePattern> currentPatternWeights4Label=new ClassicCounter<SurfacePattern>();
  for (  Entry<String,List<CoreLabel>> sentEn : Data.sents.entrySet()) {
    Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>> pat4Sent=this.patternsForEachToken.get(sentEn.getKey());
    if (pat4Sent == null) {
      throw new RuntimeException("How come there are no patterns for " + sentEn.getKey() + ". The total patternsForEachToken size is "+ patternsForEachToken.size()+ " and keys "+ patternsForEachToken.keySet());
    }
    List<CoreLabel> sent=sentEn.getValue();
    for (int i=0; i < sent.size(); i++) {
      CoreLabel token=sent.get(i);
      Set<String> matchedPhrases=token.get(PatternsAnnotations.MatchedPhrases.class);
      String tokenWordOrLemma=token.word();
      String longestMatchingPhrase=null;
      if (useMatchingPhrase) {
        if (matchedPhrases != null && !matchedPhrases.isEmpty()) {
          for (          String s : matchedPhrases) {
            if (s.equals(tokenWordOrLemma)) {
              longestMatchingPhrase=tokenWordOrLemma;
              break;
            }
            if (longestMatchingPhrase == null || longestMatchingPhrase.length() > s.length()) {
              longestMatchingPhrase=s;
            }
          }
        }
 else {
          longestMatchingPhrase=tokenWordOrLemma;
        }
      }
 else       longestMatchingPhrase=tokenWordOrLemma;
      Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>> pat=pat4Sent.get(i);
      if (pat == null)       throw new RuntimeException("Why are patterns null for sentence " + sentEn.getKey() + " and token "+ i);
      Set<SurfacePattern> prevPat=pat.first();
      Set<SurfacePattern> nextPat=pat.second();
      Set<SurfacePattern> prevnextPat=pat.third();
      if (constVars.ignoreWordRegex.matcher(token.word()).matches())       continue;
      if (token.get(answerClass4Label).equals(answerLabel4Label.toString())) {
        boolean prevTokenLabel=i == 0 ? false : sent.get(i - 1).get(answerClass4Label).equals(answerLabel4Label.toString());
        boolean nextTokenLabel=i == sent.size() - 1 ? false : sent.get(i + 1).get(answerClass4Label).equals(answerLabel4Label.toString());
        if (!ignorePatWithLabeledNeigh || !prevTokenLabel) {
          for (          SurfacePattern s : prevPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!ignorePatWithLabeledNeigh || !nextTokenLabel) {
          for (          SurfacePattern s : nextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!ignorePatWithLabeledNeigh || (!prevTokenLabel && !nextTokenLabel)) {
          for (          SurfacePattern s : prevnextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
      }
 else {
        boolean negToken=false;
        Map<Class,Object> ignore=constVars.ignoreWordswithClassesDuringSelection.get(label);
        for (        Class igCl : ignore.keySet())         if ((boolean)token.get(igCl)) {
          negToken=true;
          break;
        }
        if (!negToken)         if (constVars.getOtherSemanticClasses().contains(token.word()) || constVars.getOtherSemanticClasses().contains(token.lemma()))         negToken=true;
        for (        SurfacePattern s : CollectionUtils.union(CollectionUtils.union(prevPat,nextPat),prevnextPat)) {
          if (negToken) {
            negPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
 else {
            unLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
          negandUnLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          allPatternsandWords4Label.incrementCount(s,tokenWordOrLemma);
        }
      }
    }
  }
  Redwood.log("extremePatDebug","Patterns around positive words in the label " + label + " are "+ patternsandWords4Label);
  CollectionValuedMap<SurfacePattern,String> posWords=new CollectionValuedMap<SurfacePattern,String>();
  for (  Entry<SurfacePattern,ClassicCounter<String>> en : patternsandWords4Label.entrySet()) {
    posWords.addAll(en.getKey(),en.getValue().keySet());
  }
  CollectionValuedMap<SurfacePattern,String> negWords=new CollectionValuedMap<SurfacePattern,String>();
  for (  Entry<SurfacePattern,ClassicCounter<String>> en : negPatternsandWords4Label.entrySet()) {
    negWords.addAll(en.getKey(),en.getValue().keySet());
  }
  CollectionValuedMap<SurfacePattern,String> unlabWords=new CollectionValuedMap<SurfacePattern,String>();
  for (  Entry<SurfacePattern,ClassicCounter<String>> en : unLabeledPatternsandWords4Label.entrySet()) {
    unlabWords.addAll(en.getKey(),en.getValue().keySet());
  }
  if (patternScoring.equals(PatternScoring.F1)) {
    Counter<SurfacePattern> specificity=new ClassicCounter<SurfacePattern>();
    Counter<SurfacePattern> sensitivity=new ClassicCounter<SurfacePattern>();
    if (p0Set.keySet().size() == 0)     throw new RuntimeException("how come p0set size is empty for " + p0 + "?");
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : patternsandWords4Label.entrySet()) {
      int common=CollectionUtils.intersection(en.getValue().keySet(),p0Set.keySet()).size();
      if (common == 0)       continue;
      if (en.getValue().keySet().size() == 0)       throw new RuntimeException("how come counter for " + en.getKey() + " is empty?");
      specificity.setCount(en.getKey(),common / (double)en.getValue().keySet().size());
      sensitivity.setCount(en.getKey(),common / (double)p0Set.size());
    }
    Counters.retainNonZeros(specificity);
    Counters.retainNonZeros(sensitivity);
    Counter<SurfacePattern> add=Counters.add(sensitivity,specificity);
    Counter<SurfacePattern> product=Counters.product(sensitivity,specificity);
    Counters.retainNonZeros(product);
    Counters.retainKeys(product,add.keySet());
    Counter<SurfacePattern> finalPat=Counters.scale(Counters.division(product,add),2);
    Counters.removeKeys(finalPat,alreadyIdentifiedPatterns);
    Counters.retainNonZeros(finalPat);
    Counters.retainTop(finalPat,1);
    if (Double.isNaN(Counters.max(finalPat)))     throw new RuntimeException("how is the value NaN");
    Redwood.log(Redwood.FORCE,channelNameLogger,"Selected Pattern: " + finalPat);
    return finalPat;
  }
 else   if (patternScoring.equals(PatternScoring.PosNegUnlabOdds) || patternScoring.equals(PatternScoring.PosNegOdds) || patternScoring.equals(PatternScoring.RatioAll)|| patternScoring.equals(PatternScoring.PhEvalInPat)|| patternScoring.equals(PatternScoring.PhEvalInPatLogP)|| patternScoring.equals(PatternScoring.LOGREG)|| patternScoring.equals(PatternScoring.SqrtAllRatio)) {
    boolean useFreqPhraseExtractedByPat=false;
    if (patternScoring.equals(PatternScoring.SqrtAllRatio))     useFreqPhraseExtractedByPat=true;
    Counter<SurfacePattern> numeratorPatWt=this.convert2OneDim(label,patternsandWords4Label,sqrtPatScore,false,null,minPosPhraseSupportForPat,useFreqPhraseExtractedByPat);
    Counter<SurfacePattern> denominatorPatWt=null;
    if (patternScoring.equals(PatternScoring.PosNegUnlabOdds)) {
      denominatorPatWt=this.convert2OneDim(label,negandUnLabeledPatternsandWords4Label,sqrtPatScore,false,externalWordWeightsNormalized,minUnlabNegPhraseSupportForPat,useFreqPhraseExtractedByPat);
    }
 else     if (patternScoring.equals(PatternScoring.RatioAll)) {
      denominatorPatWt=this.convert2OneDim(label,allPatternsandWords4Label,sqrtPatScore,false,externalWordWeightsNormalized,minUnlabNegPhraseSupportForPat,useFreqPhraseExtractedByPat);
    }
 else     if (patternScoring.equals(PatternScoring.PosNegOdds)) {
      denominatorPatWt=this.convert2OneDim(label,negPatternsandWords4Label,sqrtPatScore,false,externalWordWeightsNormalized,minUnlabNegPhraseSupportForPat,useFreqPhraseExtractedByPat);
    }
 else     if (patternScoring.equals(PatternScoring.PhEvalInPat) || patternScoring.equals(PatternScoring.PhEvalInPatLogP) || patternScoring.equals(PatternScoring.LOGREG)) {
      denominatorPatWt=this.convert2OneDim(label,negandUnLabeledPatternsandWords4Label,sqrtPatScore,true,externalWordWeightsNormalized,minUnlabNegPhraseSupportForPat,useFreqPhraseExtractedByPat);
    }
 else     if (patternScoring.equals(PatternScoring.SqrtAllRatio)) {
      denominatorPatWt=this.convert2OneDim(label,negandUnLabeledPatternsandWords4Label,true,false,externalWordWeightsNormalized,minUnlabNegPhraseSupportForPat,useFreqPhraseExtractedByPat);
    }
 else     throw new RuntimeException("Cannot understand patterns scoring");
    currentPatternWeights4Label=divisionNonNaN(numeratorPatWt,denominatorPatWt);
    if (patternScoring.equals(PatternScoring.PhEvalInPatLogP)) {
      Counter<SurfacePattern> logpos_i=new ClassicCounter<SurfacePattern>();
      for (      Entry<SurfacePattern,ClassicCounter<String>> en : patternsandWords4Label.entrySet()) {
        logpos_i.setCount(en.getKey(),Math.log(en.getValue().size()));
      }
      Counters.multiplyInPlace(currentPatternWeights4Label,logpos_i);
    }
    Counters.retainNonZeros(currentPatternWeights4Label);
  }
 else   if (patternScoring.equals(PatternScoring.RlogF) || patternScoring.equals(PatternScoring.RlogFPosNeg) || patternScoring.equals(PatternScoring.RlogFUnlabNeg)|| patternScoring.equals(PatternScoring.RlogFNeg)|| patternScoring.equals(PatternScoring.YanGarber02)|| patternScoring.equals(PatternScoring.LinICML03)) {
    Counter<SurfacePattern> pos_i=new ClassicCounter<SurfacePattern>();
    Counter<SurfacePattern> all_i=new ClassicCounter<SurfacePattern>();
    Counter<SurfacePattern> neg_i=new ClassicCounter<SurfacePattern>();
    Counter<SurfacePattern> unlab_i=new ClassicCounter<SurfacePattern>();
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : negPatternsandWords4Label.entrySet()) {
      neg_i.setCount(en.getKey(),en.getValue().size());
    }
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : unLabeledPatternsandWords4Label.entrySet()) {
      unlab_i.setCount(en.getKey(),en.getValue().size());
    }
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : patternsandWords4Label.entrySet()) {
      pos_i.setCount(en.getKey(),en.getValue().size());
    }
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : allPatternsandWords4Label.entrySet()) {
      all_i.setCount(en.getKey(),en.getValue().size());
    }
    Counter<SurfacePattern> posneg_i=Counters.add(pos_i,neg_i);
    Counter<SurfacePattern> logFi=new ClassicCounter<SurfacePattern>(pos_i);
    Counters.logInPlace(logFi);
    if (patternScoring.equals(PatternScoring.RlogF)) {
      currentPatternWeights4Label=Counters.product(Counters.division(pos_i,all_i),logFi);
    }
 else     if (patternScoring.equals(PatternScoring.RlogFPosNeg)) {
      System.out.println("computing rlogfposneg");
      System.out.println("computed deno");
      currentPatternWeights4Label=Counters.product(Counters.division(pos_i,posneg_i),logFi);
      System.out.println("computed rlogfposneg");
    }
 else     if (patternScoring.equals(PatternScoring.RlogFUnlabNeg)) {
      System.out.println("computing rlogfunlabeg");
      System.out.println("computed deno");
      currentPatternWeights4Label=Counters.product(Counters.division(pos_i,Counters.add(neg_i,unlab_i)),logFi);
    }
 else     if (patternScoring.equals(PatternScoring.RlogFNeg)) {
      System.out.println("computing rlogfneg");
      currentPatternWeights4Label=Counters.product(Counters.division(pos_i,neg_i),logFi);
    }
 else     if (patternScoring.equals(PatternScoring.YanGarber02)) {
      Counter<SurfacePattern> acc=Counters.division(pos_i,Counters.add(pos_i,neg_i));
      double thetaPrecision=0.8;
      Counters.retainAbove(acc,thetaPrecision);
      Counter<SurfacePattern> conf=Counters.product(Counters.division(pos_i,all_i),logFi);
      for (      SurfacePattern p : acc.keySet()) {
        currentPatternWeights4Label.setCount(p,conf.getCount(p));
      }
    }
 else     if (patternScoring.equals(PatternScoring.LinICML03)) {
      Counter<SurfacePattern> acc=Counters.division(pos_i,Counters.add(pos_i,neg_i));
      double thetaPrecision=0.8;
      Counters.retainAbove(acc,thetaPrecision);
      Counter<SurfacePattern> conf=Counters.product(Counters.division(Counters.add(pos_i,Counters.scale(neg_i,-1)),all_i),logFi);
      for (      SurfacePattern p : acc.keySet()) {
        currentPatternWeights4Label.setCount(p,conf.getCount(p));
      }
    }
 else {
      throw new RuntimeException("not implemented");
    }
  }
 else {
    throw new RuntimeException("not implemented");
  }
  Redwood.log("extremePatDebug","patterns counter size is " + currentPatternWeights4Label.size());
  if (ignorePatterns != null && !ignorePatterns.isEmpty()) {
    Counters.removeKeys(currentPatternWeights4Label,ignorePatterns);
    Redwood.log("extremePatDebug","Removing patterns from ignorePatterns of size  " + ignorePatterns.size() + ". New patterns size "+ currentPatternWeights4Label.size());
  }
  if (alreadyIdentifiedPatterns != null && !alreadyIdentifiedPatterns.isEmpty()) {
    Counters.removeKeys(currentPatternWeights4Label,alreadyIdentifiedPatterns);
    Redwood.log("extremePatDebug","Removing already identified patterns of size  " + alreadyIdentifiedPatterns.size() + ". New patterns size "+ currentPatternWeights4Label.size());
  }
  PriorityQueue<SurfacePattern> q=Counters.toPriorityQueue(currentPatternWeights4Label);
  int num=0;
  Counter<SurfacePattern> chosenPat=new ClassicCounter<SurfacePattern>();
  Set<SurfacePattern> removePatterns=new HashSet<SurfacePattern>();
  while (num < numPatterns && !q.isEmpty()) {
    SurfacePattern pat=q.removeFirst();
    if (currentPatternWeights4Label.getCount(pat) < thresholdSelectPattern) {
      Redwood.log(Redwood.DBG,channelNameLogger,"The max weight of candidate patterns is " + df.format(currentPatternWeights4Label.getCount(pat)) + " so not adding anymore patterns");
      break;
    }
    boolean notchoose=false;
    if (discardPatternsWithNoUnlabSupport && (!unLabeledPatternsandWords4Label.containsFirstKey(pat) || unLabeledPatternsandWords4Label.getCounter(pat).isEmpty())) {
      Redwood.log("extremePatDebug","Removing pattern " + pat + " because it has no unlab support; pos words: "+ patternsandWords4Label.getCounter(pat)+ " and all words "+ allPatternsandWords4Label.getCounter(pat));
      notchoose=true;
      continue;
    }
    SurfacePattern removeIdentifiedPattern=null, removeChosenPat=null;
    if (!notchoose) {
      if (alreadyIdentifiedPatterns != null) {
        for (        SurfacePattern p : alreadyIdentifiedPatterns) {
          if (pat.nextContextStr.contains(p.nextContextStr) && pat.prevContextStr.contains(p.prevContextStr)) {
            Redwood.log("extremePatDebug","Removing pattern " + pat + " because it is contained in or contains the already chosen pattern "+ p);
            notchoose=true;
            break;
          }
          int rest=pat.equalContext(p);
          if (rest == Integer.MAX_VALUE)           continue;
          if (rest < 0) {
            removeIdentifiedPattern=p;
          }
 else {
            notchoose=true;
            break;
          }
        }
      }
    }
    if (!notchoose) {
      for (      SurfacePattern p : chosenPat.keySet()) {
        if (pat.nextContextStr.contains(p.nextContextStr) && pat.prevContextStr.contains(p.prevContextStr)) {
          Redwood.log("extremePatDebug","Removing pattern " + pat + " because it is contained in or contains the already chosen pattern "+ p);
          notchoose=true;
          break;
        }
        int rest=pat.equalContext(p);
        if (rest == Integer.MAX_VALUE)         continue;
        if (rest < 0) {
          removeChosenPat=p;
          num--;
        }
 else {
          removeIdentifiedPattern=null;
          notchoose=true;
          break;
        }
      }
    }
    if (notchoose)     continue;
    if (removeChosenPat != null) {
      Redwood.log("extremePatDebug","Removing already chosen pattern in this iteration " + removeChosenPat + " in favor of "+ pat);
      chosenPat.remove(removeChosenPat);
    }
    if (removeIdentifiedPattern != null) {
      Redwood.log("extremePatDebug","Removing already identified pattern " + removeChosenPat + " in favor of "+ pat);
      removePatterns.add(removeIdentifiedPattern);
    }
    chosenPat.setCount(pat,currentPatternWeights4Label.getCount(pat));
    num++;
  }
  this.removeLearnedPatterns(label,removePatterns);
  Redwood.log(Redwood.DBG,channelNameLogger,"final size of the patterns is " + chosenPat.size());
  Redwood.log(Redwood.FORCE,channelNameLogger,"## Selected Patterns ## \n");
  List<Pair<SurfacePattern,Double>> chosenPatSorted=Counters.toSortedListWithCounts(chosenPat);
  for (  Pair<SurfacePattern,Double> en : chosenPatSorted)   Redwood.log(Redwood.FORCE,channelNameLogger,en.first().toStringToWrite() + ":" + df.format(en.second)+ "\n");
  if (justificationDirJson != null && !justificationDirJson.isEmpty()) {
    IOUtils.ensureDir(new File(justificationDirJson + "/" + identifier+ "/"+ label));
    String filename=this.justificationDirJson + "/" + identifier+ "/"+ label+ "/patterns"+ ".json";
    JsonArrayBuilder obj=Json.createArrayBuilder();
    if (writtenPatInJustification.containsKey(label) && writtenPatInJustification.get(label)) {
      JsonReader jsonReader=Json.createReader(new BufferedInputStream(new FileInputStream(filename)));
      JsonArray objarr=jsonReader.readArray();
      jsonReader.close();
      for (      JsonValue o : objarr)       obj.add(o);
    }
 else     obj=Json.createArrayBuilder();
    JsonObjectBuilder objThisIter=Json.createObjectBuilder();
    for (    Pair<SurfacePattern,Double> pat : chosenPatSorted) {
      JsonObjectBuilder o=Json.createObjectBuilder();
      JsonArrayBuilder pos=Json.createArrayBuilder();
      JsonArrayBuilder neg=Json.createArrayBuilder();
      JsonArrayBuilder unlab=Json.createArrayBuilder();
      for (      String w : posWords.get(pat.first()))       pos.add(w);
      for (      String w : negWords.get(pat.first()))       neg.add(w);
      for (      String w : unlabWords.get(pat.first()))       unlab.add(w);
      o.add("Positive",pos);
      o.add("Negative",neg);
      o.add("Unlabeled",unlab);
      o.add("Score",pat.second());
      objThisIter.add(pat.first().toStringSimple(),o);
    }
    obj.add(objThisIter.build());
    IOUtils.ensureDir(new File(filename).getParentFile());
    IOUtils.writeStringToFile(obj.build().toString(),filename,"utf8");
    writtenPatInJustification.put(label,true);
  }
  if (justify) {
    Redwood.log(Redwood.DBG,channelNameLogger,"Justification for Patterns:");
    for (    SurfacePattern key : chosenPat.keySet()) {
      Redwood.log(Redwood.DBG,channelNameLogger,"Pattern: " + key.toStringToWrite());
      Redwood.log(Redwood.DBG,channelNameLogger,"Positive Words:" + Counters.toSortedString(patternsandWords4Label.getCounter(key),patternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
      Redwood.log(Redwood.DBG,channelNameLogger,"Negative Words:" + Counters.toSortedString(negPatternsandWords4Label.getCounter(key),negPatternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
      Redwood.log(Redwood.DBG,channelNameLogger,"All Words: " + Counters.toSortedString(allPatternsandWords4Label.getCounter(key),allPatternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
    }
  }
  allPatternsandWords.put(label,allPatternsandWords4Label);
  patternsandWords.put(label,patternsandWords4Label);
  currentPatternWeights.put(label,currentPatternWeights4Label);
  return chosenPat;
}
