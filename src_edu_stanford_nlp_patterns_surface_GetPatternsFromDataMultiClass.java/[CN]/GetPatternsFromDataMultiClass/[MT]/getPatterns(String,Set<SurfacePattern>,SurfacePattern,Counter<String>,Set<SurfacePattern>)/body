{
  if (this.patternsForEachToken == null) {
    if (constVars.computeAllPatterns) {
      Redwood.log(Redwood.DBG,"Computing all patterns");
      this.patternsForEachToken=createPats.getAllPatterns(label,Data.sents);
      if (constVars.allPatternsFile != null)       IOUtils.writeObjectToFile(this.patternsForEachToken,constVars.allPatternsFile);
    }
 else {
      this.patternsForEachToken=IOUtils.readObjectFromFile(constVars.allPatternsFile);
      Redwood.log(ConstantsAndVariables.minimaldebug,"Read all patterns from " + constVars.allPatternsFile);
    }
  }
  Class answerClass4Label=constVars.answerClass.get(label);
  String answerLabel4Label=label;
  if (patternsandWords == null)   patternsandWords=new HashMap<String,TwoDimensionalCounter<SurfacePattern,String>>();
  if (allPatternsandWords == null)   allPatternsandWords=new HashMap<String,TwoDimensionalCounter<SurfacePattern,String>>();
  if (currentPatternWeights == null)   currentPatternWeights=new HashMap<String,Counter<SurfacePattern>>();
  TwoDimensionalCounter<SurfacePattern,String> patternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> negPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> posnegPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> unLabeledPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> negandUnLabeledPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  TwoDimensionalCounter<SurfacePattern,String> allPatternsandWords4Label=new TwoDimensionalCounter<SurfacePattern,String>();
  Counter<SurfacePattern> currentPatternWeights4Label=new ClassicCounter<SurfacePattern>();
  for (  Entry<String,List<CoreLabel>> sentEn : Data.sents.entrySet()) {
    Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>> pat4Sent=this.patternsForEachToken.get(sentEn.getKey());
    if (pat4Sent == null) {
      throw new RuntimeException("How come there are no patterns for " + sentEn.getKey() + ". The total patternsForEachToken size is "+ patternsForEachToken.size()+ " and keys "+ patternsForEachToken.keySet());
    }
    List<CoreLabel> sent=sentEn.getValue();
    for (int i=0; i < sent.size(); i++) {
      CoreLabel token=sent.get(i);
      Set<String> matchedPhrases=token.get(PatternsAnnotations.MatchedPhrases.class);
      String tokenWordOrLemma=token.word();
      String longestMatchingPhrase=null;
      if (constVars.useMatchingPhrase) {
        if (matchedPhrases != null && !matchedPhrases.isEmpty()) {
          for (          String s : matchedPhrases) {
            if (s.equals(tokenWordOrLemma)) {
              longestMatchingPhrase=tokenWordOrLemma;
              break;
            }
            if (longestMatchingPhrase == null || longestMatchingPhrase.length() > s.length()) {
              longestMatchingPhrase=s;
            }
          }
        }
 else {
          longestMatchingPhrase=tokenWordOrLemma;
        }
      }
 else       longestMatchingPhrase=tokenWordOrLemma;
      Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>> pat=pat4Sent.get(i);
      if (pat == null)       throw new RuntimeException("Why are patterns null for sentence " + sentEn.getKey() + " and token "+ i);
      Set<SurfacePattern> prevPat=pat.first();
      Set<SurfacePattern> nextPat=pat.second();
      Set<SurfacePattern> prevnextPat=pat.third();
      if (constVars.ignoreWordRegex.matcher(token.word()).matches())       continue;
      String tag=token.tag();
      if (constVars.allowedTagsInitials != null && constVars.allowedTagsInitials.containsKey(label)) {
        boolean use=false;
        for (        String allowed : constVars.allowedTagsInitials.get(label)) {
          if (tag.startsWith(allowed)) {
            use=true;
            break;
          }
        }
        if (!use)         continue;
      }
      String nertag=token.ner();
      if (constVars.allowedNERsforLabels != null && constVars.allowedNERsforLabels.containsKey(label)) {
        if (!constVars.allowedNERsforLabels.get(label).contains(nertag)) {
          continue;
        }
      }
      if (token.get(answerClass4Label).equals(answerLabel4Label.toString())) {
        boolean prevTokenLabel=i == 0 ? false : sent.get(i - 1).get(answerClass4Label).equals(answerLabel4Label.toString());
        boolean nextTokenLabel=i == sent.size() - 1 ? false : sent.get(i + 1).get(answerClass4Label).equals(answerLabel4Label.toString());
        if (!constVars.ignorePatWithLabeledNeigh || !prevTokenLabel) {
          for (          SurfacePattern s : prevPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || !nextTokenLabel) {
          for (          SurfacePattern s : nextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || (!prevTokenLabel && !nextTokenLabel)) {
          for (          SurfacePattern s : prevnextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
      }
 else {
        boolean negToken=false;
        Map<Class,Object> ignore=constVars.ignoreWordswithClassesDuringSelection.get(label);
        for (        Class igCl : ignore.keySet())         if ((Boolean)token.get(igCl)) {
          negToken=true;
          break;
        }
        if (!negToken)         if (constVars.getOtherSemanticClasses().contains(token.word()) || constVars.getOtherSemanticClasses().contains(token.lemma()))         negToken=true;
        for (        SurfacePattern s : CollectionUtils.union(CollectionUtils.union(prevPat,nextPat),prevnextPat)) {
          if (negToken) {
            negPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
 else {
            unLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
          negandUnLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          allPatternsandWords4Label.incrementCount(s,tokenWordOrLemma);
        }
      }
    }
  }
  Set<SurfacePattern> removePats=enforceMinSupportRequirements(patternsandWords4Label,unLabeledPatternsandWords4Label);
  Counters.removeKeys(patternsandWords4Label,removePats);
  Counters.removeKeys(unLabeledPatternsandWords4Label,removePats);
  Counters.removeKeys(negandUnLabeledPatternsandWords4Label,removePats);
  Counters.removeKeys(allPatternsandWords4Label,removePats);
  Counters.removeKeys(posnegPatternsandWords4Label,removePats);
  Counters.removeKeys(negPatternsandWords4Label,removePats);
  Redwood.log(ConstantsAndVariables.extremedebug,"Patterns around positive words in the label " + label + " are "+ patternsandWords4Label);
  ScorePatterns scorePatterns;
  if (constVars.patternScoring.equals(PatternScoring.F1)) {
    scorePatterns=new ScorePatternsF1(constVars,constVars.patternScoring,label,patternsandWords4Label,negPatternsandWords4Label,unLabeledPatternsandWords4Label,negandUnLabeledPatternsandWords4Label,allPatternsandWords4Label,props,p0Set,p0);
    Counter<SurfacePattern> finalPat=scorePatterns.score();
    Counters.removeKeys(finalPat,alreadyIdentifiedPatterns);
    Counters.retainNonZeros(finalPat);
    Counters.retainTop(finalPat,1);
    if (Double.isNaN(Counters.max(finalPat)))     throw new RuntimeException("how is the value NaN");
    Redwood.log(ConstantsAndVariables.minimaldebug,"Selected Pattern: " + finalPat);
    return finalPat;
  }
 else   if (constVars.patternScoring.equals(PatternScoring.PosNegUnlabOdds) || constVars.patternScoring.equals(PatternScoring.PosNegOdds) || constVars.patternScoring.equals(PatternScoring.RatioAll)|| constVars.patternScoring.equals(PatternScoring.PhEvalInPat)|| constVars.patternScoring.equals(PatternScoring.PhEvalInPatLogP)|| constVars.patternScoring.equals(PatternScoring.LOGREG)|| constVars.patternScoring.equals(PatternScoring.LOGREGlogP)|| constVars.patternScoring.equals(PatternScoring.SqrtAllRatio)) {
    scorePatterns=new ScorePatternsRatioModifiedFreq(constVars,constVars.patternScoring,label,patternsandWords4Label,negPatternsandWords4Label,unLabeledPatternsandWords4Label,negandUnLabeledPatternsandWords4Label,allPatternsandWords4Label,phInPatScores,scorePhrases,props);
  }
 else   if (constVars.patternScoring.equals(PatternScoring.RlogF) || constVars.patternScoring.equals(PatternScoring.RlogFPosNeg) || constVars.patternScoring.equals(PatternScoring.RlogFUnlabNeg)|| constVars.patternScoring.equals(PatternScoring.RlogFNeg)|| constVars.patternScoring.equals(PatternScoring.YanGarber02)|| constVars.patternScoring.equals(PatternScoring.LinICML03)) {
    scorePatterns=new ScorePatternsFreqBased(constVars,constVars.patternScoring,label,patternsandWords4Label,negPatternsandWords4Label,unLabeledPatternsandWords4Label,negandUnLabeledPatternsandWords4Label,allPatternsandWords4Label,props);
  }
 else   if (constVars.patternScoring.equals(PatternScoring.kNN)) {
    try {
      Class<? extends ScorePatterns> clazz=(Class<? extends ScorePatterns>)Class.forName("edu.stanford.nlp.patterns.surface.ScorePatternsKNN");
      Constructor<? extends ScorePatterns> ctor=clazz.getConstructor(ConstantsAndVariables.class,PatternScoring.class,String.class,TwoDimensionalCounter.class,TwoDimensionalCounter.class,TwoDimensionalCounter.class,TwoDimensionalCounter.class,TwoDimensionalCounter.class,Properties.class);
      scorePatterns=ctor.newInstance(constVars,constVars.patternScoring,label,patternsandWords4Label,negPatternsandWords4Label,unLabeledPatternsandWords4Label,negandUnLabeledPatternsandWords4Label,allPatternsandWords4Label,props);
    }
 catch (    ClassNotFoundException e) {
      throw new RuntimeException("kNN pattern scoring is not released yet. Stay tuned.");
    }
catch (    NoSuchMethodException e) {
      throw new RuntimeException("newinstance of kNN not created",e);
    }
catch (    InvocationTargetException e) {
      throw new RuntimeException("newinstance of kNN not created",e);
    }
catch (    IllegalAccessException e) {
      throw new RuntimeException("newinstance of kNN not created",e);
    }
catch (    InstantiationException e) {
      throw new RuntimeException("newinstance of kNN not created",e);
    }
  }
 else {
    throw new RuntimeException(constVars.patternScoring + " is not implemented (check spelling?). ");
  }
  scorePatterns.setUp(props);
  currentPatternWeights4Label=scorePatterns.score();
  Redwood.log(ConstantsAndVariables.extremedebug,"patterns counter size is " + currentPatternWeights4Label.size());
  if (ignorePatterns != null && !ignorePatterns.isEmpty()) {
    Counters.removeKeys(currentPatternWeights4Label,ignorePatterns);
    Redwood.log(ConstantsAndVariables.extremedebug,"Removing patterns from ignorePatterns of size  " + ignorePatterns.size() + ". New patterns size "+ currentPatternWeights4Label.size());
  }
  if (alreadyIdentifiedPatterns != null && !alreadyIdentifiedPatterns.isEmpty()) {
    Counters.removeKeys(currentPatternWeights4Label,alreadyIdentifiedPatterns);
    Redwood.log(ConstantsAndVariables.extremedebug,"Removing already identified patterns of size  " + alreadyIdentifiedPatterns.size() + ". New patterns size "+ currentPatternWeights4Label.size());
  }
  PriorityQueue<SurfacePattern> q=Counters.toPriorityQueue(currentPatternWeights4Label);
  int num=0;
  Counter<SurfacePattern> chosenPat=new ClassicCounter<SurfacePattern>();
  Set<SurfacePattern> removePatterns=new HashSet<SurfacePattern>();
  while (num < constVars.numPatterns && !q.isEmpty()) {
    SurfacePattern pat=q.removeFirst();
    if (currentPatternWeights4Label.getCount(pat) < constVars.thresholdSelectPattern) {
      Redwood.log(Redwood.DBG,"The max weight of candidate patterns is " + df.format(currentPatternWeights4Label.getCount(pat)) + " so not adding anymore patterns");
      break;
    }
    boolean notchoose=false;
    if (!unLabeledPatternsandWords4Label.containsFirstKey(pat) || unLabeledPatternsandWords4Label.getCounter(pat).isEmpty()) {
      Redwood.log(ConstantsAndVariables.extremedebug,"Removing pattern " + pat + " because it has no unlab support; pos words: "+ patternsandWords4Label.getCounter(pat)+ " and all words "+ allPatternsandWords4Label.getCounter(pat));
      notchoose=true;
      continue;
    }
    SurfacePattern removeIdentifiedPattern=null, removeChosenPat=null;
    if (!notchoose) {
      if (alreadyIdentifiedPatterns != null) {
        for (        SurfacePattern p : alreadyIdentifiedPatterns) {
          if (pat.nextContextStr.contains(p.nextContextStr) && pat.prevContextStr.contains(p.prevContextStr)) {
            Redwood.log(ConstantsAndVariables.extremedebug,"Removing pattern " + pat + " because it is contained in or contains the already chosen pattern "+ p);
            notchoose=true;
            break;
          }
          int rest=pat.equalContext(p);
          if (rest == Integer.MAX_VALUE)           continue;
          if (rest < 0) {
            removeIdentifiedPattern=p;
          }
 else {
            notchoose=true;
            break;
          }
        }
      }
    }
    if (!notchoose) {
      for (      SurfacePattern p : chosenPat.keySet()) {
        if (pat.nextContextStr.contains(p.nextContextStr) && pat.prevContextStr.contains(p.prevContextStr)) {
          Redwood.log(ConstantsAndVariables.extremedebug,"Removing pattern " + pat + " because it is contained in or contains the already chosen pattern "+ p);
          notchoose=true;
          break;
        }
        int rest=pat.equalContext(p);
        if (rest == Integer.MAX_VALUE)         continue;
        if (rest < 0) {
          removeChosenPat=p;
          num--;
        }
 else {
          removeIdentifiedPattern=null;
          notchoose=true;
          break;
        }
      }
    }
    if (notchoose)     continue;
    if (removeChosenPat != null) {
      Redwood.log(ConstantsAndVariables.extremedebug,"Removing already chosen pattern in this iteration " + removeChosenPat + " in favor of "+ pat);
      chosenPat.remove(removeChosenPat);
    }
    if (removeIdentifiedPattern != null) {
      Redwood.log(ConstantsAndVariables.extremedebug,"Removing already identified pattern " + removeChosenPat + " in favor of "+ pat);
      removePatterns.add(removeIdentifiedPattern);
    }
    chosenPat.setCount(pat,currentPatternWeights4Label.getCount(pat));
    num++;
  }
  this.removeLearnedPatterns(label,removePatterns);
  Redwood.log(Redwood.DBG,"final size of the patterns is " + chosenPat.size());
  Redwood.log(ConstantsAndVariables.minimaldebug,"## Selected Patterns ## \n");
  List<Pair<SurfacePattern,Double>> chosenPatSorted=Counters.toSortedListWithCounts(chosenPat);
  for (  Pair<SurfacePattern,Double> en : chosenPatSorted)   Redwood.log(ConstantsAndVariables.minimaldebug,en.first().toStringToWrite() + ":" + df.format(en.second)+ "\n");
  if (constVars.outDir != null && !constVars.outDir.isEmpty()) {
    CollectionValuedMap<SurfacePattern,String> posWords=new CollectionValuedMap<SurfacePattern,String>();
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : patternsandWords4Label.entrySet()) {
      posWords.addAll(en.getKey(),en.getValue().keySet());
    }
    CollectionValuedMap<SurfacePattern,String> negWords=new CollectionValuedMap<SurfacePattern,String>();
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : negPatternsandWords4Label.entrySet()) {
      negWords.addAll(en.getKey(),en.getValue().keySet());
    }
    CollectionValuedMap<SurfacePattern,String> unlabWords=new CollectionValuedMap<SurfacePattern,String>();
    for (    Entry<SurfacePattern,ClassicCounter<String>> en : unLabeledPatternsandWords4Label.entrySet()) {
      unlabWords.addAll(en.getKey(),en.getValue().keySet());
    }
    String outputdir=constVars.outDir + "/" + constVars.identifier+ "/"+ label;
    Redwood.log(ConstantsAndVariables.minimaldebug,"Saving output in " + outputdir);
    IOUtils.ensureDir(new File(outputdir));
    String filename=outputdir + "/patterns" + ".json";
    JsonArrayBuilder obj=Json.createArrayBuilder();
    if (writtenPatInJustification.containsKey(label) && writtenPatInJustification.get(label)) {
      JsonReader jsonReader=Json.createReader(new BufferedInputStream(new FileInputStream(filename)));
      JsonArray objarr=jsonReader.readArray();
      jsonReader.close();
      for (      JsonValue o : objarr)       obj.add(o);
    }
 else     obj=Json.createArrayBuilder();
    JsonObjectBuilder objThisIter=Json.createObjectBuilder();
    for (    Pair<SurfacePattern,Double> pat : chosenPatSorted) {
      JsonObjectBuilder o=Json.createObjectBuilder();
      JsonArrayBuilder pos=Json.createArrayBuilder();
      JsonArrayBuilder neg=Json.createArrayBuilder();
      JsonArrayBuilder unlab=Json.createArrayBuilder();
      for (      String w : posWords.get(pat.first()))       pos.add(w);
      for (      String w : negWords.get(pat.first()))       neg.add(w);
      for (      String w : unlabWords.get(pat.first()))       unlab.add(w);
      o.add("Positive",pos);
      o.add("Negative",neg);
      o.add("Unlabeled",unlab);
      o.add("Score",pat.second());
      objThisIter.add(pat.first().toStringSimple(),o);
    }
    obj.add(objThisIter.build());
    IOUtils.ensureDir(new File(filename).getParentFile());
    IOUtils.writeStringToFile(obj.build().toString(),filename,"utf8");
    writtenPatInJustification.put(label,true);
  }
  if (constVars.justify) {
    Redwood.log(Redwood.DBG,"Justification for Patterns:");
    for (    SurfacePattern key : chosenPat.keySet()) {
      Redwood.log(Redwood.DBG,"Pattern: " + key.toStringToWrite());
      Redwood.log(Redwood.DBG,"Positive Words:" + Counters.toSortedString(patternsandWords4Label.getCounter(key),patternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
      Redwood.log(Redwood.DBG,"Negative Words:" + Counters.toSortedString(negPatternsandWords4Label.getCounter(key),negPatternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
      Redwood.log(Redwood.DBG,"All Words: " + Counters.toSortedString(allPatternsandWords4Label.getCounter(key),allPatternsandWords4Label.getCounter(key).size(),"%1$s:%2$f",";"));
    }
  }
  allPatternsandWords.put(label,allPatternsandWords4Label);
  patternsandWords.put(label,patternsandWords4Label);
  currentPatternWeights.put(label,currentPatternWeights4Label);
  return chosenPat;
}
