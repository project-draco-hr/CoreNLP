{
  Class answerClass4Label=constVars.getAnswerClass().get(label);
  for (  Entry<String,List<CoreLabel>> sentEn : sents.entrySet()) {
    Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>> pat4Sent=patternsForEachToken.get(sentEn.getKey());
    if (pat4Sent == null) {
      throw new RuntimeException("How come there are no patterns for " + sentEn.getKey() + ". The total patternsForEachToken size is "+ patternsForEachToken.size()+ " and keys "+ patternsForEachToken.keySet());
    }
    List<CoreLabel> sent=sentEn.getValue();
    for (int i=0; i < sent.size(); i++) {
      CoreLabel token=sent.get(i);
      String tokenWordOrLemma=token.word();
      String longestMatchingPhrase=null;
      if (constVars.useMatchingPhrase) {
        Map<String,String> longestMatchingPhrases=token.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class);
        longestMatchingPhrase=longestMatchingPhrases.get(label);
        longestMatchingPhrase=(longestMatchingPhrase != null && (longestMatchingPhrase.length() > tokenWordOrLemma.length())) ? longestMatchingPhrase : tokenWordOrLemma;
      }
 else       longestMatchingPhrase=tokenWordOrLemma;
      Triple<Set<Integer>,Set<Integer>,Set<Integer>> pat=pat4Sent.get(i);
      if (pat == null)       throw new RuntimeException("Why are patterns null for sentence " + sentEn.getKey() + " and token "+ i);
      Set<Integer> prevPat=pat.first();
      Set<Integer> nextPat=pat.second();
      Set<Integer> prevnextPat=pat.third();
      if (constVars.ignoreWordRegex.matcher(token.word()).matches())       continue;
      String tag=token.tag();
      if (constVars.allowedTagsInitials != null && constVars.allowedTagsInitials.containsKey(label)) {
        boolean use=false;
        for (        String allowed : constVars.allowedTagsInitials.get(label)) {
          if (tag.startsWith(allowed)) {
            use=true;
            break;
          }
        }
        if (!use)         continue;
      }
      String nertag=token.ner();
      if (constVars.allowedNERsforLabels != null && constVars.allowedNERsforLabels.containsKey(label)) {
        if (!constVars.allowedNERsforLabels.get(label).contains(nertag)) {
          continue;
        }
      }
      if (token.get(answerClass4Label).equals(label)) {
        boolean prevTokenLabel=i == 0 ? false : sent.get(i - 1).get(answerClass4Label).equals(label);
        boolean nextTokenLabel=i == sent.size() - 1 ? false : sent.get(i + 1).get(answerClass4Label).equals(label);
        if (!constVars.ignorePatWithLabeledNeigh || !prevTokenLabel) {
          for (          Integer sindex : prevPat) {
            SurfacePattern s=constVars.patternIndex.get(sindex);
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || !nextTokenLabel) {
          for (          Integer sindex : nextPat) {
            SurfacePattern s=constVars.patternIndex.get(sindex);
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || (!prevTokenLabel && !nextTokenLabel)) {
          for (          Integer sindex : prevnextPat) {
            SurfacePattern s=constVars.patternIndex.get(sindex);
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
      }
 else {
        boolean negToken=false;
        Map<Class,Object> ignore=constVars.getIgnoreWordswithClassesDuringSelection().get(label);
        for (        Class igCl : ignore.keySet())         if ((Boolean)token.get(igCl)) {
          negToken=true;
          break;
        }
        if (!negToken)         if (constVars.getOtherSemanticClassesWords().contains(token.word()) || constVars.getOtherSemanticClassesWords().contains(token.lemma()))         negToken=true;
        for (        Integer sindex : CollectionUtils.union(CollectionUtils.union(prevPat,nextPat),prevnextPat)) {
          SurfacePattern s=constVars.patternIndex.get(sindex);
          if (negToken) {
            negPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
 else {
            unLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
          negandUnLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          allPatternsandWords4Label.incrementCount(s,tokenWordOrLemma);
        }
      }
    }
  }
}
