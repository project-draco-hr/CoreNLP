{
  Class answerClass4Label=constVars.getAnswerClass().get(label);
  for (  Entry<String,List<CoreLabel>> sentEn : sents.entrySet()) {
    Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>> pat4Sent=patternsForEachToken.get(sentEn.getKey());
    if (pat4Sent == null) {
      throw new RuntimeException("How come there are no patterns for " + sentEn.getKey() + ". The total patternsForEachToken size is "+ patternsForEachToken.size()+ " and keys "+ patternsForEachToken.keySet());
    }
    List<CoreLabel> sent=sentEn.getValue();
    for (int i=0; i < sent.size(); i++) {
      CoreLabel token=sent.get(i);
      Set<String> matchedPhrases=token.get(PatternsAnnotations.MatchedPhrases.class);
      String tokenWordOrLemma=token.word();
      String longestMatchingPhrase=null;
      if (constVars.useMatchingPhrase) {
        if (matchedPhrases != null && !matchedPhrases.isEmpty()) {
          for (          String s : matchedPhrases) {
            if (s.equals(tokenWordOrLemma)) {
              longestMatchingPhrase=tokenWordOrLemma;
              break;
            }
            if (longestMatchingPhrase == null || longestMatchingPhrase.length() > s.length()) {
              longestMatchingPhrase=s;
            }
          }
        }
 else {
          longestMatchingPhrase=tokenWordOrLemma;
        }
      }
 else       longestMatchingPhrase=tokenWordOrLemma;
      Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>> pat=pat4Sent.get(i);
      if (pat == null)       throw new RuntimeException("Why are patterns null for sentence " + sentEn.getKey() + " and token "+ i);
      Set<SurfacePattern> prevPat=pat.first();
      Set<SurfacePattern> nextPat=pat.second();
      Set<SurfacePattern> prevnextPat=pat.third();
      if (constVars.ignoreWordRegex.matcher(token.word()).matches())       continue;
      String tag=token.tag();
      if (constVars.allowedTagsInitials != null && constVars.allowedTagsInitials.containsKey(label)) {
        boolean use=false;
        for (        String allowed : constVars.allowedTagsInitials.get(label)) {
          if (tag.startsWith(allowed)) {
            use=true;
            break;
          }
        }
        if (!use)         continue;
      }
      String nertag=token.ner();
      if (constVars.allowedNERsforLabels != null && constVars.allowedNERsforLabels.containsKey(label)) {
        if (!constVars.allowedNERsforLabels.get(label).contains(nertag)) {
          continue;
        }
      }
      if (token.get(answerClass4Label).equals(label)) {
        boolean prevTokenLabel=i == 0 ? false : sent.get(i - 1).get(answerClass4Label).equals(label);
        boolean nextTokenLabel=i == sent.size() - 1 ? false : sent.get(i + 1).get(answerClass4Label).equals(label);
        if (!constVars.ignorePatWithLabeledNeigh || !prevTokenLabel) {
          for (          SurfacePattern s : prevPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || !nextTokenLabel) {
          for (          SurfacePattern s : nextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
        if (!constVars.ignorePatWithLabeledNeigh || (!prevTokenLabel && !nextTokenLabel)) {
          for (          SurfacePattern s : prevnextPat) {
            patternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
            allPatternsandWords4Label.getCounter(s).incrementCount(longestMatchingPhrase);
          }
        }
      }
 else {
        boolean negToken=false;
        Map<Class,Object> ignore=constVars.getIgnoreWordswithClassesDuringSelection().get(label);
        for (        Class igCl : ignore.keySet())         if ((Boolean)token.get(igCl)) {
          negToken=true;
          break;
        }
        if (!negToken)         if (constVars.getOtherSemanticClasses().contains(token.word()) || constVars.getOtherSemanticClasses().contains(token.lemma()))         negToken=true;
        for (        SurfacePattern s : CollectionUtils.union(CollectionUtils.union(prevPat,nextPat),prevnextPat)) {
          if (negToken) {
            negPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
            posnegPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
 else {
            unLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          }
          negandUnLabeledPatternsandWords4Label.getCounter(s).incrementCount(tokenWordOrLemma);
          allPatternsandWords4Label.incrementCount(s,tokenWordOrLemma);
        }
      }
    }
  }
}
