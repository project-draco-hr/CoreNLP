{
  if (!learnedPatterns.containsKey(label)) {
    learnedPatterns.put(label,new ClassicCounter<SurfacePattern>());
  }
  if (!learnedWords.containsKey(label)) {
    learnedWords.put(label,new ClassicCounter<String>());
  }
  Counter<String> identifiedWords=new ClassicCounter<String>();
  Counter<SurfacePattern> patterns=new ClassicCounter<SurfacePattern>();
  for (int i=0; i < numIter; i++) {
    patterns.addAll(getPatterns(label,learnedPatterns.get(label).keySet(),p0,p0Set,ignorePatterns));
    learnedPatterns.get(label).addAll(patterns);
    if (sentsOutFile != null)     sentsOutFile=sentsOutFile + "_" + i+ "iter.ser";
    Counter<String> scoreForAllWordsThisIteration=new ClassicCounter<String>();
    identifiedWords.addAll(scorePhrases.learnNewPhrases(label,this.patternsForEachToken,patterns,learnedPatterns.get(label),matchedTokensByPat,scoreForAllWordsThisIteration,terms,wordsPatExtracted.get(label),currentPatternWeights.get(label),this.patternsandWords.get(label),this.allPatternsandWords.get(label),constVars.identifier,ignoreWords));
    if (identifiedWords.size() > 0) {
      if (constVars.usePatternResultAsLabel) {
        if (constVars.getLabelDictionary().containsKey(label)) {
          if (constVars.batchProcessSents) {
            for (            File f : Data.sentsFiles) {
              Redwood.log(Redwood.DBG,"labeling sentences from " + f);
              Map<String,List<CoreLabel>> sents=IOUtils.readObjectFromFile(f);
              labelWords(label,sents,identifiedWords.keySet(),patterns.keySet(),sentsOutFile,matchedTokensByPat);
              IOUtils.writeObjectToFile(sents,f);
            }
          }
 else           labelWords(label,Data.sents,identifiedWords.keySet(),patterns.keySet(),sentsOutFile,matchedTokensByPat);
        }
 else         throw new RuntimeException("why is the answer label null?");
        learnedWords.get(label).addAll(identifiedWords);
      }
      if (wordsOutput != null) {
        wordsOutput.write("\n" + Counters.toSortedString(identifiedWords,identifiedWords.size(),"%1$s","\n"));
        wordsOutput.flush();
      }
    }
    if (patterns.size() == 0 && identifiedWords.size() == 0) {
      if (learnedWords.get(label).size() >= constVars.maxExtractNumWords) {
        System.out.println("Ending because no new words identified and total words learned till now >= max words " + constVars.maxExtractNumWords);
        break;
      }
      if (constVars.tuneThresholdKeepRunning) {
        constVars.thresholdSelectPattern=0.8 * constVars.thresholdSelectPattern;
        System.out.println("\n\nTuning thresholds to keep running. New Pattern threshold is  " + constVars.thresholdSelectPattern);
      }
 else       break;
    }
  }
  if (patternsOut != null)   this.writePatternsToFile(learnedPatterns.get(label),patternsOut);
  return new Pair<Counter<SurfacePattern>,Counter<String>>(patterns,identifiedWords);
}
