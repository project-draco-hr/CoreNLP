{
  Map<String,Set<E>> ignorePatterns=new HashMap<String,Set<E>>();
  Map<String,E> p0=new HashMap<String,E>();
  Map<String,Counter<String>> p0Set=new HashMap<String,Counter<String>>();
  String fileFormat=props.getProperty("fileFormat");
  Map<String,Set<String>> seedWords=readSeedWords(props);
  Map<String,Class> answerClasses=new HashMap<String,Class>();
  String ansClasses=props.getProperty("answerClasses");
  if (ansClasses != null) {
    for (    String l : ansClasses.split(";")) {
      String[] t=l.split(",");
      String label=t[0];
      String cl=t[1];
      Class answerClass=ClassLoader.getSystemClassLoader().loadClass(cl);
      answerClasses.put(label,answerClass);
    }
  }
  Map<String,List<CoreLabel>> sents=null;
  boolean batchProcessSents=Boolean.parseBoolean(props.getProperty("batchProcessSents","false"));
  int numMaxSentencesPerBatchFile=Integer.parseInt(props.getProperty("numMaxSentencesPerBatchFile",String.valueOf(Integer.MAX_VALUE)));
  boolean preserveSentenceSequence=Boolean.parseBoolean(props.getProperty("preserveSentenceSequence","false"));
  if (!batchProcessSents) {
    if (preserveSentenceSequence)     sents=new LinkedHashMap<String,List<CoreLabel>>();
 else     sents=new HashMap<String,List<CoreLabel>>();
  }
 else {
    Data.sentsFiles=new ArrayList<File>();
    Data.sentId2File=new ConcurrentHashMap<String,File>();
  }
  String file=props.getProperty("file");
  String posModelPath=props.getProperty("posModelPath");
  boolean lowercase=Boolean.parseBoolean(props.getProperty("lowercaseText"));
  boolean useTargetNERRestriction=Boolean.parseBoolean(props.getProperty("useTargetNERRestriction"));
  boolean useTargetParserParentRestriction=Boolean.parseBoolean(props.getProperty("useTargetParserParentRestriction"));
  boolean useContextNERRestriction=Boolean.parseBoolean(props.getProperty("useContextNERRestriction"));
  boolean evaluate=Boolean.parseBoolean(props.getProperty("evaluate"));
  boolean addEvalSentsToTrain=Boolean.parseBoolean(props.getProperty("addEvalSentsToTrain"));
  String evalFileWithGoldLabels=props.getProperty("evalFileWithGoldLabels");
  if (file == null && (evalFileWithGoldLabels == null || addEvalSentsToTrain == false)) {
    throw new RuntimeException("No training data! file is " + file + " and evalFileWithGoldLabels is "+ evalFileWithGoldLabels+ " and addEvalSentsToTrain is "+ addEvalSentsToTrain);
  }
  File saveSentencesSerDir=null;
  File tempSaveSentencesDir=null;
  if (file != null) {
    String saveSentencesSerDirstr=props.getProperty("saveSentencesSerDir");
    if (saveSentencesSerDirstr != null) {
      saveSentencesSerDir=new File(saveSentencesSerDirstr);
      IOUtils.ensureDir(saveSentencesSerDir);
      if (!batchProcessSents)       IOUtils.writeObjectToFile(sents,saveSentencesSerDirstr + "/sents_all.ser");
    }
    String systemdir=System.getProperty("java.io.tmpdir");
    tempSaveSentencesDir=File.createTempFile("sents",".tmp",new File(systemdir));
    tempSaveSentencesDir.deleteOnExit();
    tempSaveSentencesDir.delete();
    tempSaveSentencesDir.mkdir();
    int numFilesTillNow=0;
    if (fileFormat == null || fileFormat.equalsIgnoreCase("text") || fileFormat.equalsIgnoreCase("txt")) {
      Map<String,List<CoreLabel>> sentsthis;
      if (preserveSentenceSequence)       sentsthis=new LinkedHashMap<String,List<CoreLabel>>();
 else       sentsthis=new HashMap<String,List<CoreLabel>>();
      for (      File f : GetPatternsFromDataMultiClass.getAllFiles(file)) {
        Redwood.log(Redwood.DBG,"Annotating text in " + f);
        Iterator<String> reader=IOUtils.readLines(f).iterator();
        while (reader.hasNext()) {
          numFilesTillNow=tokenize(reader,posModelPath,lowercase,useTargetNERRestriction || useContextNERRestriction,f.getName() + "-" + numFilesTillNow+ "-",useTargetParserParentRestriction,props.getProperty("numThreads"),batchProcessSents,numMaxSentencesPerBatchFile,saveSentencesSerDir == null ? tempSaveSentencesDir : saveSentencesSerDir,sentsthis,numFilesTillNow);
        }
        if (!batchProcessSents) {
          sents.putAll(sentsthis);
        }
      }
      if (!batchProcessSents) {
        IOUtils.writeObjectToFile(sents,(saveSentencesSerDir == null ? tempSaveSentencesDir : saveSentencesSerDir) + "/sents_" + numFilesTillNow);
      }
    }
 else     if (fileFormat.equalsIgnoreCase("ser")) {
      for (      File f : GetPatternsFromDataMultiClass.getAllFiles(file)) {
        Redwood.log(Redwood.DBG,"reading from ser file " + f);
        if (!batchProcessSents)         sents.putAll((Map<String,List<CoreLabel>>)IOUtils.readObjectFromFile(f));
 else {
          File newf=new File(tempSaveSentencesDir.getAbsolutePath() + "/" + f.getAbsolutePath().replaceAll(java.util.regex.Pattern.quote("/"),"_"));
          IOUtils.cp(f,newf);
          Data.sentsFiles.add(newf);
        }
      }
    }
 else {
      throw new RuntimeException("Cannot identify the file format. Valid values are text (or txt) and ser, where the serialized file is of the type Map<String, List<CoreLabel>>.");
    }
  }
  Map<String,List<CoreLabel>> evalsents=new HashMap<String,List<CoreLabel>>();
  File saveEvalSentencesSerFileFile=null;
  if (evaluate) {
    if (evalFileWithGoldLabels != null) {
      String saveEvalSentencesSerFile=props.getProperty("saveEvalSentencesSerFile");
      if (saveEvalSentencesSerFile == null) {
        String systemdir=System.getProperty("java.io.tmpdir");
        saveEvalSentencesSerFileFile=File.createTempFile("evalsents",".tmp",new File(systemdir));
      }
 else       saveEvalSentencesSerFileFile=new File(saveEvalSentencesSerFile);
      Map setClassForTheseLabels=new HashMap<String,Class>();
      List<File> allFiles=GetPatternsFromDataMultiClass.getAllFiles(evalFileWithGoldLabels);
      int numFile=0;
      String evalFileFormat=props.getProperty("evalFileFormat");
      if (evalFileFormat == null || evalFileFormat.equalsIgnoreCase("text") || evalFileFormat.equalsIgnoreCase("txt")) {
        for (        File f : allFiles) {
          numFile++;
          Redwood.log(Redwood.DBG,"Annotating text in " + f + ". Num file "+ numFile);
          List<CoreMap> sentsCMs=AnnotatedTextReader.parseFile(new BufferedReader(new FileReader(f)),seedWords.keySet(),setClassForTheseLabels,true,f.getName());
          evalsents.putAll(runPOSNEROnTokens(sentsCMs,posModelPath,useTargetNERRestriction || useContextNERRestriction,"",useTargetParserParentRestriction,props.getProperty("numThreads")));
        }
      }
 else       if (fileFormat.equalsIgnoreCase("ser")) {
        for (        File f : allFiles) {
          evalsents.putAll((Map<? extends String,? extends List<CoreLabel>>)IOUtils.readObjectFromFile(f));
        }
      }
      Redwood.log(Redwood.DBG,"Adding " + evalsents.size() + " eval sents to the training set");
      IOUtils.writeObjectToFile(evalsents,saveEvalSentencesSerFileFile);
      if (batchProcessSents) {
        Data.sentsFiles.add(saveEvalSentencesSerFileFile);
        for (        String k : evalsents.keySet())         Data.sentId2File.put(k,saveEvalSentencesSerFileFile);
      }
 else       sents.putAll(evalsents);
    }
  }
  boolean learn=Boolean.parseBoolean(props.getProperty("learn","true"));
  boolean labelUsingSeedSets=Boolean.parseBoolean(props.getProperty("labelUsingSeedSets","true"));
  GetPatternsFromDataMultiClass<E> model=new GetPatternsFromDataMultiClass<E>(props,sents,seedWords,labelUsingSeedSets);
  Execution.fillOptions(model,props);
  String sentsOutFile=props.getProperty("sentsOutFile");
  String wordsOutputFile=props.getProperty("wordsOutputFile");
  String patternOutFile=props.getProperty("patternOutFile");
  boolean loadSavedPatternsWordsDir=Boolean.parseBoolean(props.getProperty("loadSavedPatternsWordsDir"));
  boolean labelSentsUsingModel=Boolean.parseBoolean(props.getProperty("labelSentsUsingModel","true"));
  boolean applyPatsUsingModel=Boolean.parseBoolean(props.getProperty("applyPatsUsingModel","true"));
  if (loadSavedPatternsWordsDir) {
    loadFromSavedPatternsWordsDir(model,props,labelSentsUsingModel,applyPatsUsingModel);
  }
  if (learn)   model.iterateExtractApply(p0,p0Set,wordsOutputFile,sentsOutFile,patternOutFile,ignorePatterns);
  if (model.constVars.markedOutputTextFile != null) {
    model.writeLabeledData(model.constVars.markedOutputTextFile);
  }
  if (model.constVars.columnOutputFile != null)   model.writeColumnOutput(model.constVars.columnOutputFile);
  boolean savePatternsWordsDir=Boolean.parseBoolean(props.getProperty("savePatternsWordsDir"));
  if (savePatternsWordsDir) {
    String patternsWordsDir=props.getProperty("patternsWordsDir");
    for (    String label : model.constVars.getLabelDictionary().keySet()) {
      IOUtils.ensureDir(new File(patternsWordsDir + "/" + label));
      Counter<E> pats=model.getLearnedPatterns(label);
      IOUtils.writeObjectToFile(pats,patternsWordsDir + "/" + label+ "/patterns.ser");
      BufferedWriter w=new BufferedWriter(new FileWriter(patternsWordsDir + "/" + label+ "/phrases.txt"));
      model.writeWordsToFile(model.getLearnedWords(label),w);
      w.close();
    }
  }
  if (evaluate) {
    String goldEntitiesEvalFiles=props.getProperty("goldEntitiesEvalFiles");
    if (goldEntitiesEvalFiles != null) {
      for (      String gfile : goldEntitiesEvalFiles.split(";")) {
        String[] t=gfile.split(",");
        String label=t[0];
        String goldfile=t[1];
        Map<String,Boolean> goldWords4Label=new HashMap<String,Boolean>();
        for (        String line : IOUtils.readLines(goldfile)) {
          line=line.trim();
          if (line.isEmpty())           continue;
          if (line.endsWith("#"))           goldWords4Label.put(line.substring(0,line.length() - 1),false);
 else           goldWords4Label.put(line,true);
        }
        Pair<Double,Double> pr=model.getPrecisionRecall(label,goldWords4Label);
        Redwood.log(ConstantsAndVariables.minimaldebug,"\nFor label " + label + ": Number of gold entities is "+ goldWords4Label.size()+ ", Precision is "+ model.df.format(pr.first() * 100)+ ", Recall is "+ model.df.format(pr.second() * 100)+ ", F1 is "+ model.df.format(model.FScore(pr.first(),pr.second(),1.0) * 100)+ "\n\n");
      }
    }
    if (saveEvalSentencesSerFileFile != null && saveEvalSentencesSerFileFile.exists()) {
      if (batchProcessSents)       evalsents=IOUtils.readObjectFromFile(saveEvalSentencesSerFileFile);
      boolean evalPerEntity=Boolean.parseBoolean(props.getProperty("evalPerEntity","true"));
      model.evaluate(evalsents,evalPerEntity);
    }
    if (evalsents.size() == 0 && goldEntitiesEvalFiles == null)     System.err.println("No eval sentences or list of gold entities provided to evaluate! Make sure evalFileWithGoldLabels or goldEntitiesEvalFiles is set, or turn off the evaluate flag");
  }
  if (model.constVars.saveInvertedIndex) {
    model.constVars.invertedIndex.saveIndex(model.constVars.invertedIndexDirectory);
  }
  if (model.constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.LUCENE)) {
    model.patsForEachToken.close();
  }
  return model;
}
