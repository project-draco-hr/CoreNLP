{
  Map<String,List<CoreLabel>> newsent=new HashMap<String,List<CoreLabel>>();
  for (  String k : keyset) {
    List<CoreLabel> sent=sents.get(k);
    String[] tokens=new String[sent.size()];
    String[] tokenslemma=new String[sent.size()];
    int num=0;
    for (    CoreLabel l : sent) {
      l.set(PatternsAnnotations.ProcessedTextAnnotation.class,stringTransformation.apply(l));
      tokens[num]=l.word();
      if (l.lemma() == null)       throw new RuntimeException("how come lemma is null");
      tokenslemma[num]=l.lemma();
      num++;
    }
    boolean[] labels=new boolean[tokens.length];
    CollectionValuedMap<Integer,String> matchedPhrases=new CollectionValuedMap<Integer,String>();
    Map<Integer,String> longestMatchedPhrases=new HashMap<Integer,String>();
    for (    String[] s : seedwordsTokens) {
      List<Integer> indices=getSubListIndex(s,tokens,tokenslemma,dictWords,seenFuzzyMatches,minLen4FuzzyForPattern);
      if (indices != null && !indices.isEmpty()) {
        String ph=StringUtils.join(s," ");
        for (        int index : indices) {
          if (writeMatchedTokensIdsForEachPhrase)           Data.matchedTokensForEachPhrase.add(ph,new Triple(k,index,s.length));
          for (int i=0; i < s.length; i++) {
            matchedPhrases.add(index + i,ph);
            String longPh=longestMatchedPhrases.get(index + i);
            longPh=longPh != null && longPh.length() > ph.length() ? longPh : ph;
            longestMatchedPhrases.put(index + i,longPh);
            labels[index + i]=true;
          }
        }
      }
    }
    int i=-1;
    for (    CoreLabel l : sent) {
      i++;
      if (!l.containsKey(PatternsAnnotations.MatchedPhrases.class) || !(PatternsAnnotations.MatchedPhrases.class.isInstance(l.get(PatternsAnnotations.MatchedPhrases.class))))       l.set(PatternsAnnotations.MatchedPhrases.class,new CollectionValuedMap<String,String>());
      if (!l.containsKey(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class))       l.set(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class,new HashMap<String,String>());
      if (labels[i]) {
        l.set(labelClass,label);
        if (!l.containsKey(PatternsAnnotations.SeedLabeledOrNot.class))         l.set(PatternsAnnotations.SeedLabeledOrNot.class,new HashMap<Class,Boolean>());
        l.get(PatternsAnnotations.SeedLabeledOrNot.class).put(labelClass,true);
        String longestMatching=l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).get(label);
        longestMatching=(longestMatching != null && (longestMatching.length() > longestMatchedPhrases.get(i).length())) ? longestMatching : longestMatchedPhrases.get(i);
        l.get(PatternsAnnotations.LongestMatchedPhraseForEachLabel.class).put(label,longestMatching);
        l.get(PatternsAnnotations.MatchedPhrases.class).addAll(label,matchedPhrases.get(i));
        Redwood.log(ConstantsAndVariables.extremedebug,"labeling " + l.word() + " or its lemma "+ l.lemma()+ " as "+ label+ " because of the dict phrases "+ (Set<String>)matchedPhrases.get(i));
      }
 else       l.set(labelClass,backgroundSymbol);
    }
    newsent.put(k,sent);
  }
  return newsent;
}
