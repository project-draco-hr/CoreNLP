{
  Collection<Example> examples=input.first();
  FeedforwardParams params=input.second();
  gradW1=new double[params.getW1().length][params.getW1()[0].length];
  gradb1=new double[params.getB1().length];
  gradW2=new double[params.getW2().length][params.getW2()[0].length];
  gradE=new double[params.getE().length][params.getE()[0].length];
  gradSaved=new double[numPreComputed][hiddenSize];
  double cost=0.0;
  double correct=0.0;
  for (  Example ex : examples) {
    List<Integer> feature=ex.getFeature();
    List<Integer> label=ex.getLabel();
    double[] scores=new double[numLabels];
    double[] hidden=new double[hiddenSize];
    double[] hidden3=new double[hiddenSize];
    List<Integer> unDropped=new ArrayList<Integer>();
    int numH=0;
    for (int i=0; i < hiddenSize; ++i) {
      if (random.nextDouble() > params.getDropOutProb()) {
        numH+=1;
        unDropped.add(i);
      }
    }
    int[] ls=CollectionUtils.asIntArray(unDropped);
    int offset=0;
    for (int j=0; j < numTokens; ++j) {
      int tok=feature.get(j);
      int index=tok * numTokens + j;
      if (preMap.containsKey(index)) {
        int id=preMap.get(index);
        for (        int nodeIndex : ls)         hidden[nodeIndex]+=saved[id][nodeIndex];
      }
 else {
        for (        int nodeIndex : ls) {
          for (int k=0; k < embeddingSize; ++k)           hidden[nodeIndex]+=W1[nodeIndex][offset + k] * E[tok][k];
        }
      }
      offset+=embeddingSize;
    }
    for (    int nodeIndex : ls) {
      hidden[nodeIndex]+=b1[nodeIndex];
      hidden3[nodeIndex]=Math.pow(hidden[nodeIndex],3);
    }
    int optLabel=-1;
    for (int i=0; i < numLabels; ++i) {
      if (label.get(i) >= 0) {
        for (        int nodeIndex : ls)         scores[i]+=W2[i][nodeIndex] * hidden3[nodeIndex];
        if (optLabel < 0 || scores[i] > scores[optLabel])         optLabel=i;
      }
    }
    double sum1=0.0;
    double sum2=0.0;
    double maxScore=scores[optLabel];
    for (int i=0; i < numLabels; ++i) {
      if (label.get(i) >= 0) {
        scores[i]=Math.exp(scores[i] - maxScore);
        if (label.get(i) == 1)         sum1+=scores[i];
        sum2+=scores[i];
      }
    }
    cost+=(Math.log(sum2) - Math.log(sum1)) / examples.size();
    if (label.get(optLabel) == 1)     correct+=+1.0 / examples.size();
    double[] gradHidden3=new double[hiddenSize];
    for (int i=0; i < numLabels; ++i)     if (label.get(i) >= 0) {
      double delta=-(label.get(i) - scores[i] / sum2) / examples.size();
      for (int lj=0; lj < numH; ++lj) {
        int j=ls[lj];
        gradW2[i][j]+=delta * hidden3[j];
        gradHidden3[j]+=delta * W2[i][j];
      }
    }
    double[] gradHidden=new double[hiddenSize];
    for (int li=0; li < numH; ++li) {
      int i=ls[li];
      gradHidden[i]=gradHidden3[i] * 3 * hidden[i]* hidden[i];
      gradb1[i]+=gradHidden3[i];
    }
    offset=0;
    for (int j=0; j < numTokens; ++j) {
      int tok=feature.get(j);
      int index=tok * numTokens + j;
      if (preMap.containsKey(index)) {
        int id=preMap.get(index);
        for (int li=0; li < numH; ++li)         gradSaved[id][ls[li]]+=gradHidden[ls[li]];
      }
 else {
        for (int li=0; li < numH; ++li) {
          int i=ls[li];
          for (int k=0; k < embeddingSize; ++k) {
            gradW1[i][offset + k]+=gradHidden[i] * E[tok][k];
            gradE[tok][k]+=gradHidden[i] * W1[i][offset + k];
          }
        }
      }
      offset+=embeddingSize;
    }
  }
  for (  int x : preMap.keySet()) {
    int mapX=preMap.get(x);
    int tok=x / numTokens;
    int offset=(x % numTokens) * embeddingSize;
    for (int j=0; j < hiddenSize; ++j) {
      double delta=gradSaved[mapX][j];
      for (int k=0; k < embeddingSize; ++k) {
        gradW1[j][offset + k]+=delta * E[tok][k];
        gradE[tok][k]+=delta * W1[j][offset + k];
      }
    }
  }
  double reg=params.getRegParameter();
  for (int i=0; i < W1.length; ++i)   for (int j=0; j < W1[i].length; ++j) {
    cost+=reg * W1[i][j] * W1[i][j] / 2.0;
    gradW1[i][j]+=reg * W1[i][j];
  }
  for (int i=0; i < b1.length; ++i) {
    cost+=reg * b1[i] * b1[i] / 2.0;
    gradb1[i]+=reg * b1[i];
  }
  for (int i=0; i < W2.length; ++i)   for (int j=0; j < W2[i].length; ++j) {
    cost+=reg * W2[i][j] * W2[i][j] / 2.0;
    gradW2[i][j]+=reg * W2[i][j];
  }
  for (int i=0; i < E.length; ++i)   for (int j=0; j < E[i].length; ++j) {
    cost+=reg * E[i][j] * E[i][j] / 2.0;
    gradE[i][j]+=reg * E[i][j];
  }
  return new Cost(cost,gradW1,gradb1,gradW2,gradE,gradSaved);
}
