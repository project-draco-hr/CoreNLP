{
  CollectionValuedMap<String,Integer> tokensMatchedPattern=new CollectionValuedMap<String,Integer>();
  TwoDimensionalCounter<Pair<String,String>,SurfacePattern> allFreq=new TwoDimensionalCounter<Pair<String,String>,SurfacePattern>();
  for (  String sentid : sentids) {
    List<CoreLabel> sent=Data.sents.get(sentid);
    for (    SurfacePattern pat : patterns.keySet()) {
      String patternStr=pat.toString();
      TokenSequencePattern p=TokenSequencePattern.compile(constVars.env.get(label),patternStr);
      if (pat == null || p == null)       throw new RuntimeException("why is the pattern " + pat + " null?");
      TokenSequenceMatcher m=p.getMatcher(sent);
      while (m.find()) {
        int s=m.start("$term");
        int e=m.end("$term");
        String phrase="";
        String phraseLemma="";
        boolean useWordNotLabeled=false;
        boolean doNotUse=false;
        for (int i=s; i < e; i++) {
          CoreLabel l=sent.get(i);
          l.set(PatternsAnnotations.MatchedPattern.class,true);
          if (restrictToMatched) {
            tokensMatchedPattern.add(sentid,i);
          }
          for (          Entry<Class,Object> ig : constVars.ignoreWordswithClassesDuringSelection.get(label).entrySet()) {
            if (l.containsKey(ig.getKey()) && l.get(ig.getKey()).equals(ig.getValue())) {
              doNotUse=true;
            }
          }
          boolean containsStop=containsStopWord(l,constVars.getCommonEngWords(),constVars.ignoreWordRegex,ignoreWords);
          if (removePhrasesWithStopWords && containsStop) {
            doNotUse=true;
          }
 else {
            if (!containsStop || !removeStopWordsFromSelectedPhrases) {
              if (label == null || l.get(constVars.answerClass.get(label)) == null || !l.get(constVars.answerClass.get(label)).equals(label.toString())) {
                useWordNotLabeled=true;
              }
              phrase+=" " + l.word();
              phraseLemma+=" " + l.lemma();
            }
          }
        }
        if (!doNotUse && useWordNotLabeled) {
          phrase=phrase.trim();
          phraseLemma=phraseLemma.trim();
          allFreq.incrementCount(new Pair<String,String>(phrase,phraseLemma),pat,1.0);
        }
      }
    }
  }
  return new Pair<TwoDimensionalCounter<Pair<String,String>,SurfacePattern>,CollectionValuedMap<String,Integer>>(allFreq,tokensMatchedPattern);
}
