{
  Annotation ann=new Annotation(proto.getText());
  List<CoreLabel> tokens=new ArrayList<CoreLabel>();
  if (proto.getSentenceCount() > 0) {
    for (    CoreNLPProtos.Sentence sentence : proto.getSentenceList()) {
      for (      CoreNLPProtos.Token token : sentence.getTokenList()) {
        CoreLabel coreLabel=fromProto(token);
        if (proto.hasDocID()) {
          coreLabel.setDocID(proto.getDocID());
        }
        tokens.add(coreLabel);
      }
    }
  }
 else   if (proto.getSentencelessTokenCount() > 0) {
    if (proto.getSentencelessTokenCount() > 0) {
      for (      CoreNLPProtos.Token token : proto.getSentencelessTokenList()) {
        CoreLabel coreLabel=fromProto(token);
        if (proto.hasDocID()) {
          coreLabel.setDocID(proto.getDocID());
        }
        tokens.add(coreLabel);
      }
    }
  }
  if (!tokens.isEmpty()) {
    ann.set(TokensAnnotation.class,tokens);
  }
  List<CoreMap> sentences=new ArrayList<CoreMap>(proto.getSentenceCount());
  for (int sentIndex=0; sentIndex < proto.getSentenceCount(); ++sentIndex) {
    CoreNLPProtos.Sentence sentence=proto.getSentence(sentIndex);
    CoreMap map=fromProtoNoTokens(sentence);
    if (!tokens.isEmpty() && sentence.hasTokenOffsetBegin() && sentence.hasTokenOffsetEnd()) {
      int tokenBegin=Math.min(sentence.getTokenOffsetBegin(),tokens.size());
      int tokenEnd=Math.min(sentence.getTokenOffsetEnd(),tokens.size());
      map.set(TokensAnnotation.class,tokens.subList(tokenBegin,tokenEnd));
      for (int i=tokenBegin; i < tokenEnd; ++i) {
        tokens.get(i).setSentIndex(sentIndex);
        tokens.get(i).setIndex(i - sentence.getTokenOffsetBegin() + 1);
        if (sentence.hasParagraph()) {
          tokens.get(i).set(ParagraphAnnotation.class,sentence.getParagraph());
        }
      }
      int characterBegin=Math.min(sentence.getCharacterOffsetBegin(),proto.getText().length());
      int characterEnd=Math.min(sentence.getCharacterOffsetEnd(),proto.getText().length());
      map.set(TextAnnotation.class,proto.getText().substring(characterBegin,characterEnd));
    }
    sentences.add(map);
  }
  if (!sentences.isEmpty()) {
    ann.set(SentencesAnnotation.class,sentences);
  }
  String docid=null;
  if (proto.hasDocID()) {
    docid=proto.getDocID();
    ann.set(DocIDAnnotation.class,docid);
  }
  Map<Integer,CorefChain> corefChains=new HashMap<Integer,CorefChain>();
  for (  CoreNLPProtos.CorefChain chainProto : proto.getCorefChainList()) {
    CorefChain chain=fromProto(chainProto,ann);
    corefChains.put(chain.getChainID(),chain);
  }
  if (!corefChains.isEmpty()) {
    ann.set(CorefChainAnnotation.class,corefChains);
  }
  for (int i=0; i < proto.getSentenceCount(); ++i) {
    CoreNLPProtos.Sentence sentence=proto.getSentenceList().get(i);
    CoreMap map=sentences.get(i);
    List<CoreLabel> sentenceTokens=map.get(TokensAnnotation.class);
    if (sentence.hasBasicDependencies()) {
      map.set(BasicDependenciesAnnotation.class,fromProto(sentence.getBasicDependencies(),sentenceTokens,docid));
    }
    if (sentence.hasCollapsedDependencies()) {
      map.set(CollapsedDependenciesAnnotation.class,fromProto(sentence.getCollapsedDependencies(),sentenceTokens,docid));
    }
    if (sentence.hasCollapsedCCProcessedDependencies()) {
      map.set(CollapsedCCProcessedDependenciesAnnotation.class,fromProto(sentence.getCollapsedCCProcessedDependencies(),sentenceTokens,docid));
    }
  }
  for (  CoreMap sentence : sentences) {
    if (sentence.containsKey(TokensAnnotation.class)) {
      sentence.set(NumerizedTokensAnnotation.class,NumberNormalizer.findAndMergeNumbers(sentence));
    }
  }
  return ann;
}
