{
  System.err.println("Testing on treebank");
  Timing treebankTotalTtimer=new Timing();
  TreePrint treePrint=getTreePrint();
  TreebankLangParserParams tlpParams=op.tlpParams;
  TreebankLanguagePack tlp=op.langpack();
  PrintWriter pwOut=tlpParams.pw();
  PrintWriter pwErr=tlpParams.pw(System.err);
  if (op.testOptions.verbose) {
    pwErr.print("Testing ");
    pwErr.println(testTreebank.textualSummary(tlp));
  }
  if (op.testOptions.evalb) {
    EvalbFormatWriter.initEVALBfiles(tlpParams);
  }
  PrintWriter pwo=null;
  if (op.testOptions.writeOutputFiles) {
    String fname=op.testOptions.outputFilesPrefix + "." + op.testOptions.outputFilesExtension;
    try {
      pwo=op.tlpParams.pw(new FileOutputStream(fname));
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
    }
  }
  PrintWriter statsPwo=null;
  if (op.testOptions.outputkBestEquivocation != null) {
    try {
      statsPwo=op.tlpParams.pw(new FileOutputStream(op.testOptions.outputkBestEquivocation));
    }
 catch (    IOException ioe) {
      ioe.printStackTrace();
    }
  }
  TreeTransformer tc=tlpParams.collinizer();
  TreeTransformer br=new BoundaryRemover();
  boolean runningAverages=Boolean.parseBoolean(op.testOptions.evals.getProperty("runningAverages"));
  boolean summary=Boolean.parseBoolean(op.testOptions.evals.getProperty("summary"));
  boolean tsv=Boolean.parseBoolean(op.testOptions.evals.getProperty("tsv"));
  tlpParams.setupForEval();
  List<BestOfTopKEval> topKEvals=new ArrayList<BestOfTopKEval>();
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgTopK"))) {
    topKEvals.add(new BestOfTopKEval(new Evalb("pcfg top k comparisons",false),new Evalb("pcfg top k LP/LR",runningAverages)));
  }
  AbstractEval pcfgLB=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgLB"))) {
    pcfgLB=new Evalb("pcfg LP/LR",runningAverages);
  }
  LeafAncestorEval pcfgLA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgLA"))) {
    pcfgLA=new LeafAncestorEval("pcfg LeafAncestor");
  }
  AbstractEval pcfgCB=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgCB"))) {
    pcfgCB=new Evalb.CBEval("pcfg CB",runningAverages);
  }
  AbstractEval pcfgDA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgDA"))) {
    pcfgDA=new UnlabeledAttachmentEval("pcfg DA",runningAverages,tlp.headFinder());
  }
  AbstractEval pcfgTA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgTA"))) {
    pcfgTA=new TaggingEval("pcfg Tag",runningAverages,pparser.lex);
  }
  AbstractEval depDA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("depDA"))) {
    depDA=new UnlabeledAttachmentEval("dep DA",runningAverages,null,tlp.punctuationWordRejectFilter());
  }
  AbstractEval depTA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("depTA"))) {
    depTA=new TaggingEval("dep Tag",runningAverages,pparser.lex);
  }
  AbstractEval factLB=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factLB"))) {
    factLB=new Evalb("factor LP/LR",runningAverages);
  }
  LeafAncestorEval factLA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factLA"))) {
    factLA=new LeafAncestorEval("factor LeafAncestor");
  }
  AbstractEval factCB=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factCB"))) {
    factCB=new Evalb.CBEval("fact CB",runningAverages);
  }
  AbstractEval factDA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factDA"))) {
    factDA=new UnlabeledAttachmentEval("factor DA",runningAverages,null);
  }
  AbstractEval factTA=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factTA"))) {
    if (op.doPCFG) {
      factTA=new TaggingEval("factor Tag",runningAverages,pparser.lex);
    }
 else {
      factTA=new TaggingEval("factor Tag",runningAverages,pparser.lex);
    }
  }
  AbstractEval pcfgRUO=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgRUO"))) {
    pcfgRUO=new AbstractEval.RuleErrorEval("pcfg Rule under/over");
  }
  AbstractEval pcfgCUO=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgCUO"))) {
    pcfgCUO=new AbstractEval.CatErrorEval("pcfg Category under/over");
  }
  AbstractEval pcfgCatE=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgCatE"))) {
    pcfgCatE=new EvalbByCat("pcfg Category Eval",runningAverages);
  }
  AbstractEval.ScoreEval pcfgLL=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("pcfgLL"))) {
    pcfgLL=new AbstractEval.ScoreEval("pcfgLL",runningAverages);
  }
  AbstractEval.ScoreEval depLL=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("depLL"))) {
    depLL=new AbstractEval.ScoreEval("depLL",runningAverages);
  }
  AbstractEval.ScoreEval factLL=null;
  if (Boolean.parseBoolean(op.testOptions.evals.getProperty("factLL"))) {
    factLL=new AbstractEval.ScoreEval("factLL",runningAverages);
  }
  AbstractEval kGoodLB=new Evalb("kGood LP/LR",false);
  TreeAnnotatorAndBinarizer binarizerOnly;
  if (!op.trainOptions.leftToRight) {
    binarizerOnly=new TreeAnnotatorAndBinarizer(tlpParams,op.forceCNF,false,false,op);
  }
 else {
    binarizerOnly=new TreeAnnotatorAndBinarizer(tlpParams.headFinder(),new LeftHeadFinder(),tlpParams,op.forceCNF,false,false,op);
  }
  if (op.testOptions.preTag) {
    try {
      Class[] argsClass={String.class};
      Object[] arguments={op.testOptions.taggerSerializedFile};
      System.err.printf("Loading tagger from serialized file %s ...\n",op.testOptions.taggerSerializedFile);
      tagger=(Function<List<? extends HasWord>,ArrayList<TaggedWord>>)Class.forName("edu.stanford.nlp.tagger.maxent.MaxentTagger").getConstructor(argsClass).newInstance(arguments);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  int numSkippedEvals=0;
  boolean saidMemMessage=false;
  Timing timer=new Timing();
  for (  Tree goldTree : testTreebank) {
    final ArrayList<? extends HasWord> sentence=getInputSentence(goldTree);
    timer.start();
    pwErr.println("Parsing [len. " + sentence.size() + "]: "+ Sentence.listToString(sentence));
    Tree tree=null;
    List<ScoredObject<Tree>> kbestPCFGTrees=null;
    int kbestPCFG=0;
    if (topKEvals.size() > 0) {
      kbestPCFG=op.testOptions.evalPCFGkBest;
    }
    if (op.testOptions.printPCFGkBest > 0) {
      kbestPCFG=Math.max(kbestPCFG,op.testOptions.printPCFGkBest);
    }
    try {
      if (!parse(sentence)) {
        pwErr.print("Sentence couldn't be parsed by grammar.");
        if (pparser != null && pparser.hasParse() && fallbackToPCFG) {
          pwErr.println("... falling back to PCFG parse.");
          tree=getBestPCFGParse();
          if (kbestPCFG > 0) {
            kbestPCFGTrees=getKBestPCFGParses(kbestPCFG);
          }
        }
 else {
          pwErr.println();
        }
      }
 else {
        tree=getBestParse();
        if (kbestPCFG > 0) {
          kbestPCFGTrees=getKBestPCFGParses(kbestPCFG);
        }
        if (bparser != null)         pwErr.println("FactoredParser parse score is " + bparser.getBestScore());
      }
    }
 catch (    OutOfMemoryError e) {
      if (op.testOptions.maxLength != -0xDEADBEEF) {
        pwErr.print("NOT ENOUGH MEMORY TO PARSE SENTENCES OF LENGTH ");
        pwErr.println(op.testOptions.maxLength);
        throw e;
      }
 else {
        if (!saidMemMessage) {
          printOutOfMemory(pwErr);
          saidMemMessage=true;
        }
        if (pparser.hasParse() && fallbackToPCFG) {
          try {
            String what="dependency";
            if (dparser.hasParse()) {
              what="factored";
            }
            pwErr.println("Sentence too long for " + what + " parser.  Falling back to PCFG parse...");
            tree=getBestPCFGParse();
            if (kbestPCFG > 0) {
              kbestPCFGTrees=getKBestPCFGParses(kbestPCFG);
            }
          }
 catch (          OutOfMemoryError oome) {
            oome.printStackTrace();
            pwErr.println("No memory to gather PCFG parse. Skipping...");
            pparser.nudgeDownArraySize();
          }
        }
 else {
          pwErr.println("Sentence has no parse using PCFG grammar (or no PCFG fallback).  Skipping...");
        }
        pwErr.println();
      }
    }
catch (    UnsupportedOperationException uoe) {
      pwErr.println("Sentence too long (or zero words).");
      if (pwo != null) {
        pwo.println("(())");
      }
      continue;
    }
    if (op.testOptions.verbose) {
      pwOut.println("ComboParser best");
      Tree ot=tree;
      if (ot != null && !tlpParams.treebankLanguagePack().isStartSymbol(ot.value())) {
        ot=ot.treeFactory().newTreeNode(tlpParams.treebankLanguagePack().startSymbol(),Collections.singletonList(ot));
      }
      treePrint.printTree(ot,pwOut);
    }
 else {
      treePrint.printTree(tree,pwOut);
    }
    if (tree != null) {
      if (op.testOptions.printAllBestParses) {
        List<ScoredObject<Tree>> parses=pparser.getBestParses();
        int sz=parses.size();
        if (sz > 1) {
          pwOut.println("There were " + sz + " best PCFG parses with score "+ parses.get(0).score()+ '.');
          Tree transGoldTree=tc.transformTree(goldTree);
          int iii=0;
          for (          ScoredObject<Tree> sot : parses) {
            iii++;
            Tree tb=sot.object();
            Tree tbd=debinarizer.transformTree(tb);
            tbd=subcategoryStripper.transformTree(tbd);
            restoreOriginalWords(tbd);
            pwOut.println("PCFG Parse #" + iii + " with score "+ tbd.score());
            tbd.pennPrint(pwOut);
            Tree tbtr=tc.transformTree(tbd);
            kGoodLB.evaluate(tbtr,transGoldTree,pwErr);
          }
        }
      }
 else       if (op.testOptions.printPCFGkBest > 0 && op.testOptions.outputkBestEquivocation == null) {
        List<ScoredObject<Tree>> trees=kbestPCFGTrees.subList(0,op.testOptions.printPCFGkBest);
        Tree transGoldTree=tc.transformTree(goldTree);
        int i=0;
        for (        ScoredObject<Tree> tp : trees) {
          i++;
          pwOut.println("PCFG Parse #" + i + " with score "+ tp.score());
          Tree tbd=tp.object();
          tbd.pennPrint(pwOut);
          Tree tbtr=tc.transformTree(tbd);
          kGoodLB.evaluate(tbtr,transGoldTree,pwErr);
        }
      }
 else       if (op.testOptions.printFactoredKGood > 0 && bparser.hasParse()) {
        List<ScoredObject<Tree>> trees=getKGoodFactoredParses(op.testOptions.printFactoredKGood);
        Tree transGoldTree=tc.transformTree(goldTree);
        int ii=0;
        for (        ScoredObject<Tree> tp : trees) {
          ii++;
          pwOut.println("Factored Parse #" + ii + " with score "+ tp.score());
          Tree tbd=tp.object();
          tbd.pennPrint(pwOut);
          Tree tbtr=tc.transformTree(tbd);
          kGoodLB.evaluate(tbtr,transGoldTree,pwOut);
        }
      }
 else       if (pwo != null) {
        pwo.println(tree.toString());
      }
      if (op.testOptions.outputkBestEquivocation != null && op.testOptions.printPCFGkBest > 0) {
        List<ScoredObject<Tree>> trees=kbestPCFGTrees.subList(0,op.testOptions.printPCFGkBest);
        double[] logScores=new double[trees.size()];
        int treeId=0;
        for (        ScoredObject<Tree> kBestTree : trees)         logScores[treeId++]=kBestTree.score();
        double entropy=0.0;
        double denom=ArrayMath.logSum(logScores);
        for (        double logScore : logScores) {
          double logPr=logScore - denom;
          entropy+=Math.exp(logPr) * (logPr / Math.log(2));
        }
        entropy*=-1;
        statsPwo.printf("%f\t%d\t%d\n",entropy,trees.size(),sentence.size());
      }
    }
    if (tree != null) {
      tree=subcategoryStripper.transformTree(tree);
      Tree treeFact=tc.transformTree(tree);
      if (op.testOptions.verbose) {
        pwOut.println("Correct parse");
        treePrint.printTree(goldTree,pwOut);
      }
      Tree transGoldTree=tc.transformTree(goldTree);
      if (transGoldTree != null)       transGoldTree=subcategoryStripper.transformTree(transGoldTree);
      if (transGoldTree == null) {
        pwErr.println("Couldn't transform gold tree for evaluation, skipping eval. Gold tree was:");
        goldTree.pennPrint(pwErr);
        numSkippedEvals++;
        continue;
      }
 else       if (treeFact == null) {
        pwErr.println("Couldn't transform hypothesis tree for evaluation, skipping eval. Tree was:");
        tree.pennPrint(pwErr);
        numSkippedEvals++;
        continue;
      }
 else       if (treeFact.yield().size() != transGoldTree.yield().size()) {
        List<Label> fYield=treeFact.yield();
        List<Label> gYield=transGoldTree.yield();
        pwErr.println("WARNING: Evaluation could not be performed due to guess/gold yield mismatch.");
        pwErr.println("  sizes: g: " + gYield.size() + " p: "+ fYield.size());
        pwErr.println("  g: " + Sentence.listToString(gYield,true));
        pwErr.println("  p: " + Sentence.listToString(gYield,true));
        numSkippedEvals++;
        continue;
      }
      if (topKEvals.size() > 0) {
        List<Tree> transGuesses=new ArrayList<Tree>();
        int kbest=Math.min(op.testOptions.evalPCFGkBest,kbestPCFGTrees.size());
        for (        ScoredObject<Tree> guess : kbestPCFGTrees.subList(0,kbest)) {
          transGuesses.add(tc.transformTree(guess.object()));
        }
        for (        BestOfTopKEval eval : topKEvals) {
          eval.evaluate(transGuesses,transGoldTree,pwErr);
        }
      }
      Tree treePCFG=getBestPCFGParse();
      if (treePCFG != null) {
        Tree treePCFGeval=tc.transformTree(treePCFG);
        if (pcfgLB != null) {
          pcfgLB.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgLA != null) {
          pcfgLA.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgCB != null) {
          pcfgCB.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgDA != null) {
          treePCFGeval.indexLeaves(true);
          transGoldTree.indexLeaves(true);
          pcfgDA.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgTA != null) {
          pcfgTA.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgLL != null && pparser != null) {
          pcfgLL.recordScore(pparser,pwErr);
        }
        if (pcfgRUO != null) {
          pcfgRUO.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgCUO != null) {
          pcfgCUO.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
        if (pcfgCatE != null) {
          pcfgCatE.evaluate(treePCFGeval,transGoldTree,pwErr);
        }
      }
      Tree treeDep=getBestDependencyParse();
      if (treeDep != null) {
        Tree goldTreeB=binarizerOnly.transformTree(goldTree);
        Tree goldTreeEval=goldTree.deepCopy();
        goldTreeEval.indexLeaves(true);
        goldTreeEval.percolateHeads(tlp.headFinder());
        Tree depDAEval=getBestDependencyParse(true);
        depDAEval.indexLeaves(true);
        depDAEval.percolateHeadIndices();
        if (depDA != null) {
          depDA.evaluate(depDAEval,goldTreeEval,pwErr);
        }
        if (depTA != null) {
          Tree undoneTree=debinarizer.transformTree(treeDep);
          undoneTree=subcategoryStripper.transformTree(undoneTree);
          restoreOriginalWords(undoneTree);
          depTA.evaluate(undoneTree,goldTree,pwErr);
        }
        if (depLL != null && dparser != null) {
          depLL.recordScore(dparser,pwErr);
        }
        Tree factTreeB;
        if (bparser != null && parseSucceeded) {
          factTreeB=bparser.getBestParse();
        }
 else {
          factTreeB=treeDep;
        }
        if (factDA != null) {
          factDA.evaluate(factTreeB,goldTreeB,pwErr);
        }
      }
      if (factLB != null) {
        factLB.evaluate(treeFact,transGoldTree,pwErr);
      }
      if (factLA != null) {
        factLA.evaluate(treeFact,transGoldTree,pwErr);
      }
      if (factTA != null) {
        factTA.evaluate(tree,br.transformTree(goldTree),pwErr);
      }
      if (factLL != null && bparser != null) {
        factLL.recordScore(bparser,pwErr);
      }
      if (factCB != null) {
        factCB.evaluate(treeFact,transGoldTree,pwErr);
      }
      if (op.testOptions.evalb) {
        nanScores(tree);
        EvalbFormatWriter.writeEVALBline(treeFact,transGoldTree);
      }
    }
    pwErr.println();
  }
  treebankTotalTtimer.done("Testing on treebank");
  if (saidMemMessage) {
    printOutOfMemory(pwErr);
  }
  if (op.testOptions.evalb) {
    EvalbFormatWriter.closeEVALBfiles();
  }
  if (numSkippedEvals != 0) {
    pwOut.printf("Unable to evaluate %d parser hypotheses due to yield mismatch\n",numSkippedEvals);
  }
  if (summary) {
    if (pcfgLB != null)     pcfgLB.display(false,pwErr);
    if (pcfgLA != null)     pcfgLA.display(false,pwErr);
    if (pcfgCB != null)     pcfgCB.display(false,pwErr);
    if (pcfgDA != null)     pcfgDA.display(false,pwErr);
    if (pcfgTA != null)     pcfgTA.display(false,pwErr);
    if (pcfgLL != null && pparser != null)     pcfgLL.display(false,pwErr);
    if (depDA != null)     depDA.display(false,pwErr);
    if (depTA != null)     depTA.display(false,pwErr);
    if (depLL != null && dparser != null)     depLL.display(false,pwErr);
    if (factLB != null)     factLB.display(false,pwErr);
    if (factLA != null)     factLA.display(false,pwErr);
    if (factCB != null)     factCB.display(false,pwErr);
    if (factDA != null)     factDA.display(false,pwErr);
    if (factTA != null)     factTA.display(false,pwErr);
    if (factLL != null && bparser != null)     factLL.display(false,pwErr);
    if (pcfgCatE != null)     pcfgCatE.display(false,pwErr);
    for (    BestOfTopKEval eval : topKEvals) {
      eval.display(false,pwErr);
    }
  }
  if (pcfgRUO != null)   pcfgRUO.display(true,pwErr);
  if (pcfgCUO != null)   pcfgCUO.display(true,pwErr);
  if (tsv) {
    NumberFormat nf=new DecimalFormat("0.00");
    pwErr.println("factF1\tfactDA\tfactEx\tpcfgF1\tdepDA\tfactTA\tnum");
    if (factLB != null)     pwErr.print(nf.format(factLB.getEvalbF1Percent()));
    pwErr.print("\t");
    if (dparser != null && factDA != null)     pwErr.print(nf.format(factDA.getEvalbF1Percent()));
    pwErr.print("\t");
    if (factLB != null)     pwErr.print(nf.format(factLB.getExactPercent()));
    pwErr.print("\t");
    if (pcfgLB != null)     pwErr.print(nf.format(pcfgLB.getEvalbF1Percent()));
    pwErr.print("\t");
    if (dparser != null && depDA != null)     pwErr.print(nf.format(depDA.getEvalbF1Percent()));
    pwErr.print("\t");
    if (pparser != null && factTA != null)     pwErr.print(nf.format(factTA.getEvalbF1Percent()));
    pwErr.print("\t");
    if (factLB != null)     pwErr.print(factLB.getNum());
    pwErr.println();
  }
  double f1=0.0;
  if (factLB != null) {
    f1=factLB.getEvalbF1();
  }
  if (pwo != null)   pwo.close();
  if (statsPwo != null)   statsPwo.close();
  return f1;
}
