{
  PriorityQueue<CoreLabel> chunk=new FixedPrioritiesPriorityQueue<>();
  Queue<IndexedWord> fringe=new LinkedList<>();
  IndexedWord root=originalRoot;
  fringe.add(root);
  boolean isCopula=false;
  for (  SemanticGraphEdge edge : parse.outgoingEdgeIterable(originalRoot)) {
    if (edge.getRelation().getShortName().equals("cop")) {
      isCopula=true;
    }
  }
  while (!fringe.isEmpty()) {
    root=fringe.poll();
    chunk.add(root.backingLabel(),-root.index());
    for (    SemanticGraphEdge edge : parse.incomingEdgeIterable(root)) {
      if (edge.getDependent() != originalRoot) {
        if (edge.getRelation().toString().startsWith("prep_") || edge.getRelation().toString().startsWith("prepc_")) {
          chunk.add(mockNode(edge.getGovernor().backingLabel(),1,edge.getRelation().toString().substring(edge.getRelation().toString().indexOf("_") + 1),"PP"),-(((double)edge.getGovernor().index()) + 0.9));
        }
        if (edge.getRelation().getShortName().equals("conj")) {
          chunk.add(mockNode(root.backingLabel(),-1,edge.getRelation().getSpecific(),"CC"),-(((double)root.index()) - 0.9));
        }
      }
    }
    for (    SemanticGraphEdge edge : parse.getOutEdgesSorted(root)) {
      String shortName=edge.getRelation().getShortName();
      String name=edge.getRelation().toString();
      if (isCopula && (shortName.equals("cop") || shortName.contains("subj"))) {
      }
 else       if (ignoredArc.isPresent() && ignoredArc.get().equals(name)) {
      }
 else       if (!validArcs.contains(edge.getRelation().getShortName().replaceAll("_.*","_*"))) {
        return Optional.empty();
      }
 else {
        fringe.add(edge.getDependent());
      }
    }
  }
  return Optional.of(chunk.toSortedList());
}
