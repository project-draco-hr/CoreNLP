{
  PriorityQueue<CoreLabel> chunk=new FixedPrioritiesPriorityQueue<>();
  Queue<IndexedWord> fringe=new LinkedList<>();
  IndexedWord root=originalRoot;
  fringe.add(root);
  boolean isCopula=false;
  for (  SemanticGraphEdge edge : parse.outgoingEdgeIterable(originalRoot)) {
    if (edge.getRelation().getShortName().equals("cop")) {
      isCopula=true;
    }
  }
  while (!fringe.isEmpty()) {
    root=fringe.poll();
    chunk.add(root.backingLabel(),-root.index());
    for (    SemanticGraphEdge edge : parse.incomingEdgeIterable(root)) {
      if (edge.getDependent() != originalRoot) {
        if (edge.getRelation().getShortName().equals("prep") || edge.getRelation().getShortName().equals("prepc")) {
          chunk.add(mockNode(edge.getGovernor().backingLabel(),1,edge.getRelation().getSpecific(),"PP"),-(((double)edge.getGovernor().index()) + 0.9));
        }
        if (edge.getRelation().getShortName().equals("conj")) {
          chunk.add(mockNode(root.backingLabel(),-1,edge.getRelation().getSpecific(),"CC"),-(((double)root.index()) - 0.9));
        }
      }
    }
    for (    SemanticGraphEdge edge : parse.getOutEdgesSorted(root)) {
      String shortName=edge.getRelation().getShortName();
      if (isCopula && (shortName.equals("cop") || shortName.contains("subj"))) {
      }
 else       if (!validArcs.contains(edge.getRelation().getShortName())) {
        return Optional.empty();
      }
 else {
        fringe.add(edge.getDependent());
      }
    }
  }
  return Optional.of(chunk.toSortedList());
}
