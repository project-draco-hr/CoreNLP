{
  PriorityQueue<CoreLabel> chunk=new FixedPrioritiesPriorityQueue<>();
  Queue<IndexedWord> fringe=new LinkedList<>();
  fringe.add(root);
  while (!fringe.isEmpty()) {
    root=fringe.poll();
    chunk.add(root.backingLabel(),-root.index());
    for (    SemanticGraphEdge edge : parse.incomingEdgeIterable(root)) {
      if (edge.getRelation().getLongName().startsWith("conj_")) {
        CoreLabel mockAnd=new CoreLabel(root);
        String andPart=edge.getRelation().getSpecific();
        mockAnd.setWord(andPart);
        mockAnd.setLemma(andPart);
        mockAnd.setValue(andPart);
        mockAnd.setNER("O");
        mockAnd.setTag("PP");
        mockAnd.setIndex(root.index() - 1);
        chunk.add(mockAnd,-mockAnd.index());
      }
    }
    for (    SemanticGraphEdge edge : parse.getOutEdgesSorted(root)) {
      if (!validArcs.contains(edge.getRelation().getShortName())) {
        return Optional.empty();
      }
 else {
        fringe.add(edge.getDependent());
      }
    }
  }
  return Optional.of(chunk.toSortedList());
}
