{
  List<LineInfo> l=readLines(in);
  if (useReverse) {
    Collections.reverse(l);
  }
  Index<String> tagIndex=new HashIndex<String>();
  for (int i=0; i < l.size(); i++) {
    LineInfo lineInfo=l.get(i);
    tagIndex.add(lineInfo.answer);
  }
  SequenceModel ts=new Scorer(l,tagIndex,c,(!useTaggySequences ? (usePrevSequences ? 1 : 0) : maxLeft),(useNextSequences ? 1 : 0),answerArrays);
  BestSequenceFinder ti=new BeamBestSequenceFinder(beamSize,true,true);
  int[] tags=ti.bestSequence(ts);
  for (int i=0; i < l.size(); i++) {
    LineInfo lineInfo=l.get(i);
    String answer=tagIndex.get(tags[i]);
    lineInfo.answer=answer;
  }
  if (justify) {
    c.dump();
    for (int i=0; i < l.size(); i++) {
      LineInfo lineInfo=l.get(i);
      System.out.println(lineInfo.line + " " + lineInfo.answer);
      System.out.println("Position is: " + i);
      c.justificationOf(makeDatum(l,i));
    }
  }
  if (useEnds) {
    deEndify(l);
  }
  if (useReverse) {
    Collections.reverse(l);
  }
  for (int i=0; i < l.size(); i++) {
    LineInfo lineInfo=l.get(i);
    if (!lineInfo.word.equals(BOUNDARY)) {
      System.out.println(lineInfo.line + " " + lineInfo.answer);
    }
 else {
      System.out.println(lineInfo.line);
    }
  }
}
