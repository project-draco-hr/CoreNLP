{
  Counter<Integer> distSimClustersOfPositive=new ClassicCounter<Integer>();
  if (constVars.expandPositivesWhenSampling) {
    for (    CandidatePhrase s : CollectionUtils.union(constVars.getLearnedWords(answerLabel).keySet(),constVars.getSeedLabelDictionary().get(answerLabel))) {
      String[] toks=s.getPhrase().split("\\s+");
      if (!constVars.getWordClassClusters().containsKey(s.getPhrase())) {
        for (        String tok : toks) {
          if (constVars.getWordClassClusters().containsKey(tok)) {
            distSimClustersOfPositive.incrementCount(constVars.getWordClassClusters().get(tok));
          }
        }
      }
 else       distSimClustersOfPositive.incrementCount(constVars.getWordClassClusters().get(s.getPhrase()));
    }
  }
  RVFDataset<String,ScorePhraseMeasures> dataset=new RVFDataset<String,ScorePhraseMeasures>();
  int numpos=0;
  Set<CandidatePhrase> allNegativePhrases=new HashSet<CandidatePhrase>();
  Set<CandidatePhrase> allUnknownPhrases=new HashSet<CandidatePhrase>();
  Set<CandidatePhrase> allPositivePhrases=new HashSet<CandidatePhrase>();
  Counter<CandidatePhrase> allCloseToPositivePhrases=new ClassicCounter<CandidatePhrase>();
  ConstantsAndVariables.DataSentsIterator sentsIter=new ConstantsAndVariables.DataSentsIterator(constVars.batchProcessSents);
  while (sentsIter.hasNext()) {
    Pair<Map<String,DataInstance>,File> sentsf=sentsIter.next();
    Map<String,DataInstance> sents=sentsf.first();
    Redwood.log(Redwood.DBG,"Sampling datums from " + sentsf.second());
    if (computeRawFreq)     Data.computeRawFreqIfNull(sents,PatternFactory.numWordsCompound);
    List<List<String>> threadedSentIds=GetPatternsFromDataMultiClass.getThreadBatches(new ArrayList<String>(sents.keySet()),constVars.numThreads);
    ExecutorService executor=Executors.newFixedThreadPool(constVars.numThreads);
    List<Future<Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>>>> list=new ArrayList<Future<Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>>>>();
    for (    List<String> keys : threadedSentIds) {
      Callable<Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>>> task=new ChooseDatumsThread(answerLabel,sents,keys,forLearningPattern,wordsPatExtracted,allSelectedPatterns,distSimClustersOfPositive);
      Future<Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>>> submit=executor.submit(task);
      list.add(submit);
    }
    for (    Future<Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>>> future : list) {
      try {
        Quadruple<Set<CandidatePhrase>,Set<CandidatePhrase>,Set<CandidatePhrase>,Counter<CandidatePhrase>> result=future.get();
        allPositivePhrases.addAll(result.first());
        allNegativePhrases.addAll(result.second());
        allUnknownPhrases.addAll(result.third());
        allCloseToPositivePhrases.addAll(result.fourth());
      }
 catch (      Exception e) {
        executor.shutdownNow();
        throw new RuntimeException(e);
      }
    }
    executor.shutdown();
  }
  allPositivePhrases.addAll(constVars.getLearnedWords().get(answerLabel).keySet());
  if (constVars.expandPositivesWhenSampling) {
    Counters.retainTop(allCloseToPositivePhrases,(int)(allCloseToPositivePhrases.size() * constVars.subSampleUnkAsPosUsingSimPercentage));
    Redwood.log("Expanding positives by adding " + allCloseToPositivePhrases + " phrases");
    allPositivePhrases.addAll(allCloseToPositivePhrases.keySet());
  }
  BufferedWriter logFile=null;
  if (constVars.logFileVectorSimilarity != null)   logFile=new BufferedWriter(new FileWriter(constVars.logFileVectorSimilarity));
  System.out.println("all positive phrases are  " + allPositivePhrases);
  for (  CandidatePhrase candidate : allPositivePhrases) {
    Counter<ScorePhraseMeasures> feat=null;
    if (forLearningPattern) {
      feat=getPhraseFeaturesForPattern(answerLabel,candidate);
    }
 else {
      feat=getFeatures(answerLabel,candidate,wordsPatExtracted.getCounter(candidate),allSelectedPatterns);
    }
    RVFDatum<String,ScorePhraseMeasures> datum=new RVFDatum<String,ScorePhraseMeasures>(feat,"true");
    dataset.add(datum);
    numpos+=1;
    if (logFile != null && wordVectors.containsKey(candidate.getPhrase())) {
      logFile.write(candidate.getPhrase() + "-P" + " "+ ArrayUtils.toString(wordVectors.get(candidate.getPhrase())," ")+ "\n");
    }
  }
  Redwood.log(Redwood.DBG,"Number of pure negative phrases is " + allNegativePhrases.size());
  Redwood.log(Redwood.DBG,"Number of unknown phrases is " + allUnknownPhrases.size());
  if (constVars.subsampleUnkAsNegUsingSim) {
    Set<CandidatePhrase> chosenUnknown=chooseUnknownAsNegatives(allUnknownPhrases,answerLabel,constVars.subSampleUnkAsNegUsingSimPercentage,allPositivePhrases,logFile);
    Redwood.log(Redwood.DBG,"Choosing " + chosenUnknown.size() + " unknowns as negative based to their similarity to the positive phrases");
    allNegativePhrases.addAll(chosenUnknown);
  }
 else {
    allNegativePhrases.addAll(allUnknownPhrases);
  }
  if (allNegativePhrases.size() > numpos) {
    Redwood.log(Redwood.WARN,"Num of negative (" + allNegativePhrases.size() + ") is higher than number of positive phrases ("+ numpos+ ") = "+ (allNegativePhrases.size() / (double)numpos)+ ". "+ "Capping the number by taking the first numPositives as negative. Consider decreasing perSelectNeg and perSelectRand");
    int i=0;
    Set<CandidatePhrase> selectedNegPhrases=new HashSet<CandidatePhrase>();
    for (    CandidatePhrase p : allNegativePhrases) {
      if (i >= numpos)       break;
      selectedNegPhrases.add(p);
    }
    allNegativePhrases.clear();
    allNegativePhrases=selectedNegPhrases;
  }
  System.out.println("all negative phrases are " + allNegativePhrases);
  for (  CandidatePhrase negative : allNegativePhrases) {
    Counter<ScorePhraseMeasures> feat;
    if (forLearningPattern) {
      feat=getPhraseFeaturesForPattern(answerLabel,negative);
    }
 else {
      feat=getFeatures(answerLabel,negative,wordsPatExtracted.getCounter(negative),allSelectedPatterns);
    }
    RVFDatum<String,ScorePhraseMeasures> datum=new RVFDatum<String,ScorePhraseMeasures>(feat,"false");
    dataset.add(datum);
    if (logFile != null && wordVectors.containsKey(negative.getPhrase())) {
      logFile.write(negative.getPhrase() + "-N" + " "+ ArrayUtils.toString(wordVectors.get(negative.getPhrase())," ")+ "\n");
    }
  }
  System.out.println("Before feature count threshold, dataset stats are ");
  dataset.summaryStatistics();
  int threshold=2;
  dataset.applyFeatureCountThreshold(threshold);
  System.out.println("AFTER feature count threshold of " + threshold + ", dataset stats are ");
  dataset.summaryStatistics();
  Redwood.log(Redwood.DBG,"Eventually, number of positive datums:  " + numpos + " and number of negative datums: "+ allNegativePhrases.size());
  return dataset;
}
