{
  if (learnedScores.containsKey(word))   return learnedScores.getCount(word);
  double score;
  if (scoreClassifierType.equals(ClassifierType.DT)) {
    Counter<ScorePhraseMeasures> feat=null;
    if (forLearningPatterns)     feat=getPhraseFeaturesForPattern(label,word);
 else     feat=this.getFeatures(label,word,patternsThatExtractedPat,allSelectedPatterns);
    RVFDatum<String,ScorePhraseMeasures> d=new RVFDatum<String,ScorePhraseMeasures>(feat,Boolean.FALSE.toString());
    Counter<String> sc=classifier.scoresOf(d);
    score=sc.getCount(Boolean.TRUE.toString());
  }
 else   if (scoreClassifierType.equals(ClassifierType.LR)) {
    LogisticClassifier logcl=((LogisticClassifier)classifier);
    String l=(String)logcl.getLabelForInternalPositiveClass();
    boolean flipsign=false;
    if (l.equals(Boolean.FALSE.toString())) {
      flipsign=true;
    }
    Counter<ScorePhraseMeasures> feat=null;
    if (forLearningPatterns)     feat=getPhraseFeaturesForPattern(label,word);
 else     feat=this.getFeatures(label,word,patternsThatExtractedPat,allSelectedPatterns);
    RVFDatum<String,ScorePhraseMeasures> d=new RVFDatum<String,ScorePhraseMeasures>(feat,Boolean.FALSE.toString());
    score=logcl.probabilityOf(d);
    if (flipsign)     score=1 - score;
  }
 else   if (scoreClassifierType.equals(ClassifierType.SVM) || scoreClassifierType.equals(ClassifierType.RF)) {
    Counter<ScorePhraseMeasures> feat=null;
    if (forLearningPatterns)     feat=getPhraseFeaturesForPattern(label,word);
 else     feat=this.getFeatures(label,word,patternsThatExtractedPat,allSelectedPatterns);
    RVFDatum<String,ScorePhraseMeasures> d=new RVFDatum<String,ScorePhraseMeasures>(feat,Boolean.FALSE.toString());
    Counter<String> sc=classifier.scoresOf(d);
    score=sc.getCount(Boolean.TRUE.toString());
  }
 else   throw new RuntimeException("cannot identify classifier " + scoreClassifierType);
  this.learnedScores.setCount(word,score);
  return score;
}
