{
  SuffixNode<E> oldNode=null, currentNode;
  boolean canJump=false;
  int i=sequences.size();
  int j=i;
  sequences.addAll(sequence);
  if (terminate && !sequences.get(sequences.size() - 1).equals(termination_token)) {
    sequences.add(termination_token);
  }
  currentNode=root;
  for (; i < sequences.size(); i++) {
    count++;
    for (; j <= i; j++) {
      while ((currentNode != root) && (currentNode.suffixLink == null) && canJump) {
        currentNode=currentNode.parent;
      }
      PathEnd<E> path_end;
      if (currentNode == root) {
        path_end=walkTo(root,sequences,j,i + 1);
      }
 else {
        if (canJump) {
          currentNode=currentNode.suffixLink;
        }
        path_end=walkTo(currentNode,sequences,j + getPathLength(currentNode),i + 1);
      }
      currentNode=path_end.node;
      SuffixNode<E> newNode=null;
switch (path_end.end) {
case END_LEAF:
        addPositionToLeaf(j,currentNode);
case END_EDGE:
case END_INTERNAL:
      currentNode=currentNode.parent;
    break;
case EXTEND_INTERNAL:
  doExtendInternal(currentNode,i,j);
break;
case SPLIT_EDGE:
newNode=doSplitEdge(currentNode,i,j);
currentNode=newNode;
break;
}
if (oldNode != null) {
if (currentNode.isTerminal()) {
currentNode=currentNode.parent;
}
oldNode.suffixLink=currentNode;
}
oldNode=newNode;
if (path_end.end == End.END_LEAF || path_end.end == End.END_EDGE || path_end.end == End.END_INTERNAL) {
oldNode=null;
canJump=false;
break;
}
 else {
canJump=true;
}
}
}
setLeafEnds();
}
