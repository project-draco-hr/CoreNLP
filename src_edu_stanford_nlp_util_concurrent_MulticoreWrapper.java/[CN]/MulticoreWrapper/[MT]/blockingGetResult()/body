{
  try {
    Future<JobResult<O>> resultFuture;
    if (maxSubmitBlockTime > 0) {
      resultFuture=queue.poll(maxSubmitBlockTime,TimeUnit.MILLISECONDS);
    }
 else {
      resultFuture=queue.take();
    }
    if (resultFuture != null) {
      JobResult<O> result=resultFuture.get();
      QueueItem<O> output=new QueueItem<O>(result.output,result.inputItemId);
      outputQueue.add(output);
      idleProcessors.add(result.processorId);
      runningJobs.remove(result.inputItemId);
      return;
    }
  }
 catch (  InterruptedException e) {
    threadPool.shutdownNow();
    throw new RuntimeException(e);
  }
catch (  ExecutionException e) {
    threadPool.shutdownNow();
    throw new RuntimeException(e);
  }
  for (  Map.Entry<Integer,Future<JobResult<O>>> entry : runningJobs.entrySet()) {
    entry.getValue().cancel(true);
    QueueItem<O> output=new QueueItem<O>(null,entry.getKey());
    outputQueue.add(output);
  }
  runningJobs.clear();
  for (int i=0; i < nThreads; ++i) {
    try {
      queue.take();
      idleProcessors.add(i);
    }
 catch (    InterruptedException e) {
      throw new RuntimeException(e);
    }
  }
}
