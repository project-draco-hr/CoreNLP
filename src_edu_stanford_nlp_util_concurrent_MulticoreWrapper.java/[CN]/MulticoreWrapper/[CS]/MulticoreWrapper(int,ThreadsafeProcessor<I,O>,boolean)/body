{
  nThreads=numThreads <= 0 ? Runtime.getRuntime().availableProcessors() : numThreads;
  this.orderResults=orderResults;
  outputQueue=new PriorityQueue<QueueItem<O>>(10 * nThreads);
  threadPool=(ThreadPoolExecutor)Executors.newFixedThreadPool(nThreads);
  queue=new ExecutorCompletionService<JobResult<O>>(threadPool);
  processorList=new ArrayList<ThreadsafeProcessor<I,O>>(nThreads);
  idleProcessors=new ConcurrentLinkedQueue<Integer>();
  runningJobs=new HashMap<Integer,Future<JobResult<O>>>();
  threadPool.allowCoreThreadTimeOut(false);
  processorList.add(processor);
  idleProcessors.add(0);
  for (int i=1; i < nThreads; ++i) {
    processorList.add(processor.newInstance());
    idleProcessors.add(i);
  }
}
