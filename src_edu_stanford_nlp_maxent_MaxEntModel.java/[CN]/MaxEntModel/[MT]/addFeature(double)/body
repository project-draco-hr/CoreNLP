{
  int nextFeat=-1;
  double maxGain=-1.0;
  double temp=0.0;
  for (int i=0; i < feats.size(); i++) {
    if (!active[i]) {
      temp=prob.GainCompute(feats.get(i),gainerror);
      if (temp > maxGain) {
        maxGain=temp;
        nextFeat=i;
      }
    }
  }
  if ((nextFeat > -1) && (maxGain > gainlimit)) {
    active[nextFeat]=true;
    p.add(feats.get(nextFeat));
    correspondences[nextFeat]=p.fSize - 1;
    prob=new LambdaSolve(p,0.0001,0.00001);
    prob.improvedIterative();
    return nextFeat;
  }
 else {
    return -1;
  }
}
