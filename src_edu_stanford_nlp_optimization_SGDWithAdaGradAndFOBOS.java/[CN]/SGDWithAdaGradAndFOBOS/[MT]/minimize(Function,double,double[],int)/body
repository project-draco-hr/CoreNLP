{
  int totalSamples=0;
  int tuneSampleSize=0;
  sayln("Using lambda=" + lambda);
  if (f instanceof AbstractStochasticCachingDiffUpdateFunction) {
    AbstractStochasticCachingDiffUpdateFunction func=(AbstractStochasticCachingDiffUpdateFunction)f;
    func.sampleMethod=AbstractStochasticCachingDiffFunction.SamplingMethod.Shuffled;
    totalSamples=func.dataDimension();
    tuneSampleSize=Math.min(totalSamples,tuningSamples);
    if (tuneSampleSize < tuningSamples) {
      System.err.println("WARNING: Total number of samples=" + totalSamples + " is smaller than requested tuning sample size="+ tuningSamples+ "!!!");
    }
    sayln("Using sample size=" + tuneSampleSize);
  }
  x=new double[initial.length];
  double[] testUpdateCache=null, currentRateCache=null, bCache=null;
  double[] sumGradSquare=new double[initial.length];
  int[][] featureGrouping=null;
  if (prior != Prior.LASSO) {
    testUpdateCache=new double[initial.length];
    currentRateCache=new double[initial.length];
  }
  if (prior != Prior.LASSO && prior != Prior.RIDGE) {
    if (!(f instanceof HasFeatureGrouping)) {
      throw new UnsupportedOperationException("prior is specified to be ae-lasso or g-lasso, but function does not support feature grouping");
    }
    featureGrouping=((HasFeatureGrouping)f).getFeatureGrouping();
  }
  if (prior == Prior.sgLASSO) {
    bCache=new double[initial.length];
  }
  System.arraycopy(initial,0,x,0,x.length);
  int numBatches=1;
  if (f instanceof AbstractStochasticCachingDiffUpdateFunction) {
    numBatches=totalSamples / bSize;
  }
  boolean have_max=(maxIterations > 0 || numPasses > 0);
  if (!have_max) {
    throw new UnsupportedOperationException("No maximum number of iterations has been specified.");
  }
 else {
    maxIterations=Math.max(maxIterations,numPasses) * numBatches;
  }
  sayln("       Batch size of: " + bSize);
  sayln("       Data dimension of: " + totalSamples);
  sayln("       Batches per pass through data:  " + numBatches);
  sayln("       Number of passes is = " + numPasses);
  sayln("       Max iterations is = " + maxIterations);
  Timing total=new Timing();
  Timing current=new Timing();
  total.start();
  current.start();
  int iters=0;
  double gValue=0;
  double wValue=0;
  double sgsValue=0;
  double currentRate=0, testUpdate=0, realUpdate=0;
  for (int pass=0; pass < numPasses; pass++) {
    boolean doEval=(pass > 0 && evaluateIters > 0 && pass % evaluateIters == 0);
    double evalScore=Double.NEGATIVE_INFINITY;
    if (doEval) {
      evalScore=doEvaluation(x);
      if (useEvalImprovement && !toContinue(x,evalScore))       break;
    }
    say("Iter: " + iters + " pass "+ pass+ " batch 1 ... ");
    int numOfNonZero=0, numOfNonZeroGroup=0;
    String gSizeStr="";
    for (int batch=0; batch < numBatches; batch++) {
      iters++;
      double[] gradients=null;
      if (f instanceof AbstractStochasticCachingDiffUpdateFunction) {
        AbstractStochasticCachingDiffUpdateFunction func=(AbstractStochasticCachingDiffUpdateFunction)f;
        func.calculateStochasticGradient(x,bSize);
        gradients=func.getDerivative();
      }
 else       if (f instanceof AbstractCachingDiffFunction) {
        AbstractCachingDiffFunction func=(AbstractCachingDiffFunction)f;
        gradients=func.derivativeAt(x);
      }
      if (prior == Prior.LASSO || prior == Prior.RIDGE) {
        double testUpdateSquaredSum=0;
        Set<Integer> paramRange=null;
        if (f instanceof HasRegularizerParamRange) {
          paramRange=((HasRegularizerParamRange)f).getRegularizerParamRange(x);
        }
 else {
          paramRange=new HashSet<Integer>();
          for (int i=0; i < x.length; i++)           paramRange.add(i);
        }
        for (        int index : paramRange) {
          gValue=gradients[index];
          sgsValue=gValue * gValue;
          sumGradSquare[index]+=sgsValue;
          wValue=x[index];
          currentRate=initRate / (Math.sqrt(sumGradSquare[index]) + eps);
          testUpdate=wValue - (currentRate * gValue);
          if (prior == Prior.LASSO) {
            realUpdate=Math.signum(testUpdate) * pospart(Math.abs(testUpdate) - currentRate * lambda);
            x[index]=realUpdate;
            if (realUpdate != 0)             numOfNonZero++;
          }
 else           if (prior == Prior.RIDGE) {
            testUpdateSquaredSum+=testUpdate * testUpdate;
            testUpdateCache[index]=testUpdate;
            currentRateCache[index]=currentRate;
          }
        }
        if (prior == Prior.RIDGE) {
          double testUpdateNorm=Math.sqrt(testUpdateSquaredSum);
          for (int index=0; index < testUpdateCache.length; index++) {
            realUpdate=testUpdateCache[index] * pospart(1 - currentRateCache[index] * lambda / testUpdateNorm);
            x[index]=realUpdate;
            if (realUpdate != 0)             numOfNonZero++;
          }
        }
      }
 else {
        for (int gIndex=0; gIndex < featureGrouping.length; gIndex++) {
          int[] gFeatureIndices=featureGrouping[gIndex];
          double testUpdateSquaredSum=0;
          double testUpdateAbsSum=0;
          double M=gFeatureIndices.length;
          double dm=Math.log(M);
          for (          int index : gFeatureIndices) {
            gValue=gradients[index];
            sgsValue=gValue * gValue;
            sumGradSquare[index]+=sgsValue;
            wValue=x[index];
            currentRate=initRate / (Math.sqrt(sumGradSquare[index]) + eps);
            testUpdate=wValue - (currentRate * gValue);
            testUpdateSquaredSum+=testUpdate * testUpdate;
            testUpdateAbsSum+=Math.abs(testUpdate);
            testUpdateCache[index]=testUpdate;
            currentRateCache[index]=currentRate;
          }
          if (prior == Prior.gLASSO) {
            double testUpdateNorm=Math.sqrt(testUpdateSquaredSum);
            boolean groupHasNonZero=false;
            for (            int index : gFeatureIndices) {
              realUpdate=testUpdateCache[index] * pospart(1 - currentRateCache[index] * lambda * dm / testUpdateNorm);
              x[index]=realUpdate;
              if (realUpdate != 0) {
                numOfNonZero++;
                groupHasNonZero=true;
              }
            }
            if (groupHasNonZero)             numOfNonZeroGroup++;
          }
 else           if (prior == Prior.aeLASSO) {
            int nonZeroCount=0;
            boolean groupHasNonZero=false;
            for (            int index : gFeatureIndices) {
              double tau=currentRateCache[index] * lambda / (1 + currentRateCache[index] * lambda * M) * testUpdateAbsSum;
              realUpdate=Math.signum(testUpdateCache[index]) * pospart(Math.abs(testUpdateCache[index]) - tau);
              x[index]=realUpdate;
              if (realUpdate != 0) {
                numOfNonZero++;
                nonZeroCount++;
                groupHasNonZero=true;
              }
            }
            if (groupHasNonZero)             numOfNonZeroGroup++;
          }
 else           if (prior == Prior.sgLASSO) {
            double bSquaredSum=0, b=0;
            for (            int index : gFeatureIndices) {
              b=Math.signum(testUpdateCache[index]) * pospart(Math.abs(testUpdateCache[index]) - currentRateCache[index] * alpha * lambda);
              bCache[index]=b;
              bSquaredSum+=b * b;
            }
            double bNorm=Math.sqrt(bSquaredSum);
            int nonZeroCount=0;
            boolean groupHasNonZero=false;
            for (            int index : gFeatureIndices) {
              realUpdate=bCache[index] * pospart(1 - currentRateCache[index] * (1.0 - alpha) * lambda* dm / bNorm);
              x[index]=realUpdate;
              if (realUpdate != 0) {
                numOfNonZero++;
                nonZeroCount++;
                groupHasNonZero=true;
              }
            }
            if (groupHasNonZero) {
              numOfNonZeroGroup++;
            }
          }
        }
      }
    }
    try {
      ArrayMath.assertFinite(x,"x");
    }
 catch (    ArrayMath.InvalidElementException e) {
      System.err.println(e.toString());
      for (int i=0; i < x.length; i++) {
        x[i]=Double.NaN;
      }
      break;
    }
    sayln(String.valueOf(numBatches) + ", n0-fCount:" + numOfNonZero+ ((prior != Prior.LASSO && prior != Prior.RIDGE) ? ", n0-gCount:" + numOfNonZeroGroup : "")+ ((evalScore != Double.NEGATIVE_INFINITY) ? ", evalScore:" + evalScore : ""));
    if (iters >= maxIterations) {
      sayln("Online Optimization complete.  Stopped after max iterations");
      break;
    }
    if (total.report() >= maxTime) {
      sayln("Online Optimization complete.  Stopped after max time");
      break;
    }
  }
  if (evaluateIters > 0) {
    double evalScore=(useEvalImprovement ? doEvaluation(xBest) : doEvaluation(x));
    sayln("final evalScore is: " + evalScore);
  }
  sayln("Completed in: " + Timing.toSecondsString(total.report()) + " s");
  return (useEvalImprovement ? xBest : x);
}
