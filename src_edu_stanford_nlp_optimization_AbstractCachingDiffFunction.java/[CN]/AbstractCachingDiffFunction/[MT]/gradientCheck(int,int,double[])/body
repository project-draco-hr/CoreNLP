{
  double epsilon=1e-4;
  double diffThreshold=5e-2;
  double diffPctThreshold=1e-1;
  double twoEpsilon=epsilon * 2;
  int xLen=x.length;
  derivativeAt(x);
  double[] savedDeriv=new double[xLen];
  System.arraycopy(derivative,0,savedDeriv,0,derivative.length);
  double oldX, plusVal, minusVal, appDeriv, calcDeriv, diff, pct=0;
  int interval=x.length / numOfChecks;
  List<Integer> indicesToCheck=new ArrayList<Integer>();
  for (int paramIndex=0; paramIndex < xLen; paramIndex+=interval) {
    indicesToCheck.add(paramIndex);
  }
  for (int i=xLen - 1; i >= 0 && i > xLen - numOfChecks; i--) {
    indicesToCheck.add(i);
  }
  for (int i=1; i < xLen && i < numOfChecks; i++) {
    indicesToCheck.add(i);
  }
  for (int i=0; i < numOfRandomChecks; i++) {
    indicesToCheck.add(generator.nextInt(xLen));
  }
  for (  int paramIndex : indicesToCheck) {
    oldX=x[paramIndex];
    x[paramIndex]=oldX + epsilon;
    plusVal=valueAt(x);
    x[paramIndex]=oldX - epsilon;
    minusVal=valueAt(x);
    appDeriv=(plusVal - minusVal) / twoEpsilon;
    calcDeriv=savedDeriv[paramIndex];
    diff=Math.abs(appDeriv - calcDeriv);
    pct=diff / Math.min(Math.abs(appDeriv),Math.abs(calcDeriv));
    if (diff > diffThreshold && pct > diffPctThreshold) {
      System.err.println("Gradient check failed at index " + paramIndex + ", appGrad="+ appDeriv+ ", calcGrad="+ calcDeriv+ ", diff="+ diff+ ", pct="+ pct);
      return false;
    }
 else {
      System.err.println("Gradient check passed at index " + paramIndex + ", appGrad="+ appDeriv+ ", calcGrad="+ calcDeriv+ ", diff="+ diff+ ", pct="+ pct);
    }
    x[paramIndex]=oldX;
  }
  return true;
}
