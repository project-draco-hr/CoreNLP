{
  if (root.isEmpty())   return null;
  int extra=3;
  MatchQueue<K,V> best=new MatchQueue<K,V>(n,maxCost);
  List<PartialApproxMatch<K,V>>[][] matches=new List[target.size() + 1][];
  for (int i=0; i <= target.size(); i++) {
    for (int j=0; j <= target.size() + extra; j++) {
      if (j > 0) {
        boolean complete=(i == target.size()) && (j >= target.size());
        K t=(i > 0 && i <= target.size()) ? target.get(i - 1) : null;
        MatchQueue<K,V> queue=(multimatch) ? new MultiMatchQueue<K,V>(n,maxCost) : new MatchQueue<K,V>(n,maxCost);
        if (i > 0) {
          for (          PartialApproxMatch<K,V> pam : matches[i - 1][j - 1]) {
            if (pam.trie != null) {
              if (pam.trie.children != null) {
                for (                K k : pam.trie.children.keySet()) {
                  addToQueue(queue,best,costFunction,pam,t,k,multimatch,complete);
                }
              }
            }
          }
        }
        for (        PartialApproxMatch<K,V> pam : matches[i][j - 1]) {
          if (pam.trie != null) {
            if (pam.trie.children != null) {
              for (              K k : pam.trie.children.keySet()) {
                addToQueue(queue,best,costFunction,pam,null,k,multimatch,complete);
              }
            }
          }
        }
        if (i > 0) {
          for (          PartialApproxMatch<K,V> pam : matches[i - 1][j]) {
            addToQueue(queue,best,costFunction,pam,t,null,multimatch,complete);
          }
        }
        matches[i][j]=queue.toSortedList();
      }
 else {
        matches[i]=new List[target.size() + 1 + extra];
        matches[i][0]=new ArrayList<PartialApproxMatch<K,V>>();
        if (i > 0) {
          K t=(i < target.size()) ? target.get(i - 1) : null;
          for (          PartialApproxMatch<K,V> pam : matches[i - 1][0]) {
            PartialApproxMatch<K,V> npam=pam.withMatch(costFunction,costFunction.cost(t,null),t,null);
            if (npam.cost <= maxCost) {
              matches[i][0].add(npam);
            }
          }
        }
 else {
          matches[i][0].add(new PartialApproxMatch<K,V>(0,root));
        }
      }
    }
  }
  List<ApproxMatch<K,V>> res=new ArrayList<ApproxMatch<K,V>>();
  for (  ApproxMatch<K,V> m : best.toSortedList()) {
    res.add(m);
  }
  return res;
}
