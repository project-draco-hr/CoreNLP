{
  this.op=op;
  rand=(op.randomSeed != 0) ? new Random(op.randomSeed) : new Random();
  readWordVectors();
  if (op.numHid > 0) {
    this.numHid=op.numHid;
  }
 else {
    int size=0;
    for (    SimpleMatrix vector : wordVectors.values()) {
      size=vector.getNumElements();
      break;
    }
    this.numHid=size;
  }
  this.numClasses=op.numClasses;
  identity=SimpleMatrix.identity(numHid);
  binaryTransform=TwoDimensionalMap.treeMap();
  binaryClassification=TwoDimensionalMap.treeMap();
  for (  Pair<String,String> binary : binaryProductions) {
    String left=basicCategory(binary.first);
    String right=basicCategory(binary.second);
    if (binaryTransform.contains(left,right)) {
      continue;
    }
    binaryTransform.put(left,right,randomTransformMatrix());
    binaryClassification.put(left,right,randomClassificationMatrix());
  }
  numBinaryMatrices=binaryTransform.size();
  binaryTransformSize=numHid * (2 * numHid + 1);
  binaryClassificationSize=numClasses * (numHid + 1);
  unaryClassification=Generics.newTreeMap();
  for (  String unary : unaryProductions) {
    unary=basicCategory(unary);
    if (unaryClassification.containsKey(unary)) {
      continue;
    }
    unaryClassification.put(unary,randomClassificationMatrix());
  }
  numUnaryMatrices=unaryClassification.size();
  unaryClassificationSize=numClasses * (numHid + 1);
}
