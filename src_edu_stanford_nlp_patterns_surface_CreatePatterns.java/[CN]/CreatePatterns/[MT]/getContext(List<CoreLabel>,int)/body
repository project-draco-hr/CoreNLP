{
  Set<SurfacePattern> prevpatterns=new HashSet<SurfacePattern>();
  Set<SurfacePattern> nextpatterns=new HashSet<SurfacePattern>();
  Set<SurfacePattern> prevnextpatterns=new HashSet<SurfacePattern>();
  CoreLabel token=sent.get(i);
  String tag=null;
  if (usePOS4Pattern) {
    String fulltag=token.tag();
    tag=fulltag.substring(0,Math.min(fulltag.length(),2));
  }
  String nerTag=token.get(CoreAnnotations.NamedEntityTagAnnotation.class);
  for (int maxWin=1; maxWin <= maxWindow4Pattern; maxWin++) {
    List<String> previousTokens=new ArrayList<String>();
    List<String> originalPrev=new ArrayList<String>(), originalNext=new ArrayList<String>();
    List<String> nextTokens=new ArrayList<String>();
    int numStopWordsprev=0, numStopWordsnext=0;
    int numNonStopWordsNext=0, numNonStopWordsPrev=0;
    boolean useprev=false, usenext=false;
    PatternToken twithoutPOS=null;
    if (addPatWithoutPOS) {
      twithoutPOS=new PatternToken(tag,false,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction,constVars.useTargetParserParentRestriction,token.get(CoreAnnotations.GrandparentAnnotation.class));
    }
    PatternToken twithPOS=null;
    if (usePOS4Pattern) {
      twithPOS=new PatternToken(tag,true,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction,constVars.useTargetParserParentRestriction,token.get(CoreAnnotations.GrandparentAnnotation.class));
    }
    if (usePreviousContext) {
      int j=i - 1;
      int numTokens=0;
      while (numTokens < maxWin && j >= 0) {
        CoreLabel tokenj=sent.get(j);
        String tokenjStr;
        if (constVars.useLemmaContextTokens)         tokenjStr=tokenj.lemma();
 else         tokenjStr=tokenj.word();
        if (useFillerWordsInPat && constVars.fillerWords.contains(tokenj.word().toLowerCase())) {
          j--;
          continue;
        }
        Triple<Boolean,String,String> tr=this.getContextTokenStr(tokenj);
        boolean isLabeledO=tr.first;
        String strgeneric=tr.second;
        String strOriginal=tr.third;
        if (!isLabeledO) {
          previousTokens.add(0,"[" + strgeneric + "]");
          originalPrev.add(0,strOriginal);
          numNonStopWordsPrev++;
        }
 else         if (tokenj.word().startsWith("http")) {
          useprev=false;
          previousTokens.clear();
          originalPrev.clear();
          break;
        }
 else {
          String str=SurfacePattern.getContextStr(tokenj,constVars.useLemmaContextTokens,constVars.matchLowerCaseContext);
          previousTokens.add(0,str);
          originalPrev.add(0,tokenjStr);
          if (doNotUse(tokenjStr,constVars.getStopWords())) {
            numStopWordsprev++;
          }
 else           numNonStopWordsPrev++;
        }
        numTokens++;
        j--;
      }
    }
    if (useNextContext) {
      int numTokens=0;
      int j=i + 1;
      while (numTokens < maxWin && j < sent.size()) {
        CoreLabel tokenj=sent.get(j);
        String tokenjStr;
        if (constVars.useLemmaContextTokens)         tokenjStr=tokenj.lemma();
 else         tokenjStr=tokenj.word();
        if (useFillerWordsInPat && constVars.fillerWords.contains(tokenj.word().toLowerCase())) {
          j++;
          continue;
        }
        Triple<Boolean,String,String> tr=this.getContextTokenStr(tokenj);
        boolean isLabeledO=tr.first;
        String strgeneric=tr.second;
        String strOriginal=tr.third;
        if (!isLabeledO) {
          numNonStopWordsNext++;
          nextTokens.add("[" + strgeneric + "]");
          originalNext.add(strOriginal);
        }
 else         if (tokenj.word().startsWith("http")) {
          usenext=false;
          nextTokens.clear();
          originalNext.clear();
          break;
        }
 else {
          String str=SurfacePattern.getContextStr(tokenj,constVars.useLemmaContextTokens,constVars.matchLowerCaseContext);
          nextTokens.add(str);
          originalNext.add(tokenjStr);
          if (doNotUse(tokenjStr,constVars.getStopWords())) {
            numStopWordsnext++;
          }
 else           numNonStopWordsNext++;
        }
        j++;
        numTokens++;
      }
    }
    String fw="";
    if (useFillerWordsInPat)     fw=" $FILLER{0,2} ";
    String sw="";
    if (useStopWordsBeforeTerm) {
      sw=" $STOPWORD{0,2} ";
    }
    String[] prevContext=null;
    String[] prevOriginalArr=null;
    if (previousTokens.size() >= minWindow4Pattern && (numNonStopWordsPrev > 0 || numStopWordsprev > numMinStopWordsToAdd)) {
      List<String> prevContextList=new ArrayList<String>();
      List<String> prevOriginal=new ArrayList<String>();
      for (      String p : previousTokens) {
        prevContextList.add(p);
        if (!fw.isEmpty())         prevContextList.add(fw.trim());
      }
      for (      String p : originalPrev) {
        prevOriginal.add(p);
        if (!fw.isEmpty())         prevOriginal.add(" FW ");
      }
      if (!sw.isEmpty()) {
        prevContextList.add(sw.trim());
        prevOriginal.add(" SW ");
      }
      if (isASCII(StringUtils.join(prevOriginal))) {
        prevContext=prevContextList.toArray(new String[0]);
        prevOriginalArr=prevOriginal.toArray(new String[0]);
        if (previousTokens.size() >= minWindow4Pattern) {
          if (twithoutPOS != null) {
            SurfacePattern pat=new SurfacePattern(prevContext,twithoutPOS,null,prevOriginalArr,null);
            prevpatterns.add(pat);
          }
          if (twithPOS != null) {
            SurfacePattern patPOS=new SurfacePattern(prevContext,twithPOS,null,prevOriginalArr,null);
            prevpatterns.add(patPOS);
          }
        }
        useprev=true;
      }
    }
    String[] nextContext=null;
    String[] nextOriginalArr=null;
    if (nextTokens.size() > 0 && (numNonStopWordsNext > 0 || numStopWordsnext > numMinStopWordsToAdd)) {
      List<String> nextContextList=new ArrayList<String>();
      List<String> nextOriginal=new ArrayList<String>();
      if (!sw.isEmpty()) {
        nextContextList.add(sw.trim());
        nextOriginal.add(" SW ");
      }
      for (      String n : nextTokens) {
        if (!fw.isEmpty())         nextContextList.add(fw);
        nextContextList.add(n);
      }
      for (      String n : originalNext) {
        if (!fw.isEmpty())         nextOriginal.add(" FW ");
        nextOriginal.add(n);
      }
      if (nextTokens.size() >= minWindow4Pattern) {
        nextContext=nextContextList.toArray(new String[0]);
        nextOriginalArr=nextOriginal.toArray(new String[0]);
        if (twithoutPOS != null) {
          SurfacePattern pat=new SurfacePattern(null,twithoutPOS,nextContext,null,nextOriginalArr);
          nextpatterns.add(pat);
        }
        if (twithPOS != null) {
          SurfacePattern patPOS=new SurfacePattern(null,twithPOS,nextContext,null,nextOriginalArr);
          nextpatterns.add(patPOS);
        }
      }
      usenext=true;
    }
    if (useprev && usenext) {
      if (previousTokens.size() + nextTokens.size() >= minWindow4Pattern) {
        if (twithoutPOS != null) {
          SurfacePattern pat=new SurfacePattern(prevContext,twithoutPOS,nextContext,prevOriginalArr,nextOriginalArr);
          prevnextpatterns.add(pat);
        }
        if (twithPOS != null) {
          SurfacePattern patPOS=new SurfacePattern(prevContext,twithPOS,nextContext,prevOriginalArr,nextOriginalArr);
          prevnextpatterns.add(patPOS);
        }
      }
    }
  }
  Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>> patterns=new Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>(prevpatterns,nextpatterns,prevnextpatterns);
  return patterns;
}
