{
  patternsForEachToken=new HashMap<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>();
  List<String> keyset=new ArrayList<String>(sents.keySet());
  int num=0;
  if (constVars.numThreads == 1)   num=keyset.size();
 else   num=keyset.size() / (constVars.numThreads);
  ExecutorService executor=Executors.newFixedThreadPool(constVars.numThreads);
  Redwood.log(ConstantsAndVariables.extremedebug,"Computing all patterns. keyset size is " + keyset.size() + ". Assigning "+ num+ " values to each thread");
  List<Future<Map<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>>> list=new ArrayList<Future<Map<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>>>();
  for (int i=0; i < constVars.numThreads; i++) {
    int from=i * num;
    int to=-1;
    if (i == constVars.numThreads - 1)     to=keyset.size();
 else     to=Math.min(keyset.size(),(i + 1) * num);
    Callable<Map<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>> task=null;
    List<String> ids=keyset.subList(from,to);
    task=new CreatePatternsThread(sents,ids);
    Future<Map<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>> submit=executor.submit(task);
    list.add(submit);
  }
  for (  Future<Map<String,Map<Integer,Triple<Set<Integer>,Set<Integer>,Set<Integer>>>>> future : list) {
    try {
      patternsForEachToken.putAll(future.get());
    }
 catch (    Exception e) {
      executor.shutdownNow();
      throw new RuntimeException(e);
    }
  }
  executor.shutdown();
  Redwood.log(ConstantsAndVariables.extremedebug,"Done computing all patterns");
  return patternsForEachToken;
}
