{
  Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>> patternsForEachToken=new HashMap<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>();
  List<String> keyset=new ArrayList<String>(sents.keySet());
  int num=0;
  if (constVars.numThreads == 1)   num=keyset.size();
 else   num=keyset.size() / (constVars.numThreads - 1);
  ExecutorService executor=Executors.newFixedThreadPool(constVars.numThreads);
  Redwood.log(Redwood.FORCE,channelNameLogger,"keyset size is " + keyset.size());
  List<Future<Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>>> list=new ArrayList<Future<Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>>>();
  for (int i=0; i < constVars.numThreads; i++) {
    Redwood.log(Redwood.FORCE,channelNameLogger,"assigning from " + i * num + " till " + Math.min(keyset.size(),(i + 1) * num));
    Callable<Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>> task=null;
    List<String> ids=keyset.subList(i * num,Math.min(keyset.size(),(i + 1) * num));
    task=new CreatePatternsThread(label,sents,ids);
    Future<Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>> submit=executor.submit(task);
    list.add(submit);
  }
  for (  Future<Map<String,Map<Integer,Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>>>> future : list) {
    patternsForEachToken.putAll(future.get());
  }
  executor.shutdown();
  return patternsForEachToken;
}
