{
  Set<SurfacePattern> prevpatterns=new HashSet<SurfacePattern>();
  Set<SurfacePattern> nextpatterns=new HashSet<SurfacePattern>();
  Set<SurfacePattern> prevnextpatterns=new HashSet<SurfacePattern>();
  CoreLabel token=sent.get(i);
  String fulltag=token.tag();
  String tag=fulltag.substring(0,Math.min(fulltag.length(),2));
  String nerTag=token.get(CoreAnnotations.NamedEntityTagAnnotation.class);
  for (int maxWin=1; maxWin <= maxWindow4Pattern; maxWin++) {
    List<String> previousTokens=new ArrayList<String>();
    String originalPrevStr="", originalNextStr="";
    List<String> nextTokens=new ArrayList<String>();
    int numStopWordsprev=0, numStopWordsnext=0;
    int numNonStopWordsNext=0, numNonStopWordsPrev=0;
    boolean useprev=false, usenext=false;
    if (usePreviousContext) {
      int j=i - 1;
      int numTokens=0;
      while (numTokens < maxWin && j >= 0) {
        CoreLabel tokenj=sent.get(j);
        String tokenjStr;
        if (constVars.useLemmaContextTokens)         tokenjStr=tokenj.lemma();
 else         tokenjStr=tokenj.word();
        if (useFillerWordsInPat && constVars.fillerWords.contains(tokenj.word().toLowerCase())) {
          j--;
          continue;
        }
        if (!tokenj.containsKey(constVars.answerClass.get(label))) {
          throw new RuntimeException("how come the class " + constVars.answerClass.get(label) + " for token "+ tokenj.word()+ " in "+ sent+ " is not set");
        }
        Triple<Boolean,String,String> tr=this.getContextTokenStr(tokenj);
        boolean isLabeledO=tr.first;
        String strgeneric=tr.second;
        String strOriginal=tr.third;
        if (!isLabeledO) {
          previousTokens.add(0,"[" + strgeneric + "]");
          originalPrevStr=strOriginal + " " + originalPrevStr;
          numNonStopWordsPrev++;
        }
 else         if (tokenj.word().startsWith("http")) {
          useprev=false;
          previousTokens.clear();
          originalPrevStr="";
          break;
        }
 else {
          String str=SurfacePattern.getContextStr(tokenj,constVars.useLemmaContextTokens,constVars.matchLowerCaseContext);
          previousTokens.add(0,str);
          originalPrevStr=tokenjStr + " " + originalPrevStr;
          if (doNotUse(tokenjStr,constVars.getStopWords())) {
            numStopWordsprev++;
          }
 else           numNonStopWordsPrev++;
        }
        numTokens++;
        j--;
      }
    }
    if (useNextContext) {
      int numTokens=0;
      int j=i + 1;
      while (numTokens < maxWin && j < sent.size()) {
        CoreLabel tokenj=sent.get(j);
        String tokenjStr;
        if (constVars.useLemmaContextTokens)         tokenjStr=tokenj.lemma();
 else         tokenjStr=tokenj.word();
        if (useFillerWordsInPat && constVars.fillerWords.contains(tokenj.word().toLowerCase())) {
          j++;
          continue;
        }
        if (!tokenj.containsKey(constVars.answerClass.get(label))) {
          throw new RuntimeException("how come the dict annotation for token " + tokenj.word() + " in "+ sent+ " is not set");
        }
        Triple<Boolean,String,String> tr=this.getContextTokenStr(tokenj);
        boolean isLabeledO=tr.first;
        String strgeneric=tr.second;
        String strOriginal=tr.third;
        if (!isLabeledO) {
          numNonStopWordsNext++;
          nextTokens.add("[" + strgeneric + "]");
          originalNextStr+=" " + strOriginal;
        }
 else         if (tokenj.word().startsWith("http")) {
          usenext=false;
          nextTokens.clear();
          originalNextStr="";
          break;
        }
 else {
          String str=SurfacePattern.getContextStr(tokenj,constVars.useLemmaContextTokens,constVars.matchLowerCaseContext);
          nextTokens.add(str);
          originalNextStr+=" " + tokenjStr;
          if (doNotUse(tokenjStr,constVars.getStopWords())) {
            numStopWordsnext++;
          }
 else           numNonStopWordsNext++;
        }
        j++;
        numTokens++;
      }
    }
    String fw=" ";
    if (useFillerWordsInPat)     fw=" $FILLER{0,2} ";
    String sw="";
    if (useStopWordsBeforeTerm) {
      sw=" $STOPWORD{0,2} ";
    }
    String[] prevContext=null;
    if (previousTokens.size() >= minWindow4Pattern && (numNonStopWordsPrev > 0 || numStopWordsprev > numMinStopWordsToAdd)) {
      List<String> prevContextList=new ArrayList<String>();
      for (      String p : previousTokens) {
        prevContextList.add(p);
        if (!fw.trim().isEmpty())         prevContextList.add(fw.trim());
      }
      prevContextList.add(sw.trim());
      PatternToken twithoutPOS=null;
      if (addPatWithoutPOS) {
        twithoutPOS=new PatternToken(tag,false,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      PatternToken twithPOS=null;
      if (usePOS4Pattern) {
        twithPOS=new PatternToken(tag,true,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      if (isASCII(originalPrevStr)) {
        prevContext=prevContextList.toArray(new String[0]);
        if (previousTokens.size() >= minWindow4Pattern) {
          if (twithoutPOS != null) {
            SurfacePattern pat=new SurfacePattern(prevContext,twithoutPOS,null,originalPrevStr,"");
            prevpatterns.add(pat);
          }
          if (twithPOS != null) {
            SurfacePattern patPOS=new SurfacePattern(prevContext,twithPOS,null,originalPrevStr,"");
            prevpatterns.add(patPOS);
          }
        }
        useprev=true;
      }
    }
    String[] nextContext=null;
    if (nextTokens.size() > 0 && (numNonStopWordsNext > 0 || numStopWordsnext > numMinStopWordsToAdd)) {
      List<String> nextContextList=new ArrayList<String>();
      if (!sw.isEmpty()) {
        nextContextList.add(sw.trim());
      }
      for (      String n : nextTokens) {
        if (!fw.trim().isEmpty())         nextContextList.add(fw.trim());
        nextContextList.add(n);
      }
      PatternToken twithoutPOS=null;
      if (addPatWithoutPOS) {
        twithoutPOS=new PatternToken(tag,false,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      PatternToken twithPOS=null;
      if (usePOS4Pattern) {
        twithPOS=new PatternToken(tag,true,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      if (nextTokens.size() >= minWindow4Pattern) {
        nextContext=nextContextList.toArray(new String[0]);
        if (twithoutPOS != null) {
          SurfacePattern pat=new SurfacePattern(null,twithoutPOS,nextContext,"",originalNextStr);
          nextpatterns.add(pat);
        }
        if (twithPOS != null) {
          SurfacePattern patPOS=new SurfacePattern(null,twithPOS,nextContext,"",originalNextStr);
          nextpatterns.add(patPOS);
        }
      }
      usenext=true;
    }
    if (useprev && usenext) {
      PatternToken twithoutPOS=null;
      if (addPatWithoutPOS) {
        twithoutPOS=new PatternToken(tag,false,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      PatternToken twithPOS=null;
      if (usePOS4Pattern) {
        twithPOS=new PatternToken(tag,true,constVars.numWordsCompound > 1,constVars.numWordsCompound,nerTag,constVars.useTargetNERRestriction);
      }
      if (previousTokens.size() + nextTokens.size() >= minWindow4Pattern) {
        if (twithoutPOS != null) {
          SurfacePattern pat=new SurfacePattern(prevContext,twithoutPOS,nextContext,originalPrevStr,originalNextStr);
          prevnextpatterns.add(pat);
        }
        if (twithPOS != null) {
          SurfacePattern patPOS=new SurfacePattern(prevContext,twithPOS,nextContext,originalPrevStr,originalNextStr);
          prevnextpatterns.add(patPOS);
        }
      }
    }
  }
  Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>> patterns=new Triple<Set<SurfacePattern>,Set<SurfacePattern>,Set<SurfacePattern>>(prevpatterns,nextpatterns,prevnextpatterns);
  return patterns;
}
