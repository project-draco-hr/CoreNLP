{
  Map<String,Map<Integer,Set<E>>> tempPatternsForTokens=new HashMap<String,Map<Integer,Set<E>>>();
  int numSentencesInOneCommit=0;
  for (  String id : sentIds) {
    DataInstance sent=sents.get(id);
    List<CoreLabel> tokens=sent.getTokens();
    if (!constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.MEMORY))     tempPatternsForTokens.put(id,new HashMap<Integer,Set<E>>());
    Map<Integer,Set<E>> p=new HashMap<Integer,Set<E>>();
    for (int i=0; i < tokens.size(); i++) {
      p.put(i,new HashSet<E>());
      CoreLabel token=tokens.get(i);
      if (PatternFactory.doNotUse(token.word(),constVars.getStopWords())) {
        continue;
      }
      Set<E> pat=Pattern.getContext(constVars.patternType,sent,i);
      p.put(i,pat);
    }
    if (!constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.MEMORY)) {
      tempPatternsForTokens.put(id,p);
      numSentencesInOneCommit++;
      if (numSentencesInOneCommit % 1000 == 0) {
        patsForEach.addPatterns(tempPatternsForTokens);
        tempPatternsForTokens.clear();
        numSentencesInOneCommit=0;
      }
    }
 else     patsForEach.addPatterns(id,p);
  }
  if (!constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.MEMORY))   patsForEach.addPatterns(tempPatternsForTokens);
  return null;
}
