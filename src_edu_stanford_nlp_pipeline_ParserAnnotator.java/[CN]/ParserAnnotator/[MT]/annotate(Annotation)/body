{
  if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {
    for (    CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
      final List<CoreLabel> words=sentence.get(CoreAnnotations.TokensAnnotation.class);
      if (VERBOSE) {
        System.err.println("Parsing: " + words);
      }
      Tree tree=null;
      if (maxSentenceLength <= 0 || words.size() < maxSentenceLength) {
        final List<ParserConstraint> constraints=sentence.get(ConstraintAnnotation.class);
        if (maxParseTime > 0) {
          final Tree[] treeMem={null};
          Thread thread=new Thread(new Runnable(){
            public void run(){
              treeMem[0]=process(constraints,words);
            }
          }
);
          try {
            thread.start();
            thread.join(maxParseTime);
            tree=treeMem[0];
            if (thread.isAlive()) {
              thread.stop();
              if (VERBOSE) {
                System.err.println("WARNING: " + "The parser took too long to parse: " + Sentence.listToString(words));
              }
            }
          }
 catch (          InterruptedException e) {
            if (VERBOSE) {
              System.err.println("WARNING: Parsing of sentence failed: " + Sentence.listToString(words));
              e.printStackTrace();
            }
          }
        }
 else {
          tree=process(constraints,words);
        }
      }
      if (tree == null) {
        tree=ParserAnnotatorUtils.xTree(words);
      }
      if (treeMap != null) {
        tree=treeMap.apply(tree);
      }
      ParserAnnotatorUtils.fillInParseAnnotations(VERBOSE,BUILD_GRAPHS,gsf,sentence,tree);
    }
  }
 else {
    throw new RuntimeException("unable to find sentences in: " + annotation);
  }
}
