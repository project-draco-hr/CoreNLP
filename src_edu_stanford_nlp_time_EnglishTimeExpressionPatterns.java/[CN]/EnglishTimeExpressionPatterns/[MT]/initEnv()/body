{
  env=TokenSequencePattern.getNewEnv();
  env.setDefaultResultsAnnotationExtractor(TimeExpression.TimeExpressionConverter);
  env.setDefaultTokensAnnotationKey(CoreAnnotations.NumerizedTokensAnnotation.class);
  env.setDefaultResultAnnotationKey(TimeExpression.Annotation.class);
  env.setDefaultNestedResultsAnnotationKey(TimeExpression.ChildrenAnnotation.class);
  env.bind("time",new TimeFormatter.TimePatternExtractRuleCreator());
  env.setDefaultStringPatternFlags(Pattern.CASE_INSENSITIVE);
  env.bind("numcomptype",CoreAnnotations.NumericCompositeTypeAnnotation.class);
  env.bind("numcompvalue",CoreAnnotations.NumericCompositeValueAnnotation.class);
  env.bind("temporal",TimeExpression.Annotation.class);
  env.bind("::IS_TIMEX_DATE",new TimexTypeMatchNodePattern(SUTime.TimexType.DATE));
  env.bind("::IS_TIMEX_DURATION",new TimexTypeMatchNodePattern(SUTime.TimexType.DURATION));
  env.bind("::IS_TIMEX_TIME",new TimexTypeMatchNodePattern(SUTime.TimexType.TIME));
  env.bind("::IS_TIMEX_SET",new TimexTypeMatchNodePattern(SUTime.TimexType.SET));
  env.bind("$RELDAY","/today|yesterday|tomorrow|tonight|tonite/");
  env.bind("$SEASON","/spring|summer|fall|autumn|winter/");
  env.bind("$TIMEOFDAY","/morning|afternoon|evening|night|noon|midnight|teatime|lunchtime|dinnertime|suppertime|afternoon|midday|dusk|dawn|sunup|sunrise|sundown|twilight|daybreak/");
  env.bind("$TEDAY","/" + teDay.pattern() + "|"+ teDayAbbr.pattern()+ "/");
  env.bind("$TEDAYS","/" + teDay.pattern() + "s?|"+ teDayAbbr.pattern()+ "/");
  env.bind("$TEMONTH","/" + teMonth.pattern() + "|"+ teMonthAbbr.pattern()+ "/");
  env.bind("$TEMONTHS","/" + teMonth.pattern() + "s?|"+ teMonthAbbr.pattern()+ "\\.?s?/");
  env.bind("$TEUNITS","/" + teUnit.pattern() + "s?/");
  env.bind("$TEUNIT","/" + teUnit.pattern() + "/");
  env.bind("$NUM",TokenSequencePattern.compile(env,"[ { numcomptype:NUMBER } ]"));
  env.bind("$INT",TokenSequencePattern.compile(env," [ { numcomptype:NUMBER } & !{ word:/.*\\.\\d+.*/} & !{ word:/.*,.*/ } ] "));
  env.bind("$INT1000TO3000",TokenSequencePattern.compile(env,"[ $INT & !{ word:/\\+.*/} & { numcompvalue>1000 } & { numcompvalue<3000 } ] "));
  env.bind("$INT1TO31",TokenSequencePattern.compile(env,"[ $INT & !{ word:/\\+.*/} & { numcompvalue>=1 } & { numcompvalue<=31 } ] "));
  env.bind("$NUM_ORD",TokenSequencePattern.compile(env,"[ { numcomptype:ORDINAL } ]"));
  env.bind("$INT_TIMES",TokenSequencePattern.compile(env," $INT /times/ | once | twice | thrice "));
  env.bind("$REL_MOD",TokenSequencePattern.compile(env,"/the/? /next|following|last|previous/ | /this/ /coming|past/? | /the/ /coming|past/"));
  env.bind("$FREQ_MOD",TokenSequencePattern.compile(env,"/each/ | /every/ $NUM_ORD | /every/ /other|alternate|alternating/? | /alternate|alternating/ "));
  env.bind("$EARLY_LATE_MOD",TokenSequencePattern.compile(env,"/late|early|mid-?/ | /the/? /beginning|start|dawn|middle|end/ /of/"));
  env.bind("$APPROX_MOD",TokenSequencePattern.compile(env,"/about|around|some|exactly|precisely/"));
  env.bind("$YEAR","/[012]\\d\\d\\d|'\\d\\d/ | /\\w+teen/ [ { numcompvalue<=100 } & { numcompvalue>0 } & $INT ] ");
  env.bind("$POSSIBLE_YEAR"," $YEAR | $INT /a\\.?d\\.?|b\\.?c\\.?/ | $INT1000TO3000 ");
  env.bind("$TEUNITS_NODE",TokenSequencePattern.compile(env,"[ " + "/" + teUnit.pattern() + "s?/"+ " & { tag:/NN.*/ } ]"));
  env.bindStringRegex("$NUM_TERM",numTerm.pattern());
  env.bindStringRegex("$NUM_ORD_TERM",numOrdTerm.pattern());
  env.bindStringRegex("$NUM_NO_ORD_TERM",numNoOrdTerm.pattern());
  env.bindStringRegex("$TEmonth",teMonth.pattern());
  env.bindStringRegex("$TEmonthabbr",teMonthAbbr.pattern());
  env.bindStringRegex("$TEUnits",teUnit.pattern());
  env.bindStringRegex("$OT","\\\\b");
  env.bindStringRegex("$CT","\\\\b");
  env.bindStringRegex("$TEOrdinalWords",teOrdinalWords.pattern());
  env.bindStringRegex("$TENumOrds",teNumOrds.pattern());
}
