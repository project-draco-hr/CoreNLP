{
  State[] states=hmm.getStates();
  int stateSize=states.length;
  ClassicCounter vocab=new ClassicCounter(data.getVocab());
  int vocabSize=vocab.size();
  double[] transitionPriorParas=new double[stateSize];
  double[] transitionCount=new double[stateSize];
  double[] emissionCount=new double[vocabSize];
  double logPrior=0.0;
  for (int i=0; i < stateSize; i++) {
    transitionPriorParas[i]=1.0;
  }
  for (int i=0; i < stateSize; i++) {
    State s=states[i];
    double numVisits;
    double numTransitions=0.0;
    double numEmissions=0.0;
    double statePrior=0.0;
    double betaTran=1.0, betaEmit=1.0;
    double accumTran=stateSize * 1.0;
    double accumEmit=emissionPriorSum;
    if (s.type < 0) {
      numVisits=data.size();
    }
 else {
      numVisits=((CountedEmitMap)s.emit).getCount();
    }
    for (int j=0; j < stateSize; j++) {
      if (s.transition[j] == 0.0) {
        transitionCount[j]=transitionPriorParas[j];
      }
 else {
        transitionCount[j]=transitionPriorParas[j] + numVisits * s.transition[j];
        numTransitions+=1.0;
        for (int k=1; k <= (int)(numVisits * s.transition[j]); k++) {
          betaTran*=(transitionPriorParas[j] + k - 1) / (++accumTran - 1);
        }
      }
    }
    if (s.type < 0) {
      for (int j=0; j < vocabSize; j++) {
        emissionCount[j]=emissionPriorParas[j];
      }
    }
 else {
      ClassicCounter globalVocab=new ClassicCounter(data.getVocab());
      ClassicCounter localVocab=((CountedEmitMap)s.emit).getVocab();
      Iterator iter=globalVocab.keySet().iterator();
      int pos=0;
      while (iter.hasNext()) {
        Object key=iter.next();
        double count=localVocab.getCount(key);
        if (count != 0.0) {
          emissionCount[pos]=emissionPriorParas[pos] + count;
          numEmissions+=1.0;
          for (int k=1; k <= (int)count; k++) {
            betaEmit*=(emissionPriorParas[pos] + k - 1) / (++accumEmit - 1);
          }
        }
 else {
          emissionCount[pos]=emissionPriorParas[pos];
        }
        pos++;
      }
    }
    statePrior+=(-1.0) * numTransitions * Math.log(stateSize + 1.0);
    statePrior+=(-1.0) * numEmissions * Math.log(vocabSize + 1.0);
    if (betaTran > 1.2E-321) {
      statePrior+=Math.log(betaTran);
    }
    if (betaEmit > 1.2E-321) {
      statePrior+=Math.log(betaEmit);
    }
    logPrior+=statePrior;
  }
  return logPrior;
}
