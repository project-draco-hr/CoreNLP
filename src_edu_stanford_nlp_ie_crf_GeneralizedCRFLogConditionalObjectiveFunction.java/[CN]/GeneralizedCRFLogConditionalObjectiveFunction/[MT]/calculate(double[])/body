{
  double prob=0;
  double[][] weights=to2D(x);
  double[][] E=empty2D();
  for (int m=0; m < data.length; m++) {
    int[][][] docData=data[m];
    int[] docLabels=labels[m];
    CliquePotentialFunction cliquePotentialFunc=new LinearCliquePotentialFunction(weights);
    CRFCliqueTree cliqueTree=CRFCliqueTree.getCalibratedCliqueTree(docData,labelIndices,numClasses,classIndex,backgroundSymbol,cliquePotentialFunc,null);
    int[] given=new int[window - 1];
    Arrays.fill(given,classIndex.indexOf(backgroundSymbol));
    if (docLabels.length > docData.length) {
      System.arraycopy(docLabels,0,given,0,given.length);
      int[] newDocLabels=new int[docData.length];
      System.arraycopy(docLabels,docLabels.length - newDocLabels.length,newDocLabels,0,newDocLabels.length);
      docLabels=newDocLabels;
    }
    for (int i=0; i < docData.length; i++) {
      int label=docLabels[i];
      double p=cliqueTree.condLogProbGivenPrevious(i,label,given);
      if (VERBOSE) {
        System.err.println("P(" + label + "|"+ ArrayMath.toString(given)+ ")="+ p);
      }
      prob+=p;
      System.arraycopy(given,1,given,0,given.length - 1);
      given[given.length - 1]=label;
    }
    for (int i=0; i < data[m].length; i++) {
      for (int j=0; j < data[m][i].length; j++) {
        Index labelIndex=labelIndices.get(j);
        for (int k=0; k < labelIndex.size(); k++) {
          int[] label=((CRFLabel)labelIndex.get(k)).getLabel();
          double p=cliqueTree.prob(i,label);
          for (int n=0; n < data[m][i][j].length; n++) {
            E[data[m][i][j][n]][k]+=p;
          }
        }
      }
    }
  }
  if (Double.isNaN(prob)) {
    throw new RuntimeException("Got NaN for prob in GeneralizedCRFLogConditionalObjectiveFunction.calculate()");
  }
  value=-prob;
  int index=0;
  for (int i=0; i < E.length; i++) {
    for (int j=0; j < E[i].length; j++) {
      derivative[index++]=(E[i][j] - Ehat[i][j]);
      if (VERBOSE) {
        System.err.println("deriv(" + i + ","+ j+ ") = "+ E[i][j]+ " - "+ Ehat[i][j]+ " = "+ derivative[index - 1]);
      }
    }
  }
  if (prior == QUADRATIC_PRIOR) {
    for (int i=0; i < x.length; i++) {
      double k=1.0;
      double w=x[i] - mean[i];
      value+=k * w * w / 2.0 / sigmaPower[i];
      derivative[i]+=k * w / sigmaPower[i];
    }
  }
 else   if (prior == HUBER_PRIOR) {
    double sigmaSq=sigma[0] * sigma[0];
    for (int i=0; i < x.length; i++) {
      double w=x[i];
      double wabs=Math.abs(w);
      if (wabs < epsilon) {
        value+=w * w / 2.0 / epsilon / sigmaSq;
        derivative[i]+=w / epsilon / sigmaSq;
      }
 else {
        value+=(wabs - epsilon / 2) / sigmaSq;
        derivative[i]+=((w < 0.0) ? -1.0 : 1.0) / sigmaSq;
      }
    }
  }
 else   if (prior == QUARTIC_PRIOR) {
    double sigmaQu=sigma[0] * sigma[0] * sigma[0]* sigma[0];
    for (int i=0; i < x.length; i++) {
      double k=1.0;
      double w=x[i];
      value+=k * w * w* w* w / 2.0 / sigmaQu;
      derivative[i]+=k * w / sigmaQu;
    }
  }
}
