{
  double sampleProb=0.0;
  String goalStr=stateIndex.get(goal);
  if (end - start <= op.testOptions.maxSpanForTags && tagIndex.contains(goalStr)) {
    if (op.testOptions.maxSpanForTags > 1) {
      Tree wordNode=null;
      if (sentence != null) {
        StringBuilder word=new StringBuilder();
        for (int i=start; i < end; i++) {
          if (sentence.get(i) instanceof StringLabel) {
            word.append(((StringLabel)sentence.get(i)).value());
          }
 else {
            word.append((String)sentence.get(i));
          }
        }
        wordNode=tf.newLeaf(new StringLabel(word.toString()));
      }
 else {
        throw new RuntimeException("attempt to get word when sentence is null!");
      }
      Tree tagNode=tf.newTreeNode(new StringLabel(goalStr),Collections.singletonList(wordNode));
      return tagNode;
    }
 else {
      IntTaggedWord tagging=new IntTaggedWord(words[start],tagIndex.indexOf(goalStr));
      float tagScore=lex.score(tagging,start,wordIndex.get(words[start]),null);
      sampleProb+=tagScore;
      if (tagScore > Float.NEGATIVE_INFINITY || floodTags) {
        String wordStr=wordIndex.get(words[start]);
        Tree wordNode=tf.newLeaf(new StringLabel(wordStr));
        List<Tree> childList=new ArrayList<Tree>();
        childList.add(wordNode);
        Tree tagNode=tf.newTreeNode(new StringLabel(goalStr),childList);
        return tagNode;
      }
    }
  }
  double totalProb=0.0;
  List<UnaryRule> unaryRules=ug.rulesByParent(goal);
  List<BinaryRule> binaryRules=bg.ruleListByParent(goal);
  List<Double> probs=new ArrayList<Double>();
  for (  UnaryRule ur : unaryRules) {
    double logProb=ur.score() + iScore[start][end][ur.child];
    probs.add(Math.exp(logProb));
  }
  for (  BinaryRule br : binaryRules) {
    for (int split=start + 1; split < end; split++) {
      double logProb=br.score() + iScore[start][split][br.leftChild] + iScore[split][end][br.rightChild];
      probs.add(Math.exp(logProb));
    }
  }
  double[] dist=new double[probs.size()];
  int i=0;
  for (  Double d : probs) {
    dist[i++]=d;
  }
  try {
    ArrayMath.normalize(dist);
  }
 catch (  Exception e) {
    for (    double d : dist) {
      System.err.print(d + " ");
    }
    throw new RuntimeException(e);
  }
  int sample=-1;
  try {
    sample=ArrayMath.sampleFromDistribution(dist);
  }
 catch (  Exception e) {
    System.err.println(goalStr);
    for (    double d : probs) {
      System.err.print(d + " ");
    }
    throw new RuntimeException(e);
  }
  if (sample < unaryRules.size()) {
    UnaryRule ur=unaryRules.get(sample);
    sampleProb+=ur.score();
    Tree childTree=getSampleParse(ur.child,start,end);
    List<Tree> children=new ArrayList<Tree>();
    children.add(childTree);
    Tree result=tf.newTreeNode(new StringLabel(goalStr),children);
    return result;
  }
 else {
    sample-=unaryRules.size();
    int rule=sample / (end - start - 1);
    BinaryRule br=binaryRules.get(rule);
    sampleProb+=br.score();
    int split=(sample % (end - start - 1)) + (start + 1);
    Tree leftChildTree=getSampleParse(br.leftChild,start,split);
    Tree rightChildTree=getSampleParse(br.rightChild,split,end);
    List<Tree> children=new ArrayList<Tree>();
    children.add(leftChildTree);
    children.add(rightChildTree);
    Tree result=tf.newTreeNode(new StringLabel(goalStr),children);
    return result;
  }
}
