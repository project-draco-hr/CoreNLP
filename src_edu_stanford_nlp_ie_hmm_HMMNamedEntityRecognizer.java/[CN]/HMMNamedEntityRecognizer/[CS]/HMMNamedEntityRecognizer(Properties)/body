{
  String[] targetFields=props.getProperty("targetFields").split(" ");
  Corpus<L,Word> trainDocs=new Corpus<L,Word>(targetFields);
  List<File> sources=new ArrayList<File>();
  sources.add(new File(props.getProperty("trainFile")));
  IteratorFromReaderFactory iter=CoNLL03DocumentIterator.factory(targetFields);
  trainDocs.load(sources,(IteratorFromReaderFactory<Datum<L,Word>>)iter);
  Properties pnpcProperties=CharSequenceEmitMap.getPnpClassifierProperties(Integer.parseInt(props.getProperty("maxNGramLength","-1")));
  int nlength=Integer.parseInt(pnpcProperties.getProperty("cn"));
  ignoreContext=Boolean.parseBoolean(props.getProperty("ignoreContext","false"));
  System.err.println("ignoreContext: " + ignoreContext);
  Map<String,List<String>> listedExamplesByTargetField=new HashMap<String,List<String>>();
  String targetListFilename=props.getProperty("targetListFile");
  if (targetListFilename != null) {
    try {
      for (      String line : ObjectBank.getLineIterator(new File(targetListFilename))) {
        String[] fieldAndExample=line.split(" ",2);
        String field=fieldAndExample[0];
        String example=fieldAndExample[1];
        List<String> listedExamples=listedExamplesByTargetField.get(field);
        if (listedExamples == null) {
          listedExamples=new ArrayList<String>();
        }
        listedExamples.add(example);
        listedExamplesByTargetField.put(field,listedExamples);
      }
      System.err.println("Listed example counts:");
      for (      String targetField : listedExamplesByTargetField.keySet()) {
        List<String> listedExamples=listedExamplesByTargetField.get(targetField);
        System.err.println(targetField + ": " + listedExamples.size());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  int[][] typeTransitionCounts=new int[targetFields.length + 3][targetFields.length + 3];
  for (int i=0; i < typeTransitionCounts.length; i++) {
    Arrays.fill(typeTransitionCounts[i],0);
  }
  boolean adjacentFields=false;
  for (int i=0; i < trainDocs.size(); i++) {
    int lastType=targetFields.length + 1;
    TypedTaggedDocument<L> ttd=(TypedTaggedDocument<L>)trainDocs.get(i);
    int[] typeSequence=ttd.getTypeSequence();
    for (int j=0; j < typeSequence.length; j++) {
      if (ttd.get(j).word().equals(ADJACENT)) {
        adjacentFields=true;
        continue;
      }
      int curType=typeSequence[j];
      if (adjacentFields || curType != lastType) {
        typeTransitionCounts[lastType][curType]++;
      }
      lastType=curType;
      adjacentFields=false;
    }
    typeTransitionCounts[lastType][targetFields.length + 2]++;
  }
  String[] targetFieldsPlusBG=trainDocs.getTargetFields();
  PnpClassifier[] pnpcs=new PnpClassifier[targetFieldsPlusBG.length];
  for (int i=0; i < targetFieldsPlusBG.length; i++) {
    System.err.println("Working on target: " + targetFieldsPlusBG[i]);
    pnpcs[i]=new PnpClassifier(pnpcProperties);
    Corpus<L,Word> targetDocs=new Corpus<L,Word>(trainDocs);
    for (int j=0; j < targetDocs.size(); j++) {
      Document<L,Word,Word> doc=(Document<L,Word,Word>)targetDocs.get(j);
      String[] targetInstances=getTargetInstances(doc,i,ignoreContext ? 0 : nlength - 1,pnpcs[i].startSymbol);
      for (int k=0; k < targetInstances.length; k++) {
        pnpcs[i].addCounts(targetInstances[k],ignoreContext);
      }
    }
    List<String> listedExamples=listedExamplesByTargetField.get(targetFieldsPlusBG[i]);
    if (listedExamples != null) {
      for (int j=0; j < listedExamples.size(); j++) {
        pnpcs[i].addCounts(listedExamples.get(j),true);
      }
    }
    System.err.println(" - tuning parameters");
    pnpcs[i].tuneParameters();
  }
  int numTargetStates=nlength + 1;
  int numStates=2 + targetFieldsPlusBG.length * numTargetStates;
  double[][] transitions=new double[numStates][numStates];
  for (int i=0; i < transitions.length; i++) {
    Arrays.fill(transitions[i],0.0);
  }
  int[] stateTypes=new int[numStates];
  stateTypes[0]=State.FINISHTYPE;
  stateTypes[1]=State.STARTTYPE;
  for (int i=0; i < targetFieldsPlusBG.length; i++) {
    for (int j=0; j < numTargetStates; j++) {
      stateTypes[2 + i * numTargetStates + j]=i;
    }
  }
  transitions[State.FINISHIDX][State.FINISHIDX]=1.0;
  for (int i=0; i < targetFieldsPlusBG.length; i++) {
    int firstState=2 + i * numTargetStates;
    int lastState=2 + (i + 1) * numTargetStates - 1;
    for (int j=0; j < numTargetStates - 1; j++) {
      int stateIndex=2 + i * numTargetStates + j;
      transitions[stateIndex][stateIndex + 1]=0.5;
      transitions[stateIndex][lastState]=0.5;
      if (stateIndex == lastState - 1) {
        transitions[stateIndex][stateIndex]=0.5;
      }
    }
    for (int j=0; j < targetFieldsPlusBG.length; j++) {
      int otherFirstState=2 + j * numTargetStates;
      transitions[lastState][otherFirstState]=typeTransitionCounts[i][j];
    }
    transitions[State.STARTIDX][firstState]=typeTransitionCounts[targetFieldsPlusBG.length][i];
    transitions[lastState][State.FINISHIDX]=typeTransitionCounts[i][targetFieldsPlusBG.length + 1];
  }
  Structure structure=new Structure(transitions,stateTypes);
  State[] states=structure.getStates();
  for (int i=0; i < targetFieldsPlusBG.length; i++) {
    for (int j=0; j < numTargetStates; j++) {
      int charPosition=j == nlength ? -1 : j;
      states[2 + i * numTargetStates + j].emit=new CharSequenceEmitMap(pnpcs[i],charPosition,ignoreContext);
    }
  }
  for (int i=0; i < targetFieldsPlusBG.length; i++) {
    int lastState=2 + (i + 1) * numTargetStates - 1;
    for (int j=0; j < numTargetStates - 1; j++) {
      int stateIndex=2 + i * numTargetStates + j;
      states[stateIndex].transition[stateIndex + 1]=1.0;
      states[stateIndex].transition[lastState]=1.0;
      if (stateIndex == lastState - 1) {
        states[stateIndex].transition[stateIndex]=1.0;
      }
    }
  }
  HMM hmm=new HMM(states,HMM.REGULAR_HMM);
  hmm.setTargetFields(targetFieldsPlusBG);
  hmm.printProbs();
  String answerFilename=props.getProperty("answerFile");
  BufferedReader br=null;
  if (answerFilename != null) {
    try {
      br=new BufferedReader(new FileReader(answerFilename));
    }
 catch (    FileNotFoundException e) {
      throw (e);
    }
  }
  Corpus<L,TypedTaggedWord> testDocs=new Corpus<L,TypedTaggedWord>(targetFields);
  sources=new ArrayList<File>();
  sources.add(new File(props.getProperty("testFile")));
  IteratorFromReaderFactory iter1=CoNLL03DocumentIterator.factory(targetFields);
  testDocs.load(sources,(IteratorFromReaderFactory<Datum<L,TypedTaggedWord>>)iter1);
  System.err.println("Testing on " + testDocs.size() + " docs...");
  if (answerFilename != null) {
    System.err.println("Writing NER-style output...");
  }
  Corpus<L,Word> testNGrams=new Corpus<L,Word>(targetFields);
  for (int i=0; i < testDocs.size(); i++) {
    Document<L,TypedTaggedWord,TypedTaggedWord> doc=(Document<L,TypedTaggedWord,TypedTaggedWord>)testDocs.get(i);
    Document<L,Word,Word> ngrams=new TypedTaggedDocument<L>(targetFields);
    StringBuffer textSoFar=new StringBuffer();
    for (int j=0; j < nlength - 1; j++) {
      textSoFar.append(pnpcs[0].startSymbol);
    }
    for (int j=0; j < doc.size(); j++) {
      TypedTaggedWord ttw=doc.get(j);
      String word=ttw.word();
      if (word.equals(ADJACENT)) {
        continue;
      }
      word+=' ';
      int type=ttw.type();
      for (int k=0; k < word.length(); k++) {
        textSoFar.append(word.charAt(k));
        String ngram=textSoFar.substring(textSoFar.length() - nlength);
        ngrams.add(new TypedTaggedWord(ngram,type));
      }
    }
    testNGrams.add(ngrams);
    if (answerFilename != null) {
      String line;
      while ((line=br.readLine()).length() == 0) {
        System.out.println();
      }
      System.out.println(line + " O");
      int[] stateSequence=hmm.viterbiSequence(ngrams);
      int[] typeSequence=hmm.getLabelsForSequence(stateSequence);
      int[] wordLengths=getWordLengths(doc);
      int typeSequenceIndex=0;
      int highestStateLastWord=0;
      int typeLastWord=0;
      for (int j=0; j < doc.size(); j++) {
        while ((line=br.readLine()).length() == 0) {
          System.out.println();
        }
        System.out.print(line);
        int state=stateSequence[typeSequenceIndex + 1];
        int type=typeSequence[typeSequenceIndex];
        boolean startedTarget=(type == typeLastWord && state < highestStateLastWord);
        typeLastWord=type;
        System.out.print(' ');
        if (type == 0) {
          System.out.println("O");
        }
 else {
          System.out.println((startedTarget ? 'B' : 'I') + "-" + targetFieldsPlusBG[type]);
        }
        for (int k=0; k < wordLengths[j] + 1; k++) {
          state=stateSequence[typeSequenceIndex + 1];
          highestStateLastWord=state;
          typeSequenceIndex++;
        }
      }
    }
  }
  if (answerFilename == null) {
    new HMMTester(hmm).test(testNGrams,props,false,false,true);
  }
}
