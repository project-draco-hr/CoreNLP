{
  int numEqConstraints=eqConstraints.length;
  int numIneqConstraints=ineqConstraints.length;
  if (!(function instanceof DiffFunction)) {
    throw new UnsupportedOperationException();
  }
  for (int i=0; i < numEqConstraints; i++) {
    if (!(eqConstraints[i] instanceof DiffFunction)) {
      throw new UnsupportedOperationException();
    }
  }
  for (int i=0; i < numIneqConstraints; i++) {
    if (!(ineqConstraints[i] instanceof DiffFunction)) {
      throw new UnsupportedOperationException();
    }
  }
  double[] eqLagrange=new double[numEqConstraints];
  double[] eqPenalties=new double[numEqConstraints];
  for (int i=0; i < numEqConstraints; i++) {
    eqLagrange[i]=0;
    eqPenalties[i]=1.0;
  }
  double[] ineqLagrange=new double[numIneqConstraints];
  double[] ineqPenalties=new double[numIneqConstraints];
  for (int i=0; i < numIneqConstraints; i++) {
    ineqLagrange[i]=0;
    ineqPenalties[i]=1.0;
  }
  double worstEqViolation=1.0 + 2.0 * eqConstraintTolerance;
  double worstIneqViolation=1.0 + 2.0 * ineqConstraintTolerance;
  double lastWorstEqViolation=10 * worstEqViolation;
  double lastWorstIneqViolation=10 * worstIneqViolation;
  int iter=0;
  double[] x=copyArray(initial);
  boolean lowTolIter=false;
  while (iter < 100 && (worstEqViolation > eqConstraintTolerance || worstIneqViolation > ineqConstraintTolerance || !lowTolIter)) {
    if (worstEqViolation <= eqConstraintTolerance && worstIneqViolation <= ineqConstraintTolerance) {
      lowTolIter=true;
    }
 else {
      lowTolIter=false;
    }
    DiffFunction penalizedFunction=new PenalizedFunction(function,eqConstraints,eqLagrange,eqPenalties,ineqConstraints,ineqLagrange,ineqPenalties);
    double thisTol=(lowTolIter ? functionTolerance : Math.sqrt(functionTolerance));
    x=minimizer.minimize(penalizedFunction,thisTol,x);
    penalizedFunction.derivativeAt(x);
    lastWorstEqViolation=worstEqViolation;
    worstEqViolation=Double.NEGATIVE_INFINITY;
    double[] eqViolations=new double[numEqConstraints];
    double[] eqValues=new double[numEqConstraints];
    for (int i=0; i < numEqConstraints; i++) {
      eqValues[i]=eqConstraints[i].valueAt(x);
      eqViolations[i]=fabs(eqValues[i]);
    }
    worstEqViolation=arrayMax(eqViolations);
    for (int i=0; i < numEqConstraints; i++) {
      eqLagrange[i]+=eqPenalties[i] * eqValues[i];
      if (eqViolations[i] >= worstEqViolation / 2.0 && worstEqViolation >= eqConstraintTolerance) {
        eqPenalties[i]*=1.0;
      }
 else {
        eqPenalties[i]*=1.0;
      }
      if (worstEqViolation / (lastWorstEqViolation + 1e-100) > 0.25 && worstEqViolation >= eqConstraintTolerance) {
        eqPenalties[i]*=5.0;
      }
    }
    if (!silent) {
      System.err.println("!e " + arrayMax(eqPenalties) + "/"+ worstEqViolation+ "!");
    }
    lastWorstIneqViolation=worstIneqViolation;
    worstIneqViolation=Double.NEGATIVE_INFINITY;
    double[] ineqViolations=new double[numIneqConstraints];
    double[] ineqValues=new double[numIneqConstraints];
    for (int i=0; i < numIneqConstraints; i++) {
      double cVal=ineqConstraints[i].valueAt(x);
      ineqValues[i]=cVal;
      ineqViolations[i]=((cVal < 0 ? -1.0 * cVal : 0) + fabs(ineqLagrange[i] * cVal));
    }
    worstIneqViolation=fmax(0.0,arrayMax(ineqViolations));
    for (int i=0; i < numIneqConstraints; i++) {
      double crit=ineqValues[i] + ineqLagrange[i] / ineqPenalties[i];
      if (crit > 0) {
        ineqLagrange[i]+=ineqPenalties[i] * crit;
      }
      ineqLagrange[i]+=ineqPenalties[i] * ineqValues[i];
      if (ineqLagrange[i] > 0) {
        ineqLagrange[i]=0;
      }
      if (ineqViolations[i] >= worstIneqViolation / 2.0 && worstIneqViolation >= ineqConstraintTolerance) {
        ineqPenalties[i]*=1.0;
      }
 else {
        ineqPenalties[i]*=1.0;
      }
      if (worstIneqViolation / (lastWorstIneqViolation + 1e-100) > 0.25 && worstIneqViolation >= ineqConstraintTolerance) {
        ineqPenalties[i]*=5.0;
      }
    }
    if (!silent) {
      System.err.println("!i " + arrayMax(ineqPenalties) + "/"+ worstIneqViolation+ "!");
    }
  }
  return copyArray(x);
}
