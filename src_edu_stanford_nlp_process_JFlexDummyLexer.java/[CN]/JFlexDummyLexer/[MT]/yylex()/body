{
  int yy_input;
  int yy_action;
  int yy_currentPos_l;
  int yy_startRead_l;
  int yy_markedPos_l;
  int yy_endRead_l=yy_endRead;
  char[] yy_buffer_l=yy_buffer;
  char[] yycmap_l=yycmap;
  int[] yytrans_l=yytrans;
  int[] yy_rowMap_l=yy_rowMap;
  byte[] yy_attr_l=YY_ATTRIBUTE;
  while (true) {
    yy_markedPos_l=yy_markedPos;
    yy_action=-1;
    yy_startRead_l=yy_currentPos_l=yy_currentPos=yy_startRead=yy_markedPos_l;
    yy_state=yy_lexical_state;
    yy_forAction: {
      while (true) {
        if (yy_currentPos_l < yy_endRead_l)         yy_input=yy_buffer_l[yy_currentPos_l++];
 else         if (yy_atEOF) {
          yy_input=YYEOF;
          break yy_forAction;
        }
 else {
          yy_currentPos=yy_currentPos_l;
          yy_markedPos=yy_markedPos_l;
          boolean eof=yy_refill();
          yy_currentPos_l=yy_currentPos;
          yy_markedPos_l=yy_markedPos;
          yy_buffer_l=yy_buffer;
          yy_endRead_l=yy_endRead;
          if (eof) {
            yy_input=YYEOF;
            break yy_forAction;
          }
 else {
            yy_input=yy_buffer_l[yy_currentPos_l++];
          }
        }
        int yy_next=yytrans_l[yy_rowMap_l[yy_state] + yycmap_l[yy_input]];
        if (yy_next == -1)         break yy_forAction;
        yy_state=yy_next;
        int yy_attributes=yy_attr_l[yy_state];
        if ((yy_attributes & 1) == 1) {
          yy_action=yy_state;
          yy_markedPos_l=yy_currentPos_l;
          if ((yy_attributes & 8) == 8)           break yy_forAction;
        }
      }
    }
    yy_markedPos=yy_markedPos_l;
switch (yy_action) {
case 1:
{
        return ACCEPT;
      }
case 4:
    break;
case 2:
{
  }
case 5:
break;
default :
if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
yy_atEOF=true;
return YYEOF;
}
 else {
yy_ScanError(YY_NO_MATCH);
}
}
}
}
