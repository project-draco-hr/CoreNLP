{
  return new SearchNodeIterator(){
    Stack<IndexedWord> searchStack;
    Set<IndexedWord> searchedNodes;
    Set<IndexedWord> matchedNodes;
    Iterator<SemanticGraphEdge> neighborIterator;
    @Override public void initialize(){
      if (node.equals(IndexedWord.NO_WORD)) {
        next=null;
        return;
      }
      neighborIterator=null;
      searchedNodes=Generics.newHashSet();
      matchedNodes=Generics.newHashSet();
      searchStack=Generics.newStack();
      searchStack.push(node);
      advance();
    }
    @Override void advance(){
      if (node.equals(IndexedWord.NO_WORD)) {
        next=null;
        return;
      }
      while (!searchStack.isEmpty()) {
        if (neighborIterator == null || !neighborIterator.hasNext()) {
          IndexedWord search=searchStack.pop();
          neighborIterator=sg.incomingEdgeIterator(search);
        }
        while (neighborIterator.hasNext()) {
          SemanticGraphEdge edge=neighborIterator.next();
          IndexedWord source=edge.getSource();
          if (!searchedNodes.contains(source)) {
            searchStack.push(source);
            searchedNodes.add(source);
          }
          if (type.accept(edge.getRelation().toString()) && !matchedNodes.contains(source)) {
            matchedNodes.add(source);
            next=source;
            return;
          }
        }
      }
      next=null;
    }
  }
;
}
