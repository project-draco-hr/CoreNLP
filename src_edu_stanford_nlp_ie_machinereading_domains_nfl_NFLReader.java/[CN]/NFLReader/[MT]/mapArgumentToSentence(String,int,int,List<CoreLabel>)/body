{
  int tokenStart=-1;
  int tokenEnd=-1;
  logger.fine("Mapping argument " + text + " ["+ start+ ", "+ end+ ")");
  for (int i=0; i < tokens.size(); i++) {
    CoreLabel l=tokens.get(i);
    CoreLabel next=(i == tokens.size() - 1 ? null : tokens.get(i + 1));
    if (l.beginPosition() == start) {
      tokenStart=i;
      logger.fine("Found token start: " + l.word());
    }
 else     if (l.beginPosition() < start && l.endPosition() - 1 >= start) {
      tokenStart=i;
      logger.fine("Found token start: " + l.word());
      logger.info("WARNING: approximate START match of character span {" + start + ", "+ end+ "} to tokens: "+ StringUtils.join(tokens," "));
    }
    if (l.endPosition() - 1 == end) {
      tokenEnd=i + 1;
      logger.fine("Found token end: " + l.word());
      break;
    }
 else     if (l.endPosition() > end && l.beginPosition() < end) {
      tokenEnd=i + 1;
      logger.fine("Found token end: " + l.word());
      logger.info("WARNING: approximate END match of character span {" + start + ", "+ end+ "} to tokens: "+ StringUtils.join(tokens," "));
      break;
    }
 else     if (l.endPosition() == end && tokenStart != -1 && (next == null || next.beginPosition() > end)) {
      tokenEnd=i + 1;
      logger.fine("Found token end: " + l.word());
      logger.info("WARNING: approximate END match of character span {" + start + ", "+ end+ "} to tokens: "+ StringUtils.join(tokens," "));
      break;
    }
  }
  if (tokenStart != -1 && tokenEnd != -1) {
    return new Span(tokenStart,tokenEnd);
  }
  return null;
}
