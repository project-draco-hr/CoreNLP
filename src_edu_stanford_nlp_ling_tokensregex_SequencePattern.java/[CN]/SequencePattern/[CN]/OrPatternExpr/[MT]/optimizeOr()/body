{
  List<PatternExpr> opts=new ArrayList<PatternExpr>(patterns.size());
  Map<Pair<Class,Boolean>,Pair<Collection<PatternExpr>,Set<String>>> stringPatterns=new HashMap<Pair<Class,Boolean>,Pair<Collection<PatternExpr>,Set<String>>>();
  for (  PatternExpr p : patterns) {
    PatternExpr opt=p.optimize();
    opts.add(opt);
    if (opt instanceof NodePatternExpr) {
      NodePattern nodePattern=((NodePatternExpr)opt).nodePattern;
      if (nodePattern instanceof CoreMapNodePattern) {
        List<Pair<Class,NodePattern>> annotationPatterns=((CoreMapNodePattern)nodePattern).getAnnotationPatterns();
        if (annotationPatterns.size() == 1) {
          Pair<Class,NodePattern> pair=annotationPatterns.get(0);
          if (pair.second instanceof CoreMapNodePattern.StringAnnotationPattern) {
            Boolean ignoreCase=((CoreMapNodePattern.StringAnnotationPattern)pair.second).ignoreCase;
            String target=((CoreMapNodePattern.StringAnnotationPattern)pair.second).target;
            Pair<Class,Boolean> key=Pair.makePair(pair.first,ignoreCase);
            Pair<Collection<PatternExpr>,Set<String>> saved=stringPatterns.get(key);
            if (saved == null) {
              saved=new Pair<Collection<PatternExpr>,Set<String>>(new ArrayList<PatternExpr>(),new HashSet<String>());
              stringPatterns.put(key,saved);
            }
            saved.first.add(opt);
            saved.second.add(target);
          }
        }
      }
    }
  }
  Map<PatternExpr,Boolean> alreadyOptimized=new IdentityHashMap<PatternExpr,Boolean>();
  List<PatternExpr> finalOptimizedPatterns=new ArrayList<PatternExpr>(patterns.size());
  for (  Pair<Class,Boolean> key : stringPatterns.keySet()) {
    Pair<Collection<PatternExpr>,Set<String>> saved=stringPatterns.get(key);
    Set<String> set=saved.second;
    if (set.size() > OPTIMIZE_MIN_SIZE) {
      PatternExpr optimized=new NodePatternExpr(new CoreMapNodePattern(key.first,new CoreMapNodePattern.StringInSetAnnotationPattern(set,key.second)));
      finalOptimizedPatterns.add(optimized);
      for (      PatternExpr p : saved.first) {
        alreadyOptimized.put(p,true);
      }
    }
  }
  for (  PatternExpr p : opts) {
    Boolean included=alreadyOptimized.get(p);
    if (included == null || !included) {
      finalOptimizedPatterns.add(p);
    }
  }
  return new OrPatternExpr(finalOptimizedPatterns);
}
