{
  this.softPriorMapEn=softPriorMapEn;
  this.softPriorMapCh=softPriorMapCh;
  this.classIndexEn=classIndexEn;
  this.classIndexCh=classIndexCh;
  this.backgroundSymbol=classIndexEn.indexOf(backgroundSymbol);
  this.numClasses=classIndexEn.size();
  this.possibleValues=new int[numClasses];
  for (int i=0; i < numClasses; i++) {
    possibleValues[i]=i;
  }
  this.alignment=alignment;
  this.flags=flags;
  this.enDocSize=enDocSize;
  this.chDocSize=chDocSize;
  this.sequenceSize=enDocSize + chDocSize;
  this.alignmentMap=new HashMap<Integer,List<Pair<Integer,Double>>>(alignment.size() * 2);
  for (  Triple<Integer,Integer,Double> wordPair : alignment) {
    int enInd=wordPair.first();
    int chInd=wordPair.second();
    double prob=wordPair.third();
    chInd+=enDocSize;
    if (!alignmentMap.containsKey(enInd)) {
      List<Pair<Integer,Double>> list=new ArrayList<Pair<Integer,Double>>();
      list.add(new Pair<Integer,Double>(chInd,prob));
      alignmentMap.put(enInd,list);
    }
 else {
      List<Pair<Integer,Double>> list=alignmentMap.get(enInd);
      list.add(new Pair<Integer,Double>(chInd,prob));
    }
    if (!alignmentMap.containsKey(chInd)) {
      List<Pair<Integer,Double>> list=new ArrayList<Pair<Integer,Double>>();
      list.add(new Pair<Integer,Double>(enInd,prob));
      alignmentMap.put(chInd,list);
    }
 else {
      List<Pair<Integer,Double>> list=alignmentMap.get(chInd);
      list.add(new Pair<Integer,Double>(enInd,prob));
    }
  }
}
