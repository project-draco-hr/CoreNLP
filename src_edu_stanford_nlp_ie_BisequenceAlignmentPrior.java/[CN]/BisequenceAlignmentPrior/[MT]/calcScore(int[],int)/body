{
  double newScore=0;
  if (alignmentMap.containsKey(position)) {
    List<Pair<Integer,Double>> posProbList=alignmentMap.get(position);
    if (BisequenceEmpiricalNERPrior.DEBUG && BisequenceEmpiricalNERPrior.debugIndices.indexOf(position) != -1)     System.err.println("alignment size: " + posProbList.size());
    for (    Pair<Integer,Double> posProb : posProbList) {
      int alignedPos=posProb.first();
      double alignedProb=posProb.second();
      int alignedLabel=sequence[alignedPos];
      double probFactor=1.0;
      if (flags.factorInAlignmentProb) {
        probFactor=alignedProb;
      }
      String alignedLabelStr="";
      if (position >= enDocSize) {
        alignedLabelStr=classIndexEn.get(alignedLabel);
      }
 else {
        alignedLabelStr=classIndexCh.get(alignedLabel);
      }
      double alignScore=getAlignedWordPairScore(sequence[position],alignedLabel,position);
      double addPart=probFactor * alignScore;
      if (BisequenceEmpiricalNERPrior.DEBUG && BisequenceEmpiricalNERPrior.debugIndices.indexOf(position) != -1)       System.err.println("alignment sequence[" + position + "] to "+ alignedPos+ ":"+ alignedLabelStr+ ", has alignScore:"+ alignScore+ ", final score:"+ addPart);
      newScore+=addPart;
    }
  }
 else {
  }
  return newScore;
}
