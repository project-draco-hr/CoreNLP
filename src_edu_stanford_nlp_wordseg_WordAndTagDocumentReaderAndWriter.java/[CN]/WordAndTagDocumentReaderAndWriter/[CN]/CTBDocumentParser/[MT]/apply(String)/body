{
  if (line == null) {
    return null;
  }
  line=line.trim();
  String[] toks=line.split("[\\s\\p{Zs}]+");
  String patternStr="(.*)_([A-Z\\-]+)$";
  Pattern pattern=Pattern.compile(patternStr);
  String[] words=new String[toks.length];
  String[] postags=new String[toks.length];
  for (int i=0; i < toks.length; i++) {
    String tok=toks[i];
    Matcher matcher=pattern.matcher(tok);
    boolean matchFound=matcher.find();
    if (matchFound) {
      String word=matcher.group(1);
      String tag=matcher.group(2);
      words[i]=word;
      postags[i]=tag;
    }
 else {
      words[i]=tok;
      postags[i]="WORD";
    }
  }
  line=StringUtils.join(words," ");
  String[] postagsOnChars=new String[line.length()];
  int ptrTag=0;
  for (int i=0; i < line.length(); i++) {
    char ch=line.charAt(i);
    if (ch == ' ') {
      ptrTag++;
    }
 else {
      postagsOnChars[i]=postags[ptrTag];
    }
  }
  if (ptrTag != toks.length - 1) {
    throw new RuntimeException("When tagging chars with POS, the length is not the same?");
  }
  List<CoreLabel> lwi=new ArrayList<CoreLabel>();
  String origLine=line;
  if (DEBUG)   EncodingPrintWriter.err.println("ORIG: " + line,"UTF-8");
  line=cdtos.normalization(origLine);
  if (DEBUG)   EncodingPrintWriter.err.println("NORM: " + line,"UTF-8");
  int origIndex=0;
  int position=0;
  StringBuilder nonspaceLineSB=new StringBuilder();
  for (int i=0, len=line.length(); i < len; i++) {
    char ch=line.charAt(i);
    CoreLabel wi=new CoreLabel();
    String wordString=Character.toString(ch);
    if (!Character.isWhitespace(ch) && !Character.isISOControl(ch)) {
      wi.set(CharAnnotation.class,intern(wordString));
      nonspaceLineSB.append(wordString);
      while (Character.isWhitespace(origLine.charAt(origIndex)) || Character.isISOControl(origLine.charAt(origIndex))) {
        origIndex++;
      }
      wordString=Character.toString(origLine.charAt(origIndex));
      wi.set(OriginalCharAnnotation.class,intern(wordString));
      if (flags.useShapeStrings) {
        wi.set(ShapeAnnotation.class,shapeOf(wordString));
      }
      if (flags.useUnicodeType || flags.useUnicodeType4gram || flags.useUnicodeType5gram) {
        wi.set(UTypeAnnotation.class,Character.getType(ch));
      }
      if (flags.useUnicodeBlock) {
        wi.set(UBlockAnnotation.class,Characters.unicodeBlockStringOf(ch));
      }
      origIndex++;
      String tag=postagsOnChars[i];
      String category;
      if (tag.equals("NR")) {
        category="NR";
      }
 else {
        category="WORD";
      }
      StringBuilder one=new StringBuilder();
      one.append(category).append("-1");
      StringBuilder zero=new StringBuilder();
      zero.append(category).append("-0");
      if (i == 0) {
        wi.set(AnswerAnnotation.class,one.toString());
        wi.set(SpaceBeforeAnnotation.class,"1");
      }
 else       if (Character.isWhitespace(line.charAt(i - 1)) || Character.isISOControl(line.charAt(i - 1))) {
        wi.set(AnswerAnnotation.class,one.toString());
        wi.set(SpaceBeforeAnnotation.class,"1");
      }
 else {
        wi.set(AnswerAnnotation.class,zero.toString());
        wi.set(SpaceBeforeAnnotation.class,"0");
      }
      wi.set(PositionAnnotation.class,intern(String.valueOf((position))));
      position++;
      if (DEBUG_MORE)       EncodingPrintWriter.err.println(wi.toString(),"UTF-8");
      lwi.add(wi);
    }
  }
  if (flags.dictionary != null) {
    String nonspaceLine=nonspaceLineSB.toString();
    addDictionaryFeatures(cdict,LBeginAnnotation.class,LMiddleAnnotation.class,LEndAnnotation.class,nonspaceLine,lwi);
  }
  if (flags.dictionary2 != null) {
    String nonspaceLine=nonspaceLineSB.toString();
    addDictionaryFeatures(cdict2,D2_LBeginAnnotation.class,D2_LMiddleAnnotation.class,D2_LEndAnnotation.class,nonspaceLine,lwi);
  }
  return lwi;
}
