{
  if (lattice == null || len < 0)   throw new UnsupportedOperationException("segmentWords must be run first");
  List<Word> segmentedWords=new ArrayList<Word>();
  double costs[]=new double[len + 1];
  DFSATransition[] bptrs=new DFSATransition[len + 1];
  costs[0]=0.0;
  for (int i=1; i <= len; ++i)   costs[i]=Double.MAX_VALUE;
  for (int start=0; start < len; ++start) {
    DFSAState fromState=states[start];
    Collection<DFSATransition> trs=fromState.transitions();
    for (    DFSATransition tr : trs) {
      DFSAState toState=tr.getTarget();
      double lcost=tr.score();
      int end=((Integer)toState.stateID()).intValue();
      if (h == MatchHeuristic.MINWORDS) {
        if (costs[start] + 1 < costs[end]) {
          costs[end]=costs[start] + lcost;
          bptrs[end]=tr;
        }
      }
 else       if (h == MatchHeuristic.MAXWORDS) {
        if (costs[start] + 1 < costs[end]) {
          costs[end]=costs[start] - lcost;
          bptrs[end]=tr;
        }
      }
 else {
        throw new UnsupportedOperationException("unimplemented heuristic");
      }
    }
  }
  int i=len;
  while (i > 0) {
    DFSATransition tr=bptrs[i];
    DFSAState fromState=tr.getSource();
    Word word=(Word)tr.getInput();
    if (!word.word().equals(" "))     segmentedWords.add(0,word);
    i=((Integer)fromState.stateID()).intValue();
  }
  if (DEBUG) {
    double density=edgesNb * 1.0 / segmentedWords.size();
    System.err.println("latticeDensity: " + density + " cost: "+ costs[len]);
  }
  return new ArrayList<Word>(segmentedWords);
}
