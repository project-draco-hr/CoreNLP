{
  double prob=0.0;
  to2D(x,weights);
  setWeights(weights);
  clear2D(E);
  MulticoreWrapper<Pair<Integer,Boolean>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>> wrapper=new MulticoreWrapper<Pair<Integer,Boolean>,Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>>>(multiThreadGrad,dropoutPriorThreadProcessor);
  for (int m=0; m < totalData.length; m++) {
    boolean submitIsUnsup=(m >= unsupDropoutStartIndex);
    wrapper.put(new Pair<Integer,Boolean>(m,submitIsUnsup));
    while (wrapper.peek()) {
      Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
      int docIndex=result.first();
      boolean isUnsup=docIndex >= unsupDropoutStartIndex;
      if (isUnsup) {
        prob+=unsupDropoutScale * result.second();
      }
 else {
        prob+=result.second();
      }
      Map<Integer,double[]> partialDropout=result.fourth();
      if (partialDropout != null) {
        if (isUnsup) {
          combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
        }
 else {
          combine2DArr(dropoutPriorGrad,partialDropout);
        }
      }
      if (!isUnsup) {
        Map<Integer,double[]> partialE=result.third();
        if (partialE != null)         combine2DArr(E,partialE);
      }
    }
  }
  wrapper.join();
  while (wrapper.peek()) {
    Quadruple<Integer,Double,Map<Integer,double[]>,Map<Integer,double[]>> result=wrapper.poll();
    int docIndex=result.first();
    boolean isUnsup=docIndex >= unsupDropoutStartIndex;
    if (isUnsup) {
      prob+=unsupDropoutScale * result.second();
    }
 else {
      prob+=result.second();
    }
    Map<Integer,double[]> partialDropout=result.fourth();
    if (partialDropout != null) {
      if (isUnsup) {
        combine2DArr(dropoutPriorGrad,partialDropout,unsupDropoutScale);
      }
 else {
        combine2DArr(dropoutPriorGrad,partialDropout);
      }
    }
    if (!isUnsup) {
      Map<Integer,double[]> partialE=result.third();
      if (partialE != null)       combine2DArr(E,partialE);
    }
  }
  if (Double.isNaN(prob)) {
    throw new RuntimeException("Got NaN for prob in CRFLogConditionalObjectiveFunctionWithDropout.calculate()" + " - this may well indicate numeric underflow due to overly long documents.");
  }
  value=-prob;
  if (VERBOSE) {
    System.err.println("value is " + Math.exp(-value));
  }
  int index=0;
  for (int i=0; i < E.length; i++) {
    for (int j=0; j < E[i].length; j++) {
      derivative[index]=(E[i][j] - Ehat[i][j]);
      derivative[index]+=dropoutScale * dropoutPriorGrad[i][j];
      if (VERBOSE) {
        System.err.println("deriv(" + i + ","+ j+ ") = "+ E[i][j]+ " - "+ Ehat[i][j]+ " = "+ derivative[index]);
      }
      index++;
    }
  }
}
