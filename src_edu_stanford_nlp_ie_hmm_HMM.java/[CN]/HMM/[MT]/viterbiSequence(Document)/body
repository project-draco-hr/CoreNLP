{
  if (unseenMode == UNSEENMODE_UNK_LOW_COUNTS) {
    doc=new UnknownWordCollapser(vocab.keySet(),unkModel == UNKMODEL_FEATURAL_DECOMP,feat).processDocument(doc);
  }
  int numTimes=doc.size() + 2;
  int numStates=states.length;
  double[][] delta=new double[numStates][numTimes];
  int[][] psi=new int[numStates][numTimes];
  delta[State.STARTIDX][0]=1.0;
  int numScalings=0;
  for (int t=0; t < numTimes - 1; t++) {
    Word ttw=null;
    if (t > 0 && t < (numTimes - 1)) {
      ttw=(Word)doc.get(t - 1);
    }
    double[] emitProbs=null;
    if (ttw != null) {
      emitProbs=new double[numStates];
      for (int i=0; i < numStates; i++) {
        if (states[i].emit != null) {
          emitProbs[i]=states[i].emit.get(ttw.word());
        }
      }
    }
    double maxmax=0.0;
    for (int j=0; j < numStates; j++) {
      double max=0.0;
      int argmax=State.BKGRNDIDX;
      for (int i=0; i < numStates; i++) {
        double p;
        if (ttw == null) {
          p=delta[i][t] * states[i].transition[j];
        }
 else         if (states[i].emit == null) {
          p=0.0;
        }
 else {
          p=delta[i][t] * states[i].transition[j] * emitProbs[i];
        }
        if (p > max) {
          max=p;
          argmax=i;
        }
        if (false && t < 200 && p != 0.0) {
          System.err.println("Time " + t + " i="+ i+ " to j="+ j+ "; States[i] is "+ states[i]+ "; word is "+ ttw+ "; emit is "+ ((states[i].emit == null || ttw == null) ? "null" : Double.toString(emitProbs[i]))+ " trans is "+ states[i].transition[j]+ " path prob is "+ p);
        }
      }
      delta[j][t + 1]=max;
      psi[j][t + 1]=argmax;
      if (max > maxmax) {
        maxmax=max;
      }
    }
    if (maxmax == 0.0) {
      System.err.println("Viterbi warning: no path at time " + t + " [word: "+ ttw+ "]");
      for (int a=t + 1; a < numTimes; a++) {
        psi[2][a]=State.BKGRNDIDX;
      }
      psi[State.FINISHIDX][numTimes - 1]=State.BKGRNDIDX;
      break;
    }
 else     if (maxmax < 1e-200) {
      numScalings++;
      for (int j=0; j < numStates; j++) {
        delta[j][t + 1]*=1e200;
      }
    }
  }
  int[] sequence=new int[numTimes];
  sequence[numTimes - 1]=State.FINISHIDX;
  if (false) {
    System.err.print("Viterbi sequence prob = " + delta[0][numTimes - 1]);
    if (numScalings > 0) {
      System.err.print(" * 10^-" + (numScalings * 200));
    }
    System.err.println();
  }
  for (int k=numTimes - 2; k >= 0; k--) {
    sequence[k]=psi[sequence[k + 1]][k + 1];
  }
  if (false) {
    System.out.println("Viterbi Sequence is:");
    for (int k=0; k < numTimes; k++) {
      if (k != 0) {
        System.out.print(" - ");
      }
      System.out.print(sequence[k]);
    }
    System.out.println();
  }
  return sequence;
}
