{
  Document unkDoc=doc;
  if (unseenMode == UNSEENMODE_UNK_LOW_COUNTS) {
    unkDoc=new UnknownWordCollapser(vocab.keySet(),unkModel == UNKMODEL_FEATURAL_DECOMP,feat).processDocument(doc);
  }
  int[] typeSequence=getLabelsForSequence(stateSequence);
  HashMap<Integer,List<AnswerChecker.Range>> answerRangesByType=AnswerChecker.getAnswerRanges(typeSequence);
  HashMap<Integer,List<String>> bestAnswerByType=new HashMap<Integer,List<String>>();
  for (  Integer type : answerRangesByType.keySet()) {
    List<AnswerChecker.Range> answerRanges=answerRangesByType.get(type);
    ClassicCounter<AnswerChecker.Range> rangeScores=new ClassicCounter<AnswerChecker.Range>();
    for (    AnswerChecker.Range r : answerRanges) {
      double score=1.0;
      int from=Math.max(1,r.getFrom() - windowSize);
      int to=Math.min(stateSequence.length - 1,r.getTo() + windowSize);
      for (int i=from; i <= to; i++) {
        score*=states[stateSequence[i - 1]].transition[stateSequence[i]];
        if (i < stateSequence.length - 1) {
          score*=states[stateSequence[i]].emit.get(((HasWord)unkDoc.get(i - 1)).word());
        }
      }
      score=Math.pow(score,1.0 / (to - from));
      rangeScores.setCount(r,score);
    }
    AnswerChecker.Range bestAnswerRange=Counters.argmax(rangeScores);
    if (bestAnswerRange != null) {
      bestAnswerByType.put(type,bestAnswerRange.extractRange(doc));
    }
  }
  return bestAnswerByType;
}
