{
  ClassicCounter[] expectedEmissions=new ClassicCounter[states.length];
  for (int i=0; i < expectedEmissions.length; i++) {
    expectedEmissions[i]=new ClassicCounter();
  }
  double[] pSGT=new double[numStates];
  for (int d=0, dsize=docs.size(); d < dsize; d++) {
    Document doc=(Document)docs.get(d);
    if (!forwardAlgorithm(doc,true)) {
      if (verbose) {
        System.err.println("HMM.computeExpectedEmissions: warning: " + "couldn't generate held out document " + d + ".");
      }
    }
 else {
      backwardAlgorithm(doc,true);
      int numTimes=doc.size() + 2;
      for (int t=1; t < numTimes - 1; t++) {
        TypedTaggedWord ttw=(TypedTaggedWord)doc.get(t - 1);
        double total=0.0;
        for (int k=0; k < states.length; k++) {
          pSGT[k]=alpha[k][t] * beta[k][t];
          if (!useSingletons || vocab.getCount(ttw.word()) == 1) {
            expectedEmissions[k].incrementCount(ttw.word(),pSGT[k]);
          }
          total+=pSGT[k];
        }
        if (sanityCheck && Math.abs(total - 1.0) > TOLERANCE) {
          System.err.println("Bung: total in shrinkUnseen is " + total);
          if (SloppyMath.isDangerous(total)) {
            System.err.println("Total is dangerous (" + total + ") for doc "+ d+ " time "+ t+ "! TypedTaggedWord is "+ ((ttw == null) ? "null" : ttw.word()));
            printTrellis("Forward",alpha,t - 5,t + 2,5);
            printTrellis("Backward",beta,t - 2,t + 5,5);
            printStateVector("Scaling",scale);
            for (int k=0; k < states.length; k++) {
              if (states[k].emit != null) {
                System.err.println("P(" + ttw.word() + "|s="+ k+ ") = "+ states[k].emit.get(ttw.word()));
              }
            }
          }
        }
      }
    }
  }
  return (expectedEmissions);
}
