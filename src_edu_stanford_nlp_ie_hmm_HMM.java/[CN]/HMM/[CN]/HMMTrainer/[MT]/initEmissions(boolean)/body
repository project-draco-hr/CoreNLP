{
  vocab=new ClassicCounter();
  Counters.addInPlace(vocab,trainDocs.getVocab());
  if (unseenMode == UNSEENMODE_UNK_LOW_COUNTS) {
    addUnknownCounts(vocab);
  }
  ClassicCounter<String> uniformTable=new ClassicCounter<String>();
  for (  String key : vocab.keySet()) {
    uniformTable.incrementCount(key,1.0 / vocab.size());
  }
  uniform=new PlainEmitMap(uniformTable);
  ClassicCounter<String> starter=new ClassicCounter<String>();
  double trainWordCount=trainDocs.wordCount();
  for (  String word : vocab.keySet()) {
    starter.incrementCount(word,vocab.getCount(word) / trainWordCount);
  }
  if (targetParents == null || initStateEmissions) {
    targetParents=new PlainEmitMap[targetFields.length];
    for (int i=0; i < targetParents.length; i++) {
      targetParents[i]=new PlainEmitMap(starter);
    }
  }
  if (initStateEmissions) {
    FeatureMap dummyFM=new FeatureMap(feat);
    for (int i=State.BKGRNDIDX; i < states.length; i++) {
      if (hmmType == CONTEXT_HMM && states[i].type > 0) {
        states[i].emit=new ConstantEmitMap(targetFields[states[i].type] + "STATE");
      }
 else       if (unseenMode == UNSEENMODE_HOLD_OUT_MASS) {
        UnseenEmitMap uem=new UnseenEmitMap(starter);
        uem.setFeatureMap(dummyFM,trainDocs.wordCount());
        states[i].emit=uem;
      }
 else       if (unseenMode == UNSEENMODE_USE_CHAR_NGRAMS) {
        CharSequenceEmitMap csem=new CharSequenceEmitMap(new PlainEmitMap(starter));
        states[i].emit=csem;
      }
 else {
        states[i].emit=new PlainEmitMap(starter);
      }
    }
  }
}
