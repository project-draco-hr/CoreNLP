{
  if (args.length == 0) {
    printUsage();
    return;
  }
  int i=0;
  final int maxLength;
  final int minLength;
  int maxL=Integer.MAX_VALUE;
  int minL=-1;
  boolean normalized=false;
  boolean decimate=false;
  boolean pennPrintTrees=false;
  boolean oneLinePrint=false;
  boolean printTaggedWords=false;
  boolean printWords=false;
  boolean correct=false;
  String annotationOptions=null;
  boolean summary=false;
  boolean timing=false;
  boolean yield=false;
  boolean punct=false;
  boolean sentenceLengths=false;
  boolean countTaggings=false;
  boolean removeCodeTrees=false;
  String decimatePrefix=null;
  String encoding=TreebankLanguagePack.DEFAULT_ENCODING;
  String suffix=Treebank.DEFAULT_TREE_FILE_SUFFIX;
  TreeReaderFactory trf=null;
  TreebankLanguagePack tlp=null;
  List<Filter<Tree>> filters=new ArrayList<Filter<Tree>>();
  while (i < args.length && args[i].startsWith("-")) {
    if (args[i].equals("-maxLength") && i + 1 < args.length) {
      maxL=Integer.parseInt(args[i + 1]);
      i+=2;
    }
 else     if (args[i].equals("-minLength") && i + 1 < args.length) {
      minL=Integer.parseInt(args[i + 1]);
      i+=2;
    }
 else     if (args[i].equals("-h") || args[i].equals("-help")) {
      printUsage();
      i++;
    }
 else     if (args[i].equals("-normalized")) {
      normalized=true;
      i+=1;
    }
 else     if (args[i].equalsIgnoreCase("-tlp")) {
      try {
        final Object o=Class.forName(args[i + 1]).newInstance();
        tlp=(TreebankLanguagePack)o;
        trf=tlp.treeReaderFactory();
      }
 catch (      Exception e) {
        System.err.println("Couldn't instantiate as TreebankLanguagePack: " + args[i + 1]);
        return;
      }
      i+=2;
    }
 else     if (args[i].equals("-treeReaderFactory") || args[i].equals("-trf")) {
      try {
        final Object o=Class.forName(args[i + 1]).newInstance();
        trf=(TreeReaderFactory)o;
      }
 catch (      Exception e) {
        System.err.println("Couldn't instantiate as TreeReaderFactory: " + args[i + 1]);
        return;
      }
      i+=2;
    }
 else     if (args[i].equals("-suffix")) {
      suffix=args[i + 1];
      i+=2;
    }
 else     if (args[i].equals("-decimate")) {
      decimate=true;
      decimatePrefix=args[i + 1];
      i+=2;
    }
 else     if (args[i].equals("-encoding")) {
      encoding=args[i + 1];
      i+=2;
    }
 else     if (args[i].equals("-correct")) {
      correct=true;
      i+=1;
    }
 else     if (args[i].equals("-summary")) {
      summary=true;
      i+=1;
    }
 else     if (args[i].equals("-yield")) {
      yield=true;
      i+=1;
    }
 else     if (args[i].equals("-punct")) {
      punct=true;
      i+=1;
    }
 else     if (args[i].equals("-pennPrint")) {
      pennPrintTrees=true;
      i++;
    }
 else     if (args[i].equals("-oneLine")) {
      oneLinePrint=true;
      i++;
    }
 else     if (args[i].equals("-taggedWords")) {
      printTaggedWords=true;
      i++;
    }
 else     if (args[i].equals("-words")) {
      printWords=true;
      i++;
    }
 else     if (args[i].equals("-annotate")) {
      annotationOptions=args[i + 1];
      i+=2;
    }
 else     if (args[i].equals("-timing")) {
      timing=true;
      i++;
    }
 else     if (args[i].equals("-countTaggings")) {
      countTaggings=true;
      i++;
    }
 else     if (args[i].equals("-sentenceLengths")) {
      sentenceLengths=true;
      i++;
    }
 else     if (args[i].equals("-removeCodeTrees")) {
      removeCodeTrees=true;
      i++;
    }
 else     if (args[i].equals("-filter")) {
      Filter<Tree> filter=ReflectionLoading.loadByReflection(args[i + 1]);
      filters.add(filter);
      i+=2;
    }
 else {
      System.err.println("Unknown option: " + args[i]);
      i++;
    }
  }
  maxLength=maxL;
  minLength=minL;
  Treebank treebank;
  if (trf == null) {
    trf=new TreeReaderFactory(){
      @Override public TreeReader newTreeReader(      Reader in){
        return new PennTreeReader(in,new LabeledScoredTreeFactory());
      }
    }
;
  }
  if (normalized) {
    treebank=new DiskTreebank();
  }
 else {
    treebank=new DiskTreebank(trf,encoding);
  }
  for (  Filter<Tree> filter : filters) {
    treebank=new FilteringTreebank(treebank,filter);
  }
  final PrintWriter pw=new PrintWriter(new OutputStreamWriter(System.out,encoding),true);
  if (i + 1 < args.length) {
    treebank.loadPath(args[i],new NumberRangesFileFilter(args[i + 1],true));
  }
 else   if (i < args.length) {
    treebank.loadPath(args[i],suffix,true);
  }
 else {
    printUsage();
    return;
  }
  if (annotationOptions != null) {
    System.err.println("annotationOptions not yet implemented");
  }
  if (summary) {
    System.out.println(treebank.textualSummary());
  }
  if (sentenceLengths) {
    sentenceLengths(treebank,args[i],((i + 1) < args.length ? args[i + 1] : null),pw);
  }
  if (punct) {
    printPunct(treebank,tlp,pw);
  }
  if (correct) {
    treebank=new EnglishPTBTreebankCorrector().transformTrees(treebank);
  }
  if (pennPrintTrees) {
    treebank.apply(new TreeVisitor(){
      @Override public void visitTree(      Tree tree){
        int length=tree.yield().size();
        if (length >= minLength && length <= maxLength) {
          tree.pennPrint(pw);
          pw.println();
        }
      }
    }
);
  }
  if (oneLinePrint) {
    treebank.apply(new TreeVisitor(){
      @Override public void visitTree(      Tree tree){
        int length=tree.yield().size();
        if (length >= minLength && length <= maxLength) {
          pw.println(tree);
        }
      }
    }
);
  }
  if (printWords) {
    final TreeNormalizer tn=new BobChrisTreeNormalizer();
    treebank.apply(new TreeVisitor(){
      @Override public void visitTree(      Tree tree){
        Tree tPrime=tn.normalizeWholeTree(tree,tree.treeFactory());
        int length=tPrime.yield().size();
        if (length >= minLength && length <= maxLength) {
          pw.println(Sentence.listToString(tPrime.taggedYield()));
        }
      }
    }
);
  }
  if (printTaggedWords) {
    final TreeNormalizer tn=new BobChrisTreeNormalizer();
    treebank.apply(new TreeVisitor(){
      @Override public void visitTree(      Tree tree){
        Tree tPrime=tn.normalizeWholeTree(tree,tree.treeFactory());
        pw.println(Sentence.listToString(tPrime.taggedYield(),false,"_"));
      }
    }
);
  }
  if (countTaggings) {
    countTaggings(treebank,pw);
  }
  if (yield) {
    treebank.apply(new TreeVisitor(){
      @Override public void visitTree(      Tree tree){
        int length=tree.yield().size();
        if (length >= minLength && length <= maxLength) {
          pw.println(Sentence.listToString(tree.yield()));
        }
      }
    }
);
  }
  if (decimate) {
    Writer w1=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(decimatePrefix + "-train.txt"),encoding));
    Writer w2=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(decimatePrefix + "-dev.txt"),encoding));
    Writer w3=new BufferedWriter(new OutputStreamWriter(new FileOutputStream(decimatePrefix + "-test.txt"),encoding));
    treebank.decimate(w1,w2,w3);
  }
  if (timing) {
    runTiming(treebank);
  }
  if (removeCodeTrees) {
    if (new File(args[i]).isDirectory()) {
      throw new RuntimeException("-removeCodeTrees only works on a single file");
    }
    String treebankStr=IOUtils.slurpFile(args[i]);
    treebankStr=treebankStr.replaceAll("\\( \\(CODE <[^>]+>\\)\\)","");
    Writer w=new OutputStreamWriter(new FileOutputStream(args[i]),encoding);
    w.write(treebankStr);
    w.close();
  }
}
