{
  if (props == null) {
    props=Extractor.getDefaultProperties();
  }
  int printMode=("num_sequences".equals(props.getProperty("viterbiPrintMode"))) ? PRINT_NUM_SEQUENCES : PRINT_TYPED_WORDS;
  targetIndexMap=new HashMap<String,Integer>();
  corpusTargetFields=testDocs.getTargetFields();
  for (int i=0; i < corpusTargetFields.length; i++) {
    targetIndexMap.put(corpusTargetFields[i],Integer.valueOf(i));
  }
  statsByType=new HashMap<Integer,PrecisionRecallStats>();
  aggregateStats=new PrecisionRecallStats();
  for (Iterator iter=testDocs.iterator(); iter.hasNext(); ) {
    TypedTaggedDocument doc=(TypedTaggedDocument)iter.next();
    AnswerChecker ac=new AnswerChecker(doc);
    if (verbose) {
      System.err.println("Document: " + doc.presentableText());
      System.err.println("True answers in document:");
      ac.printAnswers();
    }
    Map<Integer,PrecisionRecallStats> stats;
    int[] bestStateSequence=hmm.viterbiSequence(doc);
    int[] guessedTypeSequence=hmm.getLabelsForSequence(bestStateSequence);
    for (int i=0; i < guessedTypeSequence.length; i++) {
      Integer corpusType=null;
      if (guessedTypeSequence[i] >= 0) {
        corpusType=targetIndexMap.get(hmmTargetFields[guessedTypeSequence[i]]);
      }
      if (corpusType != null) {
        guessedTypeSequence[i]=corpusType.intValue();
      }
 else {
        guessedTypeSequence[i]=0;
      }
    }
    if (verbose) {
      System.err.println("Guessed answers:");
      ac.printAnswerWordSequences(guessedTypeSequence);
    }
    if (bestAnswerOnly) {
      HashMap<Integer,List<String>> bestAnswers=useFirstAnswer ? hmm.firstAnswers(doc,bestStateSequence) : hmm.bestAnswers(doc,bestStateSequence);
      HashMap<Integer,List<String>> convertedBestAnswers=new HashMap<Integer,List<String>>();
      for (      Integer hmmType : bestAnswers.keySet()) {
        Integer corpusType=targetIndexMap.get(hmmTargetFields[hmmType.intValue()]);
        if (corpusType != null) {
          convertedBestAnswers.put(corpusType,bestAnswers.get(hmmType));
        }
      }
      bestAnswers=convertedBestAnswers;
      if (verbose) {
        System.err.println("Best answers: " + bestAnswers);
      }
      stats=ac.checkBestAnswers(bestAnswers);
    }
 else {
      stats=ac.checkAnswers(guessedTypeSequence,false);
    }
    if (verbose) {
      int[] correctTypeSequence=doc.getTypeSequence();
      if (printMode == PRINT_TYPED_WORDS) {
        for (int i=0; i < doc.size(); i++) {
          StringBuilder buffer=new StringBuilder();
          buffer.append(((TypedTaggedWord)doc.get(i)).word());
          buffer.append(" (");
          buffer.append(correctTypeSequence[i]);
          if (correctTypeSequence[i] != guessedTypeSequence[i]) {
            buffer.append("/");
            buffer.append(guessedTypeSequence[i]);
          }
          buffer.append(":");
          buffer.append(bestStateSequence[i + 1]);
          buffer.append(") ");
          System.err.print(buffer.toString());
        }
        System.err.println();
      }
 else {
        System.err.print("Correct type sequence:");
        printTypeSequence(correctTypeSequence,corpusTargetFields.length);
        System.err.print("Guessed type sequence:");
        printTypeSequence(guessedTypeSequence,corpusTargetFields.length);
        System.err.print("Guessed state sequence:");
        printTypeSequence(bestStateSequence,corpusTargetFields.length);
      }
      if (correctTypeSequence.length != guessedTypeSequence.length) {
        System.err.println("Error: type sequence length mismatch");
      }
      int correct=0;
      for (int i=0; i < correctTypeSequence.length; i++) {
        if (guessedTypeSequence[i] == correctTypeSequence[i]) {
          correct++;
        }
      }
      NumberFormat nf=NumberFormat.getNumberInstance();
      nf.setMaximumFractionDigits(2);
      System.err.println("Per-token accuracy: " + correct + "/"+ correctTypeSequence.length+ " ("+ nf.format(((double)correct) / correctTypeSequence.length)+ ")");
      System.err.println();
      System.err.println("Document stats (by type): " + stats);
      System.err.println();
    }
    for (    Integer type : stats.keySet()) {
      PrecisionRecallStats prs=stats.get(type);
      PrecisionRecallStats typePRS=statsByType.get(type);
      if (typePRS == null) {
        typePRS=new PrecisionRecallStats();
      }
      typePRS.addCounts(prs);
      statsByType.put(type,typePRS);
      aggregateStats.addCounts(prs);
    }
  }
  if (verbose) {
    if (printMode == PRINT_TYPED_WORDS) {
      System.err.println("OUTPUT FORMAT: <word> (<correct type> [/ <guessed type>]:<state>");
    }
    System.err.println("Aggregate stats by type:");
    for (    Integer type : statsByType.keySet()) {
      PrecisionRecallStats prs=statsByType.get(type);
      String targetName=corpusTargetFields[type.intValue()];
      System.err.println();
      System.err.println("Precision on " + targetName + ": "+ prs.getPrecisionDescription(2));
      System.err.println("Recall on " + targetName + ": "+ prs.getRecallDescription(2));
      System.err.println("F1 on " + targetName + ": "+ prs.getF1Description(2));
    }
    System.err.println();
    System.err.println("Overall aggregate stats: " + aggregateStats);
    System.err.println("Overall Precision: " + aggregateStats.getPrecision());
    System.err.println("Overall Recall: " + aggregateStats.getRecall());
    System.err.println("Overall F1: " + aggregateStats.getFMeasure());
  }
  return (aggregateStats.getFMeasure());
}
