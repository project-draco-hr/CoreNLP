{
  return new AbstractSet<Map.Entry<K,V>>(){
    @Override public Iterator<Map.Entry<K,V>> iterator(){
      Predicate<Entry<K,V>> filter1=new Predicate<Entry<K,V>>(){
        private static final long serialVersionUID=1L;
        public boolean test(        Map.Entry<K,V> e){
          K key=e.getKey();
          return !deltaMap.containsKey(key);
        }
      }
;
      Iterator<Map.Entry<K,V>> iter1=new FilteredIterator<>(originalMap.entrySet().iterator(),filter1);
      Predicate<Entry<K,V>> filter2=new Predicate<Entry<K,V>>(){
        private static final long serialVersionUID=1L;
        public boolean test(        Map.Entry<K,V> e){
          Object value=e.getValue();
          if (value == removedValue) {
            return false;
          }
          return true;
        }
      }
;
class NullingIterator<K,V> implements Iterator<Map.Entry<K,V>> {
        private Iterator<Map.Entry<K,V>> i;
        public NullingIterator(        Iterator<Map.Entry<K,V>> i){
          this.i=i;
        }
        public boolean hasNext(){
          return i.hasNext();
        }
        public Map.Entry<K,V> next(){
          Map.Entry<K,V> e=i.next();
          Object o=e.getValue();
          if (o == nullValue) {
            return new SimpleEntry<>(e.getKey(),null);
          }
          return e;
        }
        public void remove(){
          throw new UnsupportedOperationException();
        }
      }
      Iterator<Entry<K,V>> iter2=new FilteredIterator<>(new NullingIterator<>(deltaMap.entrySet().iterator()),filter2);
      return new ConcatenationIterator<>(iter1,iter2);
    }
    @Override public int size(){
      int size=0;
      for (      Entry<K,V> kvEntry : this) {
        ErasureUtils.noop(kvEntry);
        size++;
      }
      return size;
    }
  }
;
}
