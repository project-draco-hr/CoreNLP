{
  String trainFile="train.tmp", validationFile="validation.tmp";
  double[] accs=new double[5];
  fitNumClassifiers=false;
  usetop=true;
  top=5;
  int current=0;
  while (current < 5) {
    for (int round=0; round < 5; round++) {
      fAssociations.clear();
      split(trainFileName,trainFile,validationFile);
      readTrainingInstances(trainFile);
      ReadDataWeka test=new ReadDataWeka(validationFile,train);
      makeFeatures("n");
      mE=new MaxEntModel(p.data,p.functions,0.001,gaincutoff);
      if (select) {
        mE.FindModel(gaincutoff);
      }
 else {
        mE.FindModel(0);
      }
      System.out.println("Number features are " + mE.activeFeats.size());
      model=mE.prob;
      model.improvedIterative(iters);
      model.checkCorrectness();
      mE.fAssociations=fAssociations;
      model=mE.prob;
      int res=0;
      for (int d=0; d < test.v.size(); d++) {
        DataDouble dD=test.getData(d);
        int y=getClassification(dD);
        if (y == dD.getYNo()) {
          res++;
        }
      }
      double newAcc=res / (double)test.numSamples();
      System.out.println("Accuracy " + newAcc);
      accs[current]=((accs[current] * round) + newAcc) / (double)(round + 1);
    }
    current++;
    top+=2;
  }
  int max=2;
  for (int j=0; j < accs.length; j++) {
    System.out.println(" accuracies " + j + " "+ accs[j]);
    if (accs[j] > accs[max]) {
      max=j;
    }
  }
  top=5 + max * 2;
  fAssociations.clear();
  mE.fAssociations.clear();
  reverseMap.clear();
  buildClassifier(trainFileName,iters,gaincutoff);
}
