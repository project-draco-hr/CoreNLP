{
  Timing timing=new Timing();
  long maxTrainTimeMillis=model.op.trainOptions.maxTrainTimeSeconds * 1000;
  long nextDebugCycle=model.op.trainOptions.debugOutputSeconds * 1000;
  int debugCycle=0;
  double bestAccuracy=0.0;
  double[] sumGradSquare=new double[model.totalParamSize()];
  Arrays.fill(sumGradSquare,1.0);
  int numBatches=trainingTrees.size() / model.op.trainOptions.batchSize + 1;
  System.err.println("Training on " + trainingTrees.size() + " trees in "+ numBatches+ " batches");
  System.err.println("Times through each training batch: " + model.op.trainOptions.epochs);
  for (int epoch=0; epoch < model.op.trainOptions.epochs; ++epoch) {
    List<Tree> shuffledSentences=Generics.newArrayList(trainingTrees);
    Collections.shuffle(shuffledSentences,model.rand);
    for (int batch=0; batch < numBatches; ++batch) {
      System.err.println("======================================");
      System.err.println("Epoch " + epoch + " batch "+ batch);
      int startTree=batch * model.op.trainOptions.batchSize;
      int endTree=(batch + 1) * model.op.trainOptions.batchSize;
      if (endTree + model.op.trainOptions.batchSize > shuffledSentences.size()) {
        endTree=shuffledSentences.size();
      }
      executeOneTrainingBatch(model,shuffledSentences.subList(startTree,endTree),sumGradSquare);
      long totalElapsed=timing.report();
      System.err.println("Finished epoch " + epoch + " batch "+ batch+ "; total training time "+ totalElapsed+ " ms");
      if (maxTrainTimeMillis > 0 && totalElapsed > maxTrainTimeMillis) {
        break;
      }
      if (nextDebugCycle > 0 && totalElapsed > nextDebugCycle) {
        Evaluate eval=new Evaluate(model);
        eval.eval(devTrees);
        eval.printSummary();
        double score=eval.exactNodeAccuracy();
        if (modelPath != null) {
          String tempPath=modelPath;
          if (modelPath.endsWith(".ser.gz")) {
            tempPath=modelPath.substring(0,modelPath.length() - 7) + "-" + FILENAME.format(debugCycle)+ "-"+ NF.format(score)+ ".ser.gz";
          }
 else           if (modelPath.endsWith(".gz")) {
            tempPath=modelPath.substring(0,modelPath.length() - 3) + "-" + FILENAME.format(debugCycle)+ "-"+ NF.format(score)+ ".gz";
          }
 else {
            tempPath=modelPath.substring(0,modelPath.length() - 3) + "-" + FILENAME.format(debugCycle)+ "-"+ NF.format(score);
          }
          model.saveSerialized(tempPath);
        }
        ++debugCycle;
        nextDebugCycle=timing.report() + model.op.trainOptions.debugOutputSeconds * 1000;
      }
    }
    long totalElapsed=timing.report();
    if (maxTrainTimeMillis > 0 && totalElapsed > maxTrainTimeMillis) {
      System.err.println("Max training time exceeded, exiting");
      break;
    }
  }
}
