{
  Treebank tb=new MemoryTreebank();
  Properties props=StringUtils.argsToProperties(args);
  String encoding=props.getProperty("encoding","utf-8");
  try {
    System.setOut(new PrintStream(System.out,true,encoding));
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
  String treeFileName=props.getProperty("treeFile");
  String treeDirname=props.getProperty("treeDir");
  String sentFileName=props.getProperty("sentFile");
  boolean conllx=props.getProperty("conllx") != null;
  boolean basic=props.getProperty("basic") != null;
  boolean nonCollapsed=props.getProperty("nonCollapsed") != null;
  boolean collapsed=props.getProperty("collapsed") != null;
  boolean parseTree=props.getProperty("parseTree") != null;
  boolean keepPunct=props.getProperty("keepPunct") != null;
  if (conllx) {
    keepPunct=true;
  }
  String hf=props.getProperty("hf");
  String parserModel=props.getProperty("parserModel","/u/nlp/data/lexparser/chineseFactored.ser.gz");
  if (!basic && !collapsed) {
    if (conllx) {
      basic=true;
    }
 else {
      collapsed=true;
    }
  }
  try {
    if (hf != null) {
      shf=(HeadFinder)Class.forName(hf).newInstance();
      log.info("Using " + hf);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException("Fail to use HeadFinder: " + hf);
  }
  if (args.length == 0) {
    log.info(String.format("Usage:\n\t%s [optional flags] -treeFile treeFile\n\tor:\n\t%s [optional flags] -sentFile sentFile\n",UniversalChineseGrammaticalStructure.class.getName(),UniversalChineseGrammaticalStructure.class.getName()));
    log.info("Optional flags:");
    log.info("\t-parseTree  : print phrase-structure parse tree");
    log.info("\t-basic : basic non-collapsed dependencies preserving a tree structure");
    log.info("\t-collapsed : collapsed dependencies");
    log.info("\t-conllx : conllx formatted dependencies, can be used with either basic\n\t or collapsed dependencies, but basic is recommended");
  }
 else {
    if (treeDirname != null && treeFileName != null) {
      throw new RuntimeException("Only one of treeDirname or treeFileName should be set");
    }
    if (treeDirname != null) {
      File dir=new File(treeDirname);
      String[] files=dir.list();
      for (      String file : files) {
        AddTreesFromFile(treeDirname + "/" + file,encoding,tb);
      }
    }
 else     if (treeFileName != null) {
      AddTreesFromFile(treeFileName,encoding,tb);
    }
 else     if (sentFileName != null) {
      ViterbiParserWithOptions lp;
      try {
        Class<?>[] classes=new Class<?>[]{String.class};
        Constructor<?> constr=Class.forName("edu.stanford.nlp.parser.lexparser.LexicalizedParser").getConstructor(classes);
        String[] opts={"-retainTmpSubcategories"};
        lp=(ViterbiParserWithOptions)constr.newInstance(parserModel);
        lp.setOptionFlags(opts);
      }
 catch (      Exception cnfe) {
        cnfe.printStackTrace();
        return;
      }
      BufferedReader reader=null;
      try {
        reader=new BufferedReader(new FileReader(sentFileName));
      }
 catch (      FileNotFoundException e) {
        log.info("Cannot find " + sentFileName);
        System.exit(1);
      }
      try {
        System.out.println("Processing sentence file " + sentFileName);
        String line;
        while ((line=reader.readLine()) != null) {
          CHTBTokenizer chtb=new CHTBTokenizer(new StringReader(line));
          List words=chtb.tokenize();
          lp.parse(words);
          Tree tree=lp.getBestParse();
          tb.add(tree);
        }
        reader.close();
      }
 catch (      Exception e) {
        throw new RuntimeException("Exception reading key file " + sentFileName,e);
      }
    }
  }
  for (  Tree t : tb) {
    Predicate<String> puncFilter;
    if (keepPunct) {
      puncFilter=Filters.acceptFilter();
    }
 else {
      puncFilter=new ChineseTreebankLanguagePack().punctuationWordRejectFilter();
    }
    GrammaticalStructure gs=new UniversalChineseGrammaticalStructure(t,puncFilter);
    if (parseTree) {
      System.out.println("============= parse tree =======================");
      t.pennPrint();
    }
    if (basic) {
      if (collapsed || nonCollapsed) {
        System.out.println("------------- basic dependencies ---------------");
      }
      printDependencies(gs,gs.typedDependencies(Extras.NONE),t,conllx,false);
    }
    if (nonCollapsed) {
      if (basic || collapsed) {
        System.out.println("------------- noncollapsed dependencies ---------------");
      }
      printDependencies(gs,gs.typedDependencies(Extras.MAXIMAL),t,conllx,false);
    }
    if (collapsed) {
      if (basic || nonCollapsed) {
        System.out.println("----------- collapsed dependencies -----------");
      }
      printDependencies(gs,gs.typedDependenciesCollapsed(Extras.MAXIMAL),t,conllx,false);
    }
  }
}
