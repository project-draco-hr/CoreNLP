{
  try {
    List<Tree> trees=new ArrayList<Tree>();
    List<List<CoreLabel>> sentences=new ArrayList<List<CoreLabel>>();
    boolean hasSpeakerAnnotations=false;
    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {
      for (      CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
        List<CoreLabel> tokens=sentence.get(CoreAnnotations.TokensAnnotation.class);
        sentences.add(tokens);
        Tree tree=sentence.get(TreeCoreAnnotations.TreeAnnotation.class);
        trees.add(tree);
        SemanticGraph dependencies=SemanticGraphFactory.makeFromTree(tree,Mode.COLLAPSED,Extras.NONE,false,null,true);
        sentence.set(SemanticGraphCoreAnnotations.AlternativeDependenciesAnnotation.class,dependencies);
        if (!hasSpeakerAnnotations) {
          for (          CoreLabel t : tokens) {
            if (t.get(CoreAnnotations.SpeakerAnnotation.class) != null) {
              hasSpeakerAnnotations=true;
              break;
            }
          }
        }
        MentionExtractor.mergeLabels(tree,tokens);
        MentionExtractor.initializeUtterance(tokens);
      }
    }
 else {
      System.err.println("ERROR: this coreference resolution system requires SentencesAnnotation!");
      return;
    }
    if (hasSpeakerAnnotations) {
      annotation.set(CoreAnnotations.UseMarkedDiscourseAnnotation.class,true);
    }
    RuleBasedCorefMentionFinder finder=new RuleBasedCorefMentionFinder(allowReparsing);
    List<List<Mention>> allUnprocessedMentions=finder.extractPredictedMentions(annotation,0,corefSystem.dictionaries());
    Document document=mentionExtractor.arrange(annotation,sentences,trees,allUnprocessedMentions);
    List<List<Mention>> orderedMentions=document.getOrderedMentions();
    if (VERBOSE) {
      for (int i=0; i < orderedMentions.size(); i++) {
        System.err.printf("Mentions in sentence #%d:\n",i);
        for (int j=0; j < orderedMentions.get(i).size(); j++) {
          System.err.println("\tMention #" + j + ": "+ orderedMentions.get(i).get(j).spanToString());
        }
      }
    }
    Map<Integer,CorefChain> result=corefSystem.coref(document);
    annotation.set(CorefCoreAnnotations.CorefChainAnnotation.class,result);
    if (OLD_FORMAT) {
      List<Pair<IntTuple,IntTuple>> links=SieveCoreferenceSystem.getLinks(result);
      if (VERBOSE) {
        System.err.printf("Found %d coreference links:\n",links.size());
        for (        Pair<IntTuple,IntTuple> link : links) {
          System.err.printf("LINK (%d, %d) -> (%d, %d)\n",link.first.get(0),link.first.get(1),link.second.get(0),link.second.get(1));
        }
      }
      List<Pair<IntTuple,IntTuple>> graph=new ArrayList<Pair<IntTuple,IntTuple>>();
      for (      Pair<IntTuple,IntTuple> link : links) {
        int srcSent=link.first.get(0);
        int srcTok=orderedMentions.get(srcSent - 1).get(link.first.get(1) - 1).headIndex + 1;
        int dstSent=link.second.get(0);
        int dstTok=orderedMentions.get(dstSent - 1).get(link.second.get(1) - 1).headIndex + 1;
        IntTuple dst=new IntTuple(2);
        dst.set(0,dstSent);
        dst.set(1,dstTok);
        IntTuple src=new IntTuple(2);
        src.set(0,srcSent);
        src.set(1,srcTok);
        graph.add(new Pair<IntTuple,IntTuple>(src,dst));
      }
      annotation.set(CorefCoreAnnotations.CorefGraphAnnotation.class,graph);
      for (      CorefChain corefChain : result.values()) {
        if (corefChain.getMentionsInTextualOrder().size() < 2)         continue;
        Set<CoreLabel> coreferentTokens=Generics.newHashSet();
        for (        CorefMention mention : corefChain.getMentionsInTextualOrder()) {
          CoreMap sentence=annotation.get(CoreAnnotations.SentencesAnnotation.class).get(mention.sentNum - 1);
          CoreLabel token=sentence.get(CoreAnnotations.TokensAnnotation.class).get(mention.headIndex - 1);
          coreferentTokens.add(token);
        }
        for (        CoreLabel token : coreferentTokens) {
          token.set(CorefCoreAnnotations.CorefClusterAnnotation.class,coreferentTokens);
        }
      }
    }
  }
 catch (  RuntimeException e) {
    throw e;
  }
catch (  Exception e) {
    throw new RuntimeException(e);
  }
}
