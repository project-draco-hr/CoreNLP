{
  word=escapeRegexChars(word);
  if (!TgrepMatcher.subtreeMatches(tree,"(VP.*<(VB.*<<" + word + "))")) {
    return ILLEGAL;
  }
  if (ILLEGAL.matches(tree,word)) {
    return ILLEGAL;
  }
  boolean upgrade2transitive=false;
  if (PASS.matches(tree)) {
    upgrade2transitive=true;
  }
  boolean partUpgrade=false;
  if (PART.matches(tree)) {
    partUpgrade=true;
  }
  for (  Subcategory subcat : SUBCATEGORIES) {
    if (subcat == OTHER) {
      continue;
    }
    if (subcat == PRT) {
      break;
    }
    if (subcat.matches(tree,word)) {
      Subcategory temp;
      if (upgrade2transitive) {
        if (subcat == NULL) {
          temp=NP;
        }
 else         if (subcat == PP) {
          temp=NP_PP;
        }
 else         if (subcat == VP_ING) {
          temp=NP_VP_ING;
        }
 else         if (subcat == VP_TO) {
          temp=NP_VP_TO;
        }
 else         if (subcat == NP) {
          temp=NP_NP;
        }
 else         if (subcat == S) {
          temp=NP_S;
        }
 else {
          temp=subcat;
        }
      }
 else {
        temp=subcat;
      }
      if (partUpgrade) {
        partCounter.incrementCount(temp);
        if (temp == NULL) {
          temp=PRT;
        }
 else         if (temp == NP) {
          temp=NP_PRT;
        }
 else         if (temp == PP) {
          temp=PP_PRT;
        }
 else         if (temp == VP_TO || temp == VP_ING) {
          temp=VP_PRT;
        }
 else         if (temp == S || temp == S_FOR_TO) {
          temp=S_PRT;
        }
 else {
          temp=NP_PRT;
        }
      }
      return temp;
    }
  }
  return OTHER;
}
