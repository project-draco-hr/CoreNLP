{
  int[] nextStates;
  int startsAt=0;
  jjnewStateCnt=26;
  int i=1;
  jjstateSet[0]=startState;
  int j, kind=0x7fffffff;
  for (; ; ) {
    if (++jjround == 0x7fffffff) {
      ReInitRounds();
    }
    if (curChar < 64) {
      long l=1L << curChar;
      MatchLoop:       do {
switch (jjstateSet[--i]) {
case 23:
          if ((0xefffffffffffffffL & l) != 0L) {
            if (kind > 7) {
              kind=7;
            }
            jjCheckNAdd(24);
          }
 else           if (curChar == 60) {
            if (kind > 7) {
              kind=7;
            }
          }
        if (curChar == 60) {
          jjstateSet[jjnewStateCnt++]=0;
        }
      break;
case 0:
    if (curChar == 47) {
      jjAddStates(0,1);
    }
  break;
case 7:
if ((0x100002600L & l) != 0L) {
  jjAddStates(2,3);
}
break;
case 8:
if (curChar == 62 && kind > 6) {
kind=6;
}
break;
case 24:
if ((0xefffffffffffffffL & l) == 0L) {
break;
}
if (kind > 7) {
kind=7;
}
jjCheckNAdd(24);
break;
case 25:
if (curChar == 60 && kind > 7) {
kind=7;
}
break;
default :
break;
}
}
 while (i != startsAt);
}
 else if (curChar < 128) {
long l=1L << (curChar & 077);
MatchLoop: do {
switch (jjstateSet[--i]) {
case 23:
case 24:
if (kind > 7) {
kind=7;
}
jjCheckNAdd(24);
break;
case 1:
if ((0x200000002L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=2;
}
break;
case 2:
if ((0x1000000010000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=3;
}
break;
case 3:
if ((0x1000000010000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=4;
}
break;
case 4:
if ((0x100000001000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=5;
}
break;
case 5:
if ((0x2000000020L & l) != 0L) {
jjCheckNAdd(6);
}
break;
case 6:
if ((0x10000000100000L & l) != 0L) {
jjCheckNAddTwoStates(7,8);
}
break;
case 9:
if ((0x8000000080000L & l) != 0L) {
jjAddStates(4,6);
}
break;
case 10:
if ((0x800000008L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=11;
}
break;
case 11:
if ((0x4000000040000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=12;
}
break;
case 12:
if ((0x20000000200L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=13;
}
break;
case 13:
if ((0x1000000010000L & l) != 0L) {
jjCheckNAdd(6);
}
break;
case 14:
if ((0x2000000020L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=15;
}
break;
case 15:
if ((0x4000000040000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=16;
}
break;
case 16:
if ((0x40000000400000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=17;
}
break;
case 17:
if ((0x2000000020L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=18;
}
break;
case 18:
if ((0x4000000040000L & l) != 0L) {
jjCheckNAddTwoStates(7,8);
}
break;
case 19:
if ((0x10000000100000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=20;
}
break;
case 20:
if ((0x200000002000000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=21;
}
break;
case 21:
if ((0x100000001000L & l) != 0L) {
jjstateSet[jjnewStateCnt++]=22;
}
break;
case 22:
if ((0x2000000020L & l) != 0L) {
jjCheckNAddTwoStates(7,8);
}
break;
default :
break;
}
}
 while (i != startsAt);
}
 else {
int i2=(curChar & 0xff) >> 6;
long l2=1L << (curChar & 077);
MatchLoop: do {
switch (jjstateSet[--i]) {
case 23:
case 24:
if ((jjbitVec0[i2] & l2) == 0L) {
break;
}
if (kind > 7) {
kind=7;
}
jjCheckNAdd(24);
break;
default :
break;
}
}
 while (i != startsAt);
}
if (kind != 0x7fffffff) {
jjmatchedKind=kind;
jjmatchedPos=curPos;
kind=0x7fffffff;
}
++curPos;
if ((i=jjnewStateCnt) == (startsAt=26 - (jjnewStateCnt=startsAt))) {
return curPos;
}
try {
curChar=input_stream.readChar();
}
 catch (java.io.IOException e) {
return curPos;
}
}
}
