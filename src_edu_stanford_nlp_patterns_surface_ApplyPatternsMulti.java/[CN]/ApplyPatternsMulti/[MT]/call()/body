{
  CollectionValuedMap<Integer,Triple<String,Integer,Integer>> matchedTokensByPat=new CollectionValuedMap<Integer,Triple<String,Integer,Integer>>();
  TwoDimensionalCounter<Pair<String,String>,Integer> allFreq=new TwoDimensionalCounter<Pair<String,String>,Integer>();
  for (  String sentid : sentids) {
    List<CoreLabel> sent=sents.get(sentid);
    Iterable<SequenceMatchResult<CoreMap>> matched=multiPatternMatcher.find(sent,SequenceMatcher.FindType.FIND_ALL);
    for (    SequenceMatchResult<CoreMap> m : matched) {
      int s=m.start("$term");
      int e=m.end("$term");
      Integer matchedPat=patterns.get(m.pattern());
      matchedTokensByPat.add(matchedPat,new Triple<String,Integer,Integer>(sentid,s,e));
      String phrase="";
      String phraseLemma="";
      boolean useWordNotLabeled=false;
      boolean doNotUse=false;
      boolean[] addedindices=new boolean[e - s];
      Arrays.fill(addedindices,false);
      for (int i=s; i < e; i++) {
        CoreLabel l=sent.get(i);
        l.set(PatternsAnnotations.MatchedPattern.class,true);
        if (!l.containsKey(PatternsAnnotations.MatchedPatterns.class))         l.set(PatternsAnnotations.MatchedPatterns.class,new HashSet<SurfacePattern>());
        l.get(PatternsAnnotations.MatchedPatterns.class).add(constVars.getPatternIndex().get(matchedPat));
        for (        Entry<Class,Object> ig : constVars.getIgnoreWordswithClassesDuringSelection().get(label).entrySet()) {
          if (l.containsKey(ig.getKey()) && l.get(ig.getKey()).equals(ig.getValue())) {
            doNotUse=true;
          }
        }
        boolean containsStop=containsStopWord(l,constVars.getCommonEngWords(),constVars.ignoreWordRegex);
        if (removePhrasesWithStopWords && containsStop) {
          doNotUse=true;
        }
 else {
          if (!containsStop || !removeStopWordsFromSelectedPhrases) {
            if (label == null || l.get(constVars.getAnswerClass().get(label)) == null || !l.get(constVars.getAnswerClass().get(label)).equals(label.toString())) {
              useWordNotLabeled=true;
            }
            phrase+=" " + l.word();
            phraseLemma+=" " + l.lemma();
            addedindices[i - s]=true;
          }
        }
      }
      for (int i=0; i < addedindices.length; i++) {
        if (i > 0 && i < addedindices.length - 1 && addedindices[i - 1] == true && addedindices[i] == false && addedindices[i + 1] == true) {
          doNotUse=true;
          break;
        }
      }
      if (!doNotUse && useWordNotLabeled) {
        phrase=phrase.trim();
        phraseLemma=phraseLemma.trim();
        allFreq.incrementCount(new Pair<String,String>(phrase,phraseLemma),matchedPat,1.0);
      }
    }
  }
  return new Pair<TwoDimensionalCounter<Pair<String,String>,Integer>,CollectionValuedMap<Integer,Triple<String,Integer,Integer>>>(allFreq,matchedTokensByPat);
}
