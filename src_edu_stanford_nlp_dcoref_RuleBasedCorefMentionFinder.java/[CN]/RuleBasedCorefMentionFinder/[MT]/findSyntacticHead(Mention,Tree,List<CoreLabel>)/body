{
  int endIdx=m.endIndex;
  if (m.originalSpan.size() > 0) {
    String lastWord=m.originalSpan.get(m.originalSpan.size() - 1).get(CoreAnnotations.TextAnnotation.class);
    if ((lastWord.equals("'s") || lastWord.equals("'")) && m.originalSpan.size() != 1)     endIdx--;
  }
  Tree exactMatch=findTreeWithSpan(root,m.startIndex,endIdx);
  if (exactMatch != null) {
    return safeHead(exactMatch,endIdx);
  }
  Tree wordMatch=findTreeWithSmallestSpan(root,m.startIndex,endIdx);
  if (wordMatch != null) {
    Tree head=safeHead(wordMatch,endIdx);
    if (head != null) {
      return head;
    }
  }
  int approximateness=0;
  List<CoreLabel> extentTokens=new ArrayList<CoreLabel>();
  extentTokens.add(initCoreLabel("It"));
  extentTokens.add(initCoreLabel("was"));
  final int ADDED_WORDS=2;
  for (int i=m.startIndex; i < endIdx; i++) {
    CoreLabel label=tokens.get(i);
    if (!"-".equals(label.word())) {
      extentTokens.add(tokens.get(i));
    }
 else {
      approximateness++;
    }
  }
  extentTokens.add(initCoreLabel("."));
  ParserConstraint constraint=new ParserConstraint(ADDED_WORDS,extentTokens.size() - 1,Pattern.compile(".*"));
  List<ParserConstraint> constraints=Collections.singletonList(constraint);
  Tree tree=parse(extentTokens,constraints);
  convertToCoreLabels(tree);
  tree.indexSpans(m.startIndex - ADDED_WORDS);
  Tree subtree=findPartialSpan(tree,m.startIndex);
  Tree extentHead=safeHead(subtree,endIdx);
  assert(extentHead != null);
  CoreLabel l=(CoreLabel)extentHead.label();
  Tree realHead=funkyFindLeafWithApproximateSpan(root,l.value(),l.get(CoreAnnotations.BeginIndexAnnotation.class),approximateness);
  assert(realHead != null);
  return realHead;
}
