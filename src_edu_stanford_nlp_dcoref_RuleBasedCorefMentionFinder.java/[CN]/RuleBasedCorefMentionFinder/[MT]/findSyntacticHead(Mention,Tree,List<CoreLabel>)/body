{
  int endIdx=m.endIndex;
  if (m.originalSpan.size() > 0) {
    String lastWord=m.originalSpan.get(m.originalSpan.size() - 1).get(CoreAnnotations.TextAnnotation.class);
    if ((lastWord.equals("'s") || lastWord.equals("'")) && m.originalSpan.size() != 1)     endIdx--;
  }
  Tree exactMatch=findTreeWithSpan(root,m.startIndex,endIdx);
  if (exactMatch != null) {
    return safeHead(exactMatch,endIdx);
  }
  if (allowReparsing) {
    int approximateness=0;
    List<CoreLabel> extentTokens=new ArrayList<CoreLabel>();
    extentTokens.add(initCoreLabel("It"));
    extentTokens.add(initCoreLabel("was"));
    final int ADDED_WORDS=2;
    for (int i=m.startIndex; i < endIdx; i++) {
      CoreLabel label=tokens.get(i);
      if (!"-".equals(label.word())) {
        extentTokens.add(tokens.get(i));
      }
 else {
        approximateness++;
      }
    }
    extentTokens.add(initCoreLabel("."));
    ParserConstraint constraint=new ParserConstraint(ADDED_WORDS,extentTokens.size() - 1,Pattern.compile(".*"));
    List<ParserConstraint> constraints=Collections.singletonList(constraint);
    Tree tree=parse(extentTokens,constraints);
    convertToCoreLabels(tree);
    tree.indexSpans(m.startIndex - ADDED_WORDS);
    Tree subtree=findPartialSpan(tree,m.startIndex);
    Tree extentHead=safeHead(subtree,endIdx);
    assert(extentHead != null);
    CoreLabel l=(CoreLabel)extentHead.label();
    Tree realHead=funkyFindLeafWithApproximateSpan(root,l.value(),l.get(CoreAnnotations.BeginIndexAnnotation.class),approximateness);
    assert(realHead != null);
    return realHead;
  }
  Tree wordMatch=findTreeWithSmallestSpan(root,m.startIndex,endIdx);
  if (wordMatch != null) {
    Tree head=safeHead(wordMatch,endIdx);
    if (head != null) {
      int index=((CoreLabel)head.label()).get(CoreAnnotations.IndexAnnotation.class) - 1;
      if (index >= m.startIndex && index < endIdx) {
        return head;
      }
    }
  }
  List<Tree> leaves=root.getLeaves();
  Tree endLeaf=leaves.get(endIdx - 1);
  return endLeaf;
}
