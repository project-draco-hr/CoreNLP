{
  int wordIndex=1;
  while (tokenizer.hasNext()) {
    String token=tokenizer.next();
    if (token.equals(leftParen)) {
      String label=(tokenizer.peek().equals(leftParen)) ? null : tokenizer.next();
      if (rightParen.equals(label)) {
        continue;
      }
 else       if (treeNormalizer != null) {
        label=treeNormalizer.normalizeNonterminal(label);
      }
      Tree newTree=treeFactory.newTreeNode(label,null);
      if (currentTree == null)       stack.add(newTree);
 else {
        currentTree.addChild(newTree);
        stack.add(currentTree);
      }
      currentTree=newTree;
    }
 else     if (token.equals(rightParen)) {
      if (stack.isEmpty()) {
        System.err.println("PennTreeReader: warning: file has extra non-matching right parenthesis [ignored]");
        break;
      }
      currentTree=stack.remove(stack.size() - 1);
      if (stack.isEmpty())       return currentTree;
    }
 else {
      if (currentTree == null) {
        break;
      }
      String terminal=(treeNormalizer == null) ? token : treeNormalizer.normalizeTerminal(token);
      Tree leaf=treeFactory.newLeaf(terminal);
      if (leaf.label() instanceof HasIndex) {
        HasIndex hi=(HasIndex)leaf.label();
        hi.setIndex(wordIndex);
      }
      if (leaf.label() instanceof HasWord) {
        HasWord hw=(HasWord)leaf.label();
        hw.setWord(leaf.label().value());
      }
      wordIndex++;
      currentTree.addChild(leaf);
    }
  }
  if (currentTree != null) {
    System.err.println("PennTreeReader: warning: incomplete tree (extra left parentheses in input): " + currentTree);
  }
  return null;
}
