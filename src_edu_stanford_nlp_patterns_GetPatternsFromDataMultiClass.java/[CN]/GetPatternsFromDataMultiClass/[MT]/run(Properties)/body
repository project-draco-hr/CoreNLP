{
  Map<String,Set<E>> ignorePatterns=new HashMap<String,Set<E>>();
  Map<String,E> p0=new HashMap<String,E>();
  Map<String,Counter<String>> p0Set=new HashMap<String,Counter<String>>();
  Map<String,Set<String>> seedWords=readSeedWords(props);
  Map<String,Class> answerClasses=new HashMap<String,Class>();
  String ansClasses=props.getProperty("answerClasses");
  if (ansClasses != null) {
    for (    String l : ansClasses.split(";")) {
      String[] t=l.split(",");
      String label=t[0];
      String cl=t[1];
      Class answerClass=ClassLoader.getSystemClassLoader().loadClass(cl);
      answerClasses.put(label,answerClass);
    }
  }
  Pair<Map<String,DataInstance>,Map<String,DataInstance>> sentsPair=processSents(props,seedWords.keySet());
  boolean learn=Boolean.parseBoolean(props.getProperty("learn","true"));
  boolean labelUsingSeedSets=Boolean.parseBoolean(props.getProperty("labelUsingSeedSets","true"));
  GetPatternsFromDataMultiClass<E> model=new GetPatternsFromDataMultiClass<E>(props,sentsPair.first(),seedWords,labelUsingSeedSets);
  Execution.fillOptions(model,props);
  String sentsOutFile=props.getProperty("sentsOutFile");
  String wordsOutputFile=props.getProperty("wordsOutputFile");
  String patternOutFile=props.getProperty("patternOutFile");
  boolean loadSavedPatternsWordsDir=Boolean.parseBoolean(props.getProperty("loadSavedPatternsWordsDir"));
  boolean labelSentsUsingModel=Boolean.parseBoolean(props.getProperty("labelSentsUsingModel","true"));
  boolean applyPatsUsingModel=Boolean.parseBoolean(props.getProperty("applyPatsUsingModel","true"));
  if (loadSavedPatternsWordsDir) {
    loadFromSavedPatternsWordsDir(model,props,labelSentsUsingModel,applyPatsUsingModel);
  }
  if (learn)   model.iterateExtractApply(p0,p0Set,wordsOutputFile,sentsOutFile,patternOutFile,ignorePatterns);
  if (model.constVars.markedOutputTextFile != null) {
    model.writeLabeledData(model.constVars.markedOutputTextFile);
  }
  if (model.constVars.columnOutputFile != null)   model.writeColumnOutput(model.constVars.columnOutputFile);
  boolean savePatternsWordsDir=Boolean.parseBoolean(props.getProperty("savePatternsWordsDir"));
  if (savePatternsWordsDir) {
    String patternsWordsDir=props.getProperty("patternsWordsDir");
    for (    String label : model.constVars.getLabels()) {
      IOUtils.ensureDir(new File(patternsWordsDir + "/" + label));
      Counter<E> pats=model.getLearnedPatterns(label);
      IOUtils.writeObjectToFile(pats,patternsWordsDir + "/" + label+ "/patterns.ser");
      BufferedWriter w=new BufferedWriter(new FileWriter(patternsWordsDir + "/" + label+ "/phrases.txt"));
      model.writeWordsToFile(model.constVars.getLearnedWords(label),w);
      w.close();
    }
  }
  boolean evaluate=Boolean.parseBoolean(props.getProperty("evaluate"));
  if (evaluate) {
    String goldEntitiesEvalFiles=props.getProperty("goldEntitiesEvalFiles");
    if (goldEntitiesEvalFiles != null) {
      for (      String gfile : goldEntitiesEvalFiles.split(";")) {
        String[] t=gfile.split(",");
        String label=t[0];
        String goldfile=t[1];
        Map<String,Boolean> goldWords4Label=new HashMap<String,Boolean>();
        for (        String line : IOUtils.readLines(goldfile)) {
          line=line.trim();
          if (line.isEmpty())           continue;
          if (line.endsWith("#"))           goldWords4Label.put(line.substring(0,line.length() - 1),false);
 else           goldWords4Label.put(line,true);
        }
        Pair<Double,Double> pr=model.getPrecisionRecall(label,goldWords4Label);
        Redwood.log(ConstantsAndVariables.minimaldebug,"\nFor label " + label + ": Number of gold entities is "+ goldWords4Label.size()+ ", Precision is "+ model.df.format(pr.first() * 100)+ ", Recall is "+ model.df.format(pr.second() * 100)+ ", F1 is "+ model.df.format(model.FScore(pr.first(),pr.second(),1.0) * 100)+ "\n\n");
      }
    }
    Map<String,DataInstance> evalsents=sentsPair.second();
    if (evalsents.size() > 0) {
      boolean evalPerEntity=Boolean.parseBoolean(props.getProperty("evalPerEntity","true"));
      model.evaluate(evalsents,evalPerEntity);
    }
    if (evalsents.size() == 0 && goldEntitiesEvalFiles == null)     System.err.println("No eval sentences or list of gold entities provided to evaluate! Make sure evalFileWithGoldLabels or goldEntitiesEvalFiles is set, or turn off the evaluate flag");
  }
  if (model.constVars.saveInvertedIndex) {
    model.constVars.invertedIndex.saveIndex(model.constVars.invertedIndexDirectory);
  }
  if (model.constVars.storePatsForEachToken.equals(ConstantsAndVariables.PatternForEachTokenWay.LUCENE)) {
    model.patsForEachToken.close();
  }
  return model;
}
