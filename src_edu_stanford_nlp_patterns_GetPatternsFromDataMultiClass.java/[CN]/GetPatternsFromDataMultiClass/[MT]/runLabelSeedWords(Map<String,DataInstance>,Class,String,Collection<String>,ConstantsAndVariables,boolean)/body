{
  Function<CoreLabel,String> stringTransformationFunction=new Function<CoreLabel,String>(){
    @Override public String apply(    CoreLabel l){
      String s;
      if (PatternFactory.useLemmaContextTokens)       s=l.lemma();
 else       s=l.word();
      if (constVars.matchLowerCaseContext)       s=s.toLowerCase();
      return s;
    }
  }
;
  List<String> keyset=new ArrayList<String>(sents.keySet());
  Redwood.log(Redwood.DBG,"Labeling " + keyset.size() + " sentences with "+ seedWords.size()+ " seeds for the label "+ label);
  int num;
  if (constVars.numThreads == 1)   num=keyset.size();
 else   num=keyset.size() / (constVars.numThreads - 1);
  ExecutorService executor=Executors.newFixedThreadPool(constVars.numThreads);
  Redwood.log(ConstantsAndVariables.extremedebug,"keyset size is " + keyset.size());
  List<Future<Map<String,DataInstance>>> list=new ArrayList<Future<Map<String,DataInstance>>>();
  for (int i=0; i < constVars.numThreads; i++) {
    List<String> keys=keyset.subList(i * num,Math.min(keyset.size(),(i + 1) * num));
    Redwood.log(ConstantsAndVariables.extremedebug,"assigning from " + i * num + " till " + Math.min(keyset.size(),(i + 1) * num));
    Callable<Map<String,DataInstance>> task=new LabelWithSeedWords(seedWords,sents,keys,answerclass,label,constVars.minLen4FuzzyForPattern,constVars.backgroundSymbol,constVars.getEnglishWords(),stringTransformationFunction,constVars.writeMatchedTokensIdsForEachPhrase,overwriteExistingLabels);
    Future<Map<String,DataInstance>> submit=executor.submit(task);
    list.add(submit);
  }
  for (  Future<Map<String,DataInstance>> future : list) {
    try {
      sents.putAll(future.get());
    }
 catch (    Exception e) {
      executor.shutdownNow();
      throw new RuntimeException(e);
    }
  }
  executor.shutdown();
}
