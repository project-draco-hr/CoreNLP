{
  this(r);
  this.tokenFactory=tf;
  if (options == null) {
    options="";
  }
  Properties prop=StringUtils.stringToProperties(options);
  Set<Map.Entry<Object,Object>> props=prop.entrySet();
  for (  Map.Entry<Object,Object> item : props) {
    String key=(String)item.getKey();
    String value=(String)item.getValue();
    boolean val=Boolean.valueOf(value);
switch (key) {
case "":
      break;
case "invertible":
    invertible=val;
  break;
case "tokenizeNLs":
tokenizeNLs=val;
break;
case "ptb3Escaping":
normalizeSpace=val;
normalizeAmpersandEntity=val;
normalizeCurrency=val;
normalizeFractions=val;
normalizeParentheses=val;
normalizeOtherBrackets=val;
latexQuotes=val;
unicodeQuotes=val;
asciiQuotes=val;
ptb3Ellipsis=val;
unicodeEllipsis=val;
ptb3Dashes=val;
break;
case "americanize":
americanize=val;
break;
case "normalizeSpace":
normalizeSpace=val;
break;
case "normalizeAmpersandEntity":
normalizeAmpersandEntity=val;
break;
case "normalizeCurrency":
normalizeCurrency=val;
break;
case "normalizeFractions":
normalizeFractions=val;
break;
case "normalizeParentheses":
normalizeParentheses=val;
break;
case "normalizeOtherBrackets":
normalizeOtherBrackets=val;
break;
case "latexQuotes":
latexQuotes=val;
break;
case "unicodeQuotes":
unicodeQuotes=val;
if (val) {
latexQuotes=false;
}
break;
case "asciiQuotes":
asciiQuotes=val;
if (val) {
latexQuotes=false;
unicodeQuotes=false;
}
break;
case "splitAssimilations":
splitAssimilations=val;
break;
case "ptb3Ellipsis":
ptb3Ellipsis=val;
break;
case "unicodeEllipsis":
unicodeEllipsis=val;
break;
case "ptb3Dashes":
ptb3Dashes=val;
break;
case "escapeForwardSlashAsterisk":
escapeForwardSlashAsterisk=val;
break;
case "untokenizable":
if (value.equals("noneDelete")) {
untokenizable=UntokenizableOptions.NONE_DELETE;
}
 else if (value.equals("firstDelete")) {
untokenizable=UntokenizableOptions.FIRST_DELETE;
}
 else if (value.equals("allDelete")) {
untokenizable=UntokenizableOptions.ALL_DELETE;
}
 else if (value.equals("noneKeep")) {
untokenizable=UntokenizableOptions.NONE_KEEP;
}
 else if (value.equals("firstKeep")) {
untokenizable=UntokenizableOptions.FIRST_KEEP;
}
 else if (value.equals("allKeep")) {
untokenizable=UntokenizableOptions.ALL_KEEP;
}
 else {
throw new IllegalArgumentException("PTBLexer: Invalid option value in constructor: " + key + ": "+ value);
}
break;
case "strictTreebank3":
strictTreebank3=val;
break;
default :
throw new IllegalArgumentException("PTBLexer: Invalid options key in constructor: " + key);
}
}
if (invertible) {
if (!(tf instanceof CoreLabelTokenFactory)) {
throw new IllegalArgumentException("PTBLexer: the invertible option requires a CoreLabelTokenFactory");
}
prevWord=(CoreLabel)tf.makeToken("",0,0);
prevWordAfter=new StringBuilder();
}
if (strictTreebank3) {
yybegin(YyStrictlyTreebank3);
}
 else {
yybegin(YyTraditionalTreebank3);
}
}
