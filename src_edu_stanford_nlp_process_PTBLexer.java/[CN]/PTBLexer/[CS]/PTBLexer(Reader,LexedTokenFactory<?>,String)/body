{
  this(r);
  this.tokenFactory=tf;
  if (options == null) {
    options="";
  }
  Properties prop=StringUtils.stringToProperties(options);
  Set<Map.Entry<Object,Object>> props=prop.entrySet();
  for (  Map.Entry<Object,Object> item : props) {
    String key=(String)item.getKey();
    String value=(String)item.getValue();
    boolean val=Boolean.valueOf(value);
    if ("".equals(key)) {
    }
 else     if ("invertible".equals(key)) {
      invertible=val;
    }
 else     if ("tokenizeNLs".equals(key)) {
      tokenizeNLs=val;
    }
 else     if ("ptb3Escaping".equals(key)) {
      americanize=val;
      normalizeSpace=val;
      normalizeAmpersandEntity=val;
      normalizeCurrency=val;
      normalizeFractions=val;
      normalizeParentheses=val;
      normalizeOtherBrackets=val;
      latexQuotes=val;
      unicodeQuotes=val;
      asciiQuotes=val;
      ptb3Ellipsis=val;
      unicodeEllipsis=val;
      ptb3Dashes=val;
      escapeForwardSlashAsterisk=val;
    }
 else     if ("americanize".equals(key)) {
      americanize=val;
    }
 else     if ("normalizeSpace".equals(key)) {
      normalizeSpace=val;
    }
 else     if ("normalizeAmpersandEntity".equals(key)) {
      normalizeAmpersandEntity=val;
    }
 else     if ("normalizeCurrency".equals(key)) {
      normalizeCurrency=val;
    }
 else     if ("normalizeFractions".equals(key)) {
      normalizeFractions=val;
    }
 else     if ("normalizeParentheses".equals(key)) {
      normalizeParentheses=val;
    }
 else     if ("normalizeOtherBrackets".equals(key)) {
      normalizeOtherBrackets=val;
    }
 else     if ("latexQuotes".equals(key)) {
      latexQuotes=val;
    }
 else     if ("unicodeQuotes".equals(key)) {
      unicodeQuotes=val;
      if (val) {
        latexQuotes=false;
      }
    }
 else     if ("asciiQuotes".equals(key)) {
      asciiQuotes=val;
      if (val) {
        latexQuotes=false;
        unicodeQuotes=false;
      }
    }
 else     if ("splitAssimilations".equals(key)) {
      splitAssimilations=val;
    }
 else     if ("ptb3Ellipsis".equals(key)) {
      ptb3Ellipsis=val;
    }
 else     if ("unicodeEllipsis".equals(key)) {
      unicodeEllipsis=val;
    }
 else     if ("ptb3Dashes".equals(key)) {
      ptb3Dashes=val;
    }
 else     if ("escapeForwardSlashAsterisk".equals(key)) {
      escapeForwardSlashAsterisk=val;
    }
 else     if ("untokenizable".equals(key)) {
      if (value.equals("noneDelete")) {
        untokenizable=UntokenizableOptions.NONE_DELETE;
      }
 else       if (value.equals("firstDelete")) {
        untokenizable=UntokenizableOptions.FIRST_DELETE;
      }
 else       if (value.equals("allDelete")) {
        untokenizable=UntokenizableOptions.ALL_DELETE;
      }
 else       if (value.equals("noneKeep")) {
        untokenizable=UntokenizableOptions.NONE_KEEP;
      }
 else       if (value.equals("firstKeep")) {
        untokenizable=UntokenizableOptions.FIRST_KEEP;
      }
 else       if (value.equals("allKeep")) {
        untokenizable=UntokenizableOptions.ALL_KEEP;
      }
 else {
        throw new IllegalArgumentException("PTBLexer: Invalid option value in constructor: " + key + ": "+ value);
      }
    }
 else     if ("strictTreebank3".equals(key)) {
      strictTreebank3=val;
    }
 else {
      throw new IllegalArgumentException("PTBLexer: Invalid options key in constructor: " + key);
    }
  }
  if (invertible) {
    if (!(tf instanceof CoreLabelTokenFactory)) {
      throw new IllegalArgumentException("PTBLexer: the invertible option requires a CoreLabelTokenFactory");
    }
    prevWord=(CoreLabel)tf.makeToken("",0,0);
    prevWordAfter=new StringBuilder();
  }
  if (strictTreebank3) {
    yybegin(YyStrictlyTreebank3);
  }
 else {
    yybegin(YyTraditionalTreebank3);
  }
}
