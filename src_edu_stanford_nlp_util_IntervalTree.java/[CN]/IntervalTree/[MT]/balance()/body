{
  Stack<IntervalTree<E,T>> todo=new Stack<IntervalTree<E,T>>();
  todo.add(this);
  while (!todo.isEmpty()) {
    IntervalTree<E,T> node=todo.pop();
    int medianAt=node.size / 2;
    IntervalTree<E,T> median=node.getNode(medianAt);
    if (median != null && median != node) {
      int leftSize=(node.left != null) ? node.left.size() : 0;
      int rightSize=(node.right != null) ? node.right.size() : 0;
      IntervalTree<E,T> copy=new IntervalTree<E,T>();
      copy.left=node.left;
      copy.right=node.right;
      copy.value=node.value;
      if (copy.left != null)       copy.left.parent=copy;
      if (copy.right != null)       copy.right.parent=copy;
      node.value=median.value;
      node.left=median.left;
      node.right=median.right;
      if (node.left != null)       node.left.parent=node;
      if (node.right != null)       node.right.parent=node;
      IntervalTree<E,T> mparent=median.parent;
      median.parent=null;
      if (mparent != null) {
        if (mparent.left == median) {
          mparent.left=null;
        }
 else         if (mparent.right == median) {
          mparent.right=null;
        }
        adjustUpwards(mparent,node);
      }
      if (medianAt < leftSize) {
        IntervalTree<E,T> rightmost=node.getRightmostNode();
        rightmost.right=copy;
        copy.parent=rightmost;
        adjustUpwards(rightmost.right,node);
      }
 else       if (medianAt > leftSize) {
        IntervalTree<E,T> leftmost=node.getLeftmostNode();
        leftmost.left=copy;
        copy.parent=leftmost;
        adjustUpwards(leftmost.left,node);
      }
 else       if (medianAt == leftSize) {
        throw new RuntimeException("Shouldn't be here...");
      }
    }
    if (node.left != null)     todo.push(node.left);
    if (node.right != null)     todo.push(node.right);
  }
}
