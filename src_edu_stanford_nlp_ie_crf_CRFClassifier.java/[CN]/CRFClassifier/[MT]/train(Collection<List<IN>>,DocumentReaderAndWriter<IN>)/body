{
  Timing timer=new Timing();
  timer.start();
  Collection<List<IN>> docs=new ArrayList<List<IN>>();
  for (  List<IN> doc : objectBankWrapper) {
    docs.add(doc);
  }
  if (flags.numOfSlices > 0) {
    System.err.println("Taking " + flags.numOfSlices + " out of "+ flags.totalDataSlice+ " slices of data for training");
    List<List<IN>> docsToShuffle=new ArrayList<List<IN>>();
    for (    List<IN> doc : docs) {
      docsToShuffle.add(doc);
    }
    Collections.shuffle(docsToShuffle,random);
    int cutOff=(int)(docsToShuffle.size() / (flags.totalDataSlice + 0.0) * flags.numOfSlices);
    docs=docsToShuffle.subList(0,cutOff);
  }
  List<List<IN>> unsupDocs=null;
  if (flags.unsupDropoutFile != null) {
    System.err.println("Reading unsupervised dropout data from file: " + flags.unsupDropoutFile);
    timer.start();
    unsupDocs=new ArrayList<List<IN>>();
    ObjectBank<List<IN>> unsupObjBank=makeObjectBankFromFile(flags.unsupDropoutFile,readerAndWriter);
    for (    List<IN> doc : unsupObjBank) {
      for (      IN tok : doc) {
        tok.set(CoreAnnotations.AnswerAnnotation.class,flags.backgroundSymbol);
        tok.set(CoreAnnotations.GoldAnswerAnnotation.class,flags.backgroundSymbol);
      }
      unsupDocs.add(doc);
    }
  }
  List<List<IN>> totalDocs=new ArrayList<List<IN>>();
  totalDocs.addAll(docs);
  if (flags.doFeatureDiscovery && unsupDocs != null)   totalDocs.addAll(unsupDocs);
  makeAnswerArraysAndTagIndex(totalDocs);
  long elapsedMs=timer.stop();
  System.err.println("Time to convert docs to feature indices: " + Timing.toSecondsString(elapsedMs) + " seconds");
  if (flags.serializeClassIndexTo != null) {
    timer.start();
    serializeClassIndex(flags.serializeClassIndexTo);
    elapsedMs=timer.stop();
    System.err.println("Time to export class index : " + Timing.toSecondsString(elapsedMs) + " seconds");
  }
  if (flags.exportFeatures != null) {
    timer.start();
    CRFFeatureExporter<IN> featureExporter=new CRFFeatureExporter<IN>(this);
    featureExporter.printFeatures(flags.exportFeatures,docs);
    elapsedMs=timer.stop();
    System.err.println("Time to export features: " + Timing.toSecondsString(elapsedMs) + " seconds");
  }
  for (int i=0; i <= flags.numTimesPruneFeatures; i++) {
    timer.start();
    Triple<int[][][][],int[][],double[][][][]> dataAndLabelsAndFeatureVals=documentsToDataAndLabels(docs);
    elapsedMs=timer.stop();
    System.err.println("Time to convert docs to data/labels: " + Timing.toSecondsString(elapsedMs) + " seconds");
    Evaluator[] evaluators=null;
    if (flags.evaluateIters > 0 || flags.terminateOnEvalImprovement) {
      List<Evaluator> evaluatorList=new ArrayList<Evaluator>();
      if (flags.useMemoryEvaluator)       evaluatorList.add(new MemoryEvaluator());
      if (flags.evaluateTrain) {
        CRFClassifierEvaluator<IN> crfEvaluator=new CRFClassifierEvaluator<IN>("Train set",this);
        List<Triple<int[][][],int[],double[][][]>> trainDataAndLabels=new ArrayList<Triple<int[][][],int[],double[][][]>>();
        int[][][][] data=dataAndLabelsAndFeatureVals.first();
        int[][] labels=dataAndLabelsAndFeatureVals.second();
        double[][][][] featureVal=dataAndLabelsAndFeatureVals.third();
        for (int j=0; j < data.length; j++) {
          Triple<int[][][],int[],double[][][]> p=new Triple<int[][][],int[],double[][][]>(data[j],labels[j],featureVal[j]);
          trainDataAndLabels.add(p);
        }
        crfEvaluator.setTestData(docs,trainDataAndLabels);
        if (flags.evalCmd.length() > 0)         crfEvaluator.setEvalCmd(flags.evalCmd);
        evaluatorList.add(crfEvaluator);
      }
      if (flags.testFile != null) {
        CRFClassifierEvaluator<IN> crfEvaluator=new CRFClassifierEvaluator<IN>("Test set (" + flags.testFile + ")",this);
        ObjectBank<List<IN>> testObjBank=makeObjectBankFromFile(flags.testFile,readerAndWriter);
        List<List<IN>> testDocs=new ArrayList<List<IN>>();
        for (        List<IN> doc : testObjBank) {
          testDocs.add(doc);
        }
        List<Triple<int[][][],int[],double[][][]>> testDataAndLabels=documentsToDataAndLabelsList(testDocs);
        crfEvaluator.setTestData(testDocs,testDataAndLabels);
        if (flags.evalCmd.length() > 0)         crfEvaluator.setEvalCmd(flags.evalCmd);
        evaluatorList.add(crfEvaluator);
      }
      if (flags.testFiles != null) {
        String[] testFiles=flags.testFiles.split(",");
        for (        String testFile : testFiles) {
          CRFClassifierEvaluator<IN> crfEvaluator=new CRFClassifierEvaluator<IN>("Test set (" + testFile + ")",this);
          ObjectBank<List<IN>> testObjBank=makeObjectBankFromFile(testFile,readerAndWriter);
          List<Triple<int[][][],int[],double[][][]>> testDataAndLabels=documentsToDataAndLabelsList(testObjBank);
          crfEvaluator.setTestData(testObjBank,testDataAndLabels);
          if (flags.evalCmd.length() > 0)           crfEvaluator.setEvalCmd(flags.evalCmd);
          evaluatorList.add(crfEvaluator);
        }
      }
      evaluators=new Evaluator[evaluatorList.size()];
      evaluatorList.toArray(evaluators);
    }
    if (flags.numTimesPruneFeatures == i) {
      docs=null;
    }
    File featIndexFile=null;
    int numFeatures=featureIndex.size();
    if (flags.saveFeatureIndexToDisk) {
      try {
        System.err.println("Writing feature index to temporary file.");
        featIndexFile=IOUtils.writeObjectToTempFile(featureIndex,"featIndex" + i + ".tmp");
      }
 catch (      IOException e) {
        throw new RuntimeException("Could not open temporary feature index file for writing.");
      }
    }
    int[][][][] data=dataAndLabelsAndFeatureVals.first();
    int[][] labels=dataAndLabelsAndFeatureVals.second();
    double[][][][] featureVals=dataAndLabelsAndFeatureVals.third();
    if (flags.loadProcessedData != null) {
      List<List<CRFDatum<Collection<String>,String>>> processedData=loadProcessedData(flags.loadProcessedData);
      if (processedData != null) {
        int[][][][] allData=new int[data.length + processedData.size()][][][];
        double[][][][] allFeatureVals=new double[featureVals.length + processedData.size()][][][];
        int[][] allLabels=new int[labels.length + processedData.size()][];
        System.arraycopy(data,0,allData,0,data.length);
        System.arraycopy(labels,0,allLabels,0,labels.length);
        System.arraycopy(featureVals,0,allFeatureVals,0,featureVals.length);
        addProcessedData(processedData,allData,allLabels,allFeatureVals,data.length);
        data=allData;
        labels=allLabels;
        featureVals=allFeatureVals;
      }
    }
    int[][][][] unsupDropoutData=null;
    if (flags.unsupDropoutFile != null) {
      List<Triple<int[][][],int[],double[][][]>> unsupDataAndLabels=documentsToDataAndLabelsList(unsupDocs);
      unsupDropoutData=new int[unsupDataAndLabels.size()][][][];
      for (int q=0; q < unsupDropoutData.length; q++)       unsupDropoutData[q]=unsupDataAndLabels.get(q).first();
      elapsedMs=timer.stop();
      System.err.println("Time to read unsupervised dropout data: " + Timing.toSecondsString(elapsedMs) + " seconds, read "+ unsupDropoutData.length+ " files");
    }
    if (flags.nonLinearCRF) {
      if (flags.secondOrderNonLinear) {
        CRFNonLinearSecondOrderLogConditionalObjectiveFunction func=new CRFNonLinearSecondOrderLogConditionalObjectiveFunction(data,labels,windowSize,classIndex,labelIndices,map,flags,nodeFeatureIndicesMap.size(),edgeFeatureIndicesMap.size());
        cliquePotentialFunctionHelper=func;
        double[] allWeights=trainWeightsUsingNonLinearCRF(func,evaluators);
        Quadruple<double[][],double[][],double[][],double[][]> params=func.separateWeights(allWeights);
        this.inputLayerWeights4Edge=params.first();
        this.outputLayerWeights4Edge=params.second();
        this.inputLayerWeights=params.third();
        this.outputLayerWeights=params.fourth();
        System.err.println("Edge Output Layer Weights:");
        for (int ii=0; ii < outputLayerWeights4Edge.length; ii++) {
          System.err.print("[ ");
          for (int jj=0; jj < outputLayerWeights4Edge[ii].length; jj++) {
            System.err.print(outputLayerWeights4Edge[ii][jj] + " ");
          }
          System.err.println("]");
        }
        System.err.println("Node Output Layer Weights:");
        for (int ii=0; ii < outputLayerWeights.length; ii++) {
          System.err.print("[ ");
          for (int jj=0; jj < outputLayerWeights[ii].length; jj++) {
            System.err.print(outputLayerWeights[ii][jj] + " ");
          }
          System.err.println("]");
        }
      }
 else {
        CRFNonLinearLogConditionalObjectiveFunction func=new CRFNonLinearLogConditionalObjectiveFunction(data,labels,windowSize,classIndex,labelIndices,map,flags,nodeFeatureIndicesMap.size(),edgeFeatureIndicesMap.size(),featureVals);
        if (flags.useAdaGradFOBOS) {
          func.gradientsOnly=true;
        }
        cliquePotentialFunctionHelper=func;
        double[] allWeights=trainWeightsUsingNonLinearCRF(func,evaluators);
        Triple<double[][],double[][],double[][]> params=func.separateWeights(allWeights);
        this.linearWeights=params.first();
        this.inputLayerWeights=params.second();
        this.outputLayerWeights=params.third();
        if (flags.printWeights) {
          System.err.println("Linear Layer Weights:");
          for (int ii=0; ii < linearWeights.length; ii++) {
            System.err.print("[ ");
            for (int jj=0; jj < linearWeights[ii].length; jj++) {
              System.err.print(linearWeights[ii][jj] + " ");
            }
            System.err.println("]");
          }
          System.err.println("Input Layer Weights:");
          for (int ii=0; ii < inputLayerWeights.length; ii++) {
            System.err.print("[ ");
            for (int jj=0; jj < inputLayerWeights[ii].length; jj++) {
              System.err.print(inputLayerWeights[ii][jj] + " ");
            }
            System.err.println("]");
          }
          System.err.println("Output Layer Weights:");
          for (int ii=0; ii < outputLayerWeights.length; ii++) {
            System.err.print("[ ");
            for (int jj=0; jj < outputLayerWeights[ii].length; jj++) {
              System.err.print(outputLayerWeights[ii][jj] + " ");
            }
            System.err.println("]");
          }
        }
      }
    }
 else {
      double[] oneDimWeights=null;
      if (flags.useFloat) {
        oneDimWeights=trainWeightsUsingFloatCRF(data,labels,i);
      }
 else       if (flags.numLopExpert > 1) {
        oneDimWeights=trainWeightsUsingLopCRF(numFeatures,data,labels,evaluators,i);
      }
 else {
        oneDimWeights=trainWeightsUsingDoubleCRF(data,labels,evaluators,i,featureVals,unsupDropoutData);
      }
      this.weights=to2D(oneDimWeights,labelIndices,map);
    }
    if (flags.saveFeatureIndexToDisk) {
      try {
        System.err.println("Reading temporary feature index file.");
        featureIndex=(Index<String>)IOUtils.readObjectFromFile(featIndexFile);
      }
 catch (      Exception e) {
        throw new RuntimeException("Could not open temporary feature index file for reading.");
      }
    }
    if (i != flags.numTimesPruneFeatures) {
      dropFeaturesBelowThreshold(flags.featureDiffThresh);
      System.err.println("Removing features with weight below " + flags.featureDiffThresh + " and retraining...");
    }
  }
}
