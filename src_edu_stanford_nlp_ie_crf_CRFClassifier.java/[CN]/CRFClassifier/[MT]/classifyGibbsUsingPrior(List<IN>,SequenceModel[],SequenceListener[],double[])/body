{
  if ((priorModels.length + 1) != modelWts.length)   throw new RuntimeException("modelWts array should be longer than the priorModels array by 1 unit since it also includes the weight of the CRF model at position 0.");
  Triple<int[][][],int[],double[][][]> p=documentToDataAndLabels(sentence);
  List<IN> newDocument=sentence;
  if (flags.useReverse) {
    Collections.reverse(sentence);
    newDocument=new ArrayList<IN>(sentence);
    Collections.reverse(sentence);
  }
  CRFCliqueTree<String> cliqueTree=getCliqueTree(p);
  SequenceModel model=cliqueTree;
  SequenceListener listener=cliqueTree;
  SequenceModel[] models=new SequenceModel[priorModels.length + 1];
  models[0]=model;
  for (int i=1; i < models.length; i++)   models[i]=priorModels[i - 1];
  model=new FactoredSequenceModel(models,modelWts);
  SequenceListener[] listeners=new SequenceListener[priorListeners.length + 1];
  listeners[0]=listener;
  for (int i=1; i < listeners.length; i++)   listeners[i]=priorListeners[i - 1];
  listener=new FactoredSequenceListener(listeners);
  SequenceGibbsSampler sampler=new SequenceGibbsSampler(0,0,listener);
  int[] sequence=new int[cliqueTree.length()];
  if (flags.initViterbi) {
    TestSequenceModel testSequenceModel=new TestSequenceModel(cliqueTree);
    ExactBestSequenceFinder tagInference=new ExactBestSequenceFinder();
    int[] bestSequence=tagInference.bestSequence(testSequenceModel);
    System.arraycopy(bestSequence,windowSize - 1,sequence,0,sequence.length);
  }
 else {
    int[] initialSequence=SequenceGibbsSampler.getRandomSequence(model);
    System.arraycopy(initialSequence,0,sequence,0,sequence.length);
  }
  SequenceGibbsSampler.verbose=0;
  if (flags.annealingType.equalsIgnoreCase("linear")) {
    sequence=sampler.findBestUsingAnnealing(model,CoolingSchedule.getLinearSchedule(1.0,flags.numSamples),sequence);
  }
 else   if (flags.annealingType.equalsIgnoreCase("exp") || flags.annealingType.equalsIgnoreCase("exponential")) {
    sequence=sampler.findBestUsingAnnealing(model,CoolingSchedule.getExponentialSchedule(1.0,flags.annealingRate,flags.numSamples),sequence);
  }
 else {
    throw new RuntimeException("No annealing type specified");
  }
  if (flags.useReverse) {
    Collections.reverse(sentence);
  }
  for (int j=0, dsize=newDocument.size(); j < dsize; j++) {
    IN wi=sentence.get(j);
    if (wi == null)     throw new RuntimeException("");
    if (classIndex == null)     throw new RuntimeException("");
    wi.set(CoreAnnotations.AnswerAnnotation.class,classIndex.get(sequence[j]));
  }
  if (flags.useReverse) {
    Collections.reverse(sentence);
  }
  return sentence;
}
