{
  Triple<int[][][],int[],double[][][]> p=documentDataAndLabels;
  List<IN> newDocument=document;
  if (flags.useReverse) {
    Collections.reverse(document);
    newDocument=new ArrayList<IN>(document);
    Collections.reverse(document);
  }
  CRFCliqueTree<? extends CharSequence> cliqueTree=getCliqueTree(p);
  SequenceModel model=cliqueTree;
  SequenceListener listener=cliqueTree;
  SequenceModel priorModel=null;
  SequenceListener priorListener=null;
  if (flags.useNERPrior) {
    EntityCachingAbstractSequencePrior<IN> prior=new EmpiricalNERPrior<IN>(flags.backgroundSymbol,classIndex,newDocument);
    priorModel=prior;
    priorListener=prior;
  }
 else   if (flags.useAcqPrior) {
    EntityCachingAbstractSequencePrior<IN> prior=new AcquisitionsPrior<IN>(flags.backgroundSymbol,classIndex,newDocument);
    priorModel=prior;
    priorListener=prior;
  }
 else   if (flags.useSemPrior) {
    EntityCachingAbstractSequencePrior<IN> prior=new SeminarsPrior<IN>(flags.backgroundSymbol,classIndex,newDocument);
    priorModel=prior;
    priorListener=prior;
  }
 else   if (flags.useUniformPrior) {
    UniformPrior<IN> uniPrior=new UniformPrior<IN>(flags.backgroundSymbol,classIndex,newDocument);
    priorModel=uniPrior;
    priorListener=uniPrior;
  }
 else {
    throw new RuntimeException("no prior specified");
  }
  model=new FactoredSequenceModel(model,priorModel);
  listener=new FactoredSequenceListener(listener,priorListener);
  SequenceGibbsSampler sampler=new SequenceGibbsSampler(0,0,listener);
  int[] sequence=new int[cliqueTree.length()];
  if (flags.initViterbi) {
    TestSequenceModel testSequenceModel=new TestSequenceModel(cliqueTree);
    ExactBestSequenceFinder tagInference=new ExactBestSequenceFinder();
    int[] bestSequence=tagInference.bestSequence(testSequenceModel);
    System.arraycopy(bestSequence,windowSize - 1,sequence,0,sequence.length);
  }
 else {
    int[] initialSequence=SequenceGibbsSampler.getRandomSequence(model);
    System.arraycopy(initialSequence,0,sequence,0,sequence.length);
  }
  sampler.verbose=0;
  if (flags.annealingType.equalsIgnoreCase("linear")) {
    sequence=sampler.findBestUsingAnnealing(model,CoolingSchedule.getLinearSchedule(1.0,flags.numSamples),sequence);
  }
 else   if (flags.annealingType.equalsIgnoreCase("exp") || flags.annealingType.equalsIgnoreCase("exponential")) {
    sequence=sampler.findBestUsingAnnealing(model,CoolingSchedule.getExponentialSchedule(1.0,flags.annealingRate,flags.numSamples),sequence);
  }
 else {
    throw new RuntimeException("No annealing type specified");
  }
  if (flags.useReverse) {
    Collections.reverse(document);
  }
  for (int j=0, dsize=newDocument.size(); j < dsize; j++) {
    IN wi=document.get(j);
    if (wi == null)     throw new RuntimeException("");
    if (classIndex == null)     throw new RuntimeException("");
    wi.set(AnswerAnnotation.class,classIndex.get(sequence[j]));
  }
  if (flags.useReverse) {
    Collections.reverse(document);
  }
  return document;
}
