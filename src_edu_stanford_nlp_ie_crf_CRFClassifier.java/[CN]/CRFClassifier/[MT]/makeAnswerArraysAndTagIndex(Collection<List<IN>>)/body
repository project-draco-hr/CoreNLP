{
  Set<String>[] featureIndices=new HashSet[windowSize];
  for (int i=0; i < windowSize; i++) {
    featureIndices[i]=Generics.newHashSet();
  }
  labelIndices=new ArrayList<Index<CRFLabel>>(windowSize);
  for (int i=0; i < windowSize; i++) {
    labelIndices.add(new HashIndex<CRFLabel>());
  }
  Index<CRFLabel> labelIndex=labelIndices.get(windowSize - 1);
  classIndex=new HashIndex<String>();
  classIndex.add(flags.backgroundSymbol);
  Set<String>[] seenBackgroundFeatures=new HashSet[2];
  seenBackgroundFeatures[0]=Generics.newHashSet();
  seenBackgroundFeatures[1]=Generics.newHashSet();
  int wordCount=0;
  for (  List<IN> doc : ob) {
    if (flags.useReverse) {
      Collections.reverse(doc);
    }
    for (    IN token : doc) {
      wordCount++;
      String ans=token.get(CoreAnnotations.AnswerAnnotation.class);
      if (ans == null || ans.equals("")) {
        throw new IllegalArgumentException("Word " + wordCount + " (\""+ token.get(CoreAnnotations.TextAnnotation.class)+ "\") has a blank answer");
      }
      classIndex.add(ans);
    }
    for (int j=0, docSize=doc.size(); j < docSize; j++) {
      CRFDatum<List<String>,CRFLabel> d=makeDatum(doc,j,featureFactory);
      labelIndex.add(d.label());
      List<List<String>> features=d.asFeatures();
      for (int k=0, fSize=features.size(); k < fSize; k++) {
        Collection<String> cliqueFeatures=features.get(k);
        if (k < 2 && flags.removeBackgroundSingletonFeatures) {
          String ans=doc.get(j).get(CoreAnnotations.AnswerAnnotation.class);
          boolean background=ans.equals(flags.backgroundSymbol);
          if (k == 1 && j > 0 && background) {
            ans=doc.get(j - 1).get(CoreAnnotations.AnswerAnnotation.class);
            background=ans.equals(flags.backgroundSymbol);
          }
          if (background) {
            for (            String f : cliqueFeatures) {
              if (!featureIndices[k].contains(f)) {
                if (seenBackgroundFeatures[k].contains(f)) {
                  seenBackgroundFeatures[k].remove(f);
                  featureIndices[k].add(f);
                }
 else {
                  seenBackgroundFeatures[k].add(f);
                }
              }
            }
          }
 else {
            seenBackgroundFeatures[k].removeAll(cliqueFeatures);
            featureIndices[k].addAll(cliqueFeatures);
          }
        }
 else {
          featureIndices[k].addAll(cliqueFeatures);
        }
      }
    }
    if (flags.useReverse) {
      Collections.reverse(doc);
    }
  }
  int numFeatures=0;
  for (int i=0; i < windowSize; i++) {
    numFeatures+=featureIndices[i].size();
  }
  featureIndex=new HashIndex<String>();
  map=new int[numFeatures];
  if (flags.groupByFeatureTemplate) {
    templateGroupIndex=new HashIndex<String>();
    featureIndexToTemplateIndex=new HashMap<Integer,Integer>();
  }
  Matcher m=null;
  String groupSuffix=null;
  for (int i=0; i < windowSize; i++) {
    Index<Integer> featureIndexMap=new HashIndex<Integer>();
    featureIndex.addAll(featureIndices[i]);
    for (    String str : featureIndices[i]) {
      int index=featureIndex.indexOf(str);
      map[index]=i;
      featureIndexMap.add(index);
      if (flags.groupByFeatureTemplate) {
        m=suffixPatt.matcher(str);
        groupSuffix="NoTemplate";
        if (m.matches()) {
          groupSuffix=m.group(1);
        }
        groupSuffix+="-c:" + i;
        int groupIndex=templateGroupIndex.indexOf(groupSuffix,true);
        featureIndexToTemplateIndex.put(index,groupIndex);
      }
    }
    if (i == 0) {
      nodeFeatureIndicesMap=featureIndexMap;
      System.err.println("setting nodeFeatureIndicesMap, size=" + nodeFeatureIndicesMap.size());
    }
 else {
      edgeFeatureIndicesMap=featureIndexMap;
      System.err.println("setting edgeFeatureIndicesMap, size=" + edgeFeatureIndicesMap.size());
    }
  }
  if (flags.numOfFeatureSlices > 0) {
    System.err.println("Taking " + flags.numOfFeatureSlices + " out of "+ flags.totalFeatureSlice+ " slices of node features for training");
    pruneNodeFeatureIndices(flags.totalFeatureSlice,flags.numOfFeatureSlices);
  }
  if (flags.useObservedSequencesOnly) {
    for (int i=0, liSize=labelIndex.size(); i < liSize; i++) {
      CRFLabel label=labelIndex.get(i);
      for (int j=windowSize - 2; j >= 0; j--) {
        label=label.getOneSmallerLabel();
        labelIndices.get(j).add(label);
      }
    }
  }
 else {
    for (int i=0; i < labelIndices.size(); i++) {
      labelIndices.set(i,allLabels(i + 1,classIndex));
    }
  }
  if (VERBOSE) {
    for (int i=0, fiSize=featureIndex.size(); i < fiSize; i++) {
      System.out.println(i + ": " + featureIndex.get(i));
    }
  }
}
