{
  boolean droppedFeature=false;
  int docSize=document.size();
  int[][][] data=new int[docSize][windowSize][];
  double[][][] featureVals=new double[docSize][windowSize][];
  int[] labels=new int[docSize];
  if (flags.useReverse) {
    Collections.reverse(document);
  }
  for (int j=0; j < docSize; j++) {
    CRFDatum<List<String>,CRFLabel> d=makeDatum(document,j,featureFactory);
    List<List<String>> features=d.asFeatures();
    List<double[]> featureValList=d.asFeatureVals();
    for (int k=0, fSize=features.size(); k < fSize; k++) {
      Collection<String> cliqueFeatures=features.get(k);
      data[j][k]=new int[cliqueFeatures.size()];
      featureVals[j][k]=featureValList.get(k);
      int m=0;
      for (      String feature : cliqueFeatures) {
        if (trainTime && flags.inputDropOut != 0.0) {
          double rand=Math.random();
          if (rand < flags.inputDropOut) {
            if (!droppedFeature) {
              System.err.printf("Dropped feature %s%n",feature);
              droppedFeature=true;
            }
            continue;
          }
        }
        int index=featureIndex.indexOf(feature);
        if (index >= 0) {
          data[j][k][m]=index;
          m++;
        }
 else {
        }
      }
      if (m < data[j][k].length) {
        int[] f=new int[m];
        System.arraycopy(data[j][k],0,f,0,m);
        data[j][k]=f;
        if (featureVals[j][k] != null) {
          double[] fVal=new double[m];
          System.arraycopy(featureVals[j][k],0,fVal,0,m);
          featureVals[j][k]=fVal;
        }
      }
    }
    IN wi=document.get(j);
    labels[j]=classIndex.indexOf(wi.get(AnswerAnnotation.class));
  }
  if (flags.useReverse) {
    Collections.reverse(document);
  }
  if (flags.nonLinearCRF) {
    data=transformDocData(data);
  }
  return new Triple<int[][][],int[],double[][][]>(data,labels,featureVals);
}
