{
  PaddedList<IN> pInfo=new PaddedList<IN>(info,pad);
  ArrayList<List<String>> features=new ArrayList<List<String>>();
  List<double[]> featureVals=new ArrayList<double[]>();
  Collection<Clique> done=Generics.newHashSet();
  for (int i=0; i < windowSize; i++) {
    List<String> featuresC=new ArrayList<String>();
    List<Clique> windowCliques=FeatureFactory.getCliques(i,0);
    windowCliques.removeAll(done);
    done.addAll(windowCliques);
    double[] featureValArr=null;
    if (flags.useEmbedding && i == 0) {
      List<double[]> embeddingList=new ArrayList<double[]>();
      int concatEmbeddingLen=0;
      String currentWord=null;
      for (int currLoc=loc - 2; currLoc <= loc + 2; currLoc++) {
        double[] embedding=null;
        if (currLoc >= 0 && currLoc < info.size()) {
          currentWord=info.get(loc).get(CoreAnnotations.TextAnnotation.class);
          String word=currentWord.toLowerCase();
          word=word.replaceAll("(-)?\\d+(\\.\\d*)?","0");
          if (embeddings.containsKey(word))           embedding=embeddings.get(word);
 else           embedding=embeddings.get("UNKNOWN");
        }
 else {
          embedding=embeddings.get("PADDING");
        }
        for (int e=0; e < embedding.length; e++) {
          featuresC.add("EMBEDDING-(" + (currLoc - loc) + ")-"+ e);
        }
        if (flags.addCapitalFeatures) {
          int numOfCapitalFeatures=4;
          double[] newEmbedding=new double[embedding.length + numOfCapitalFeatures];
          int currLen=embedding.length;
          System.arraycopy(embedding,0,newEmbedding,0,currLen);
          for (int e=0; e < numOfCapitalFeatures; e++)           featuresC.add("CAPITAL-(" + (currLoc - loc) + ")-"+ e);
          if (currLoc >= 0 && currLoc < info.size()) {
            if (currentWord.toUpperCase().equals(currentWord))             newEmbedding[currLen]=1;
 else {
              currLen+=1;
              if (currentWord.toLowerCase().equals(currentWord))               newEmbedding[currLen]=1;
 else {
                currLen+=1;
                if (Character.isUpperCase(currentWord.charAt(0)))                 newEmbedding[currLen]=1;
 else {
                  currLen+=1;
                  String remainder=currentWord.substring(1);
                  if (!remainder.toLowerCase().equals(remainder))                   newEmbedding[currLen]=1;
                }
              }
            }
          }
          embedding=newEmbedding;
        }
        embeddingList.add(embedding);
        concatEmbeddingLen+=embedding.length;
      }
      double[] concatEmbedding=new double[concatEmbeddingLen];
      int currPos=0;
      for (      double[] em : embeddingList) {
        System.arraycopy(em,0,concatEmbedding,currPos,em.length);
        currPos+=em.length;
      }
      if (flags.prependEmbedding) {
        int additionalFeatureCount=0;
        for (        Clique c : windowCliques) {
          Collection<String> fCol=featureFactory.getCliqueFeatures(pInfo,loc,c);
          featuresC.addAll(fCol);
          additionalFeatureCount+=fCol.size();
        }
        featureValArr=new double[concatEmbedding.length + additionalFeatureCount];
        System.arraycopy(concatEmbedding,0,featureValArr,0,concatEmbedding.length);
        Arrays.fill(featureValArr,concatEmbedding.length,featureValArr.length,1.0);
      }
 else {
        featureValArr=concatEmbedding;
      }
      if (flags.addBiasToEmbedding) {
        featuresC.add("BIAS-FEATURE");
        double[] newFeatureValArr=new double[featureValArr.length + 1];
        System.arraycopy(featureValArr,0,newFeatureValArr,0,featureValArr.length);
        newFeatureValArr[newFeatureValArr.length - 1]=1;
        featureValArr=newFeatureValArr;
      }
    }
 else {
      for (      Clique c : windowCliques) {
        featuresC.addAll(featureFactory.getCliqueFeatures(pInfo,loc,c));
      }
    }
    features.add(featuresC);
    featureVals.add(featureValArr);
  }
  int[] labels=new int[windowSize];
  for (int i=0; i < windowSize; i++) {
    String answer=pInfo.get(loc + i - windowSize + 1).get(CoreAnnotations.AnswerAnnotation.class);
    labels[i]=classIndex.indexOf(answer);
  }
  printFeatureLists(pInfo.get(loc),features);
  CRFDatum<List<String>,CRFLabel> d=new CRFDatum<List<String>,CRFLabel>(features,new CRFLabel(labels),featureVals);
  return d;
}
