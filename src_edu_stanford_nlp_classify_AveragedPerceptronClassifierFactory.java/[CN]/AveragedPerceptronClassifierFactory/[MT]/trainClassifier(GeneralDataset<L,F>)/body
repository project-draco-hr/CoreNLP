{
  Set<L> labelSet=new HashSet<L>();
  for (  RVFDatum<L,F> datum : dataset) {
    labelSet.add(datum.label());
  }
  List<L> labelList=new ArrayList<L>(labelSet);
  Index<Pair<F,L>> weightIndex=new HashIndex<Pair<F,L>>();
  double[] weights=EMPTY_DOUBLE_ARRAY;
  double[] weightsSumLastEpoch=EMPTY_DOUBLE_ARRAY;
  System.out.println("Training with Averaged Perceptron");
  System.out.printf("\tEpochs %d\n",epochs);
  for (int epoch=0; epoch < epochs; epoch++) {
    int cntIncorrect=0;
    double magnitudeIncorrect=0;
    Random r=new Random(1);
    RandomizedIterable<RVFDatum<L,F>> randDatums=new RandomizedIterable<RVFDatum<L,F>>(dataset,r,true);
    for (    RVFDatum<L,F> datum : randDatums) {
      ClassicCounter<Pair<F,L>>[] guessedVectors=new ClassicCounter[labelList.size()];
      ClassicCounter<Pair<F,L>>[] goldVector=new ClassicCounter[1];
      double[] losses=new double[labelList.size()];
      double bestGuessScore=Double.NEGATIVE_INFINITY;
      int bestGuessIdx=-1;
      for (int i=0; i < guessedVectors.length; i++) {
        guessedVectors[i]=makeFeatureFunctionPairs(labelList.get(i),datum);
        if (labelList.get(i).equals(datum.label())) {
          losses[i]=0;
        }
 else {
          losses[i]=1;
        }
        double score=Counters.dotProduct(guessedVectors[i],weights,weightIndex);
        if (bestGuessScore <= score) {
          bestGuessScore=score;
          bestGuessIdx=i;
        }
      }
      goldVector[0]=makeFeatureFunctionPairs(datum.label(),datum);
      double goldScore=Counters.dotProduct(goldVector[0],weights,weightIndex);
      if (losses[bestGuessIdx] == 1) {
        cntIncorrect++;
      }
      if (VERBOSE) {
        System.err.printf("Label: %s (%f) Best Guess: %s (%f) Features: %s\n",datum.label(),goldScore,labelList.get(bestGuessIdx),bestGuessScore,datum.asFeaturesCounter().toString());
      }
      if (bestGuessScore >= goldScore && !goldVector[0].equals(guessedVectors[bestGuessIdx])) {
        magnitudeIncorrect+=bestGuessScore - goldScore;
        weightIndex.addAll(goldVector[0].keySet());
        weightIndex.addAll(guessedVectors[bestGuessIdx].keySet());
        if (weightIndex.size() > weights.length) {
          weights=ArrayMath.copyOf(weights,weightIndex.size());
        }
        Counters.addInPlace(weights,goldVector[0],weightIndex);
        Counters.subtractInPlace(weights,guessedVectors[bestGuessIdx],weightIndex);
      }
      if (epoch + 1 == epochs) {
        weightsSumLastEpoch=ArrayMath.pairwiseAdd(weights,weightsSumLastEpoch);
      }
    }
    System.out.printf("Averaged Perceptron Epoch %d - Incorrect: %d/%d Magnitude Incorrect: %e\n",epoch,cntIncorrect,dataset.size,magnitudeIncorrect);
  }
  ArrayMath.L1normalize(weightsSumLastEpoch);
  LinearClassifier<L,F> lc=new LinearClassifier<L,F>(weightsSumLastEpoch,weightIndex);
  return lc;
}
