{
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(2);
  StringBuffer[] javaSB=new StringBuffer[CUTOFFS.length];
  for (int i=0; i < CUTOFFS.length; i++) {
    javaSB[i]=new StringBuffer("  private static String[] splitters" + (i + 1) + " = new String[] {");
  }
  ClassicCounter allScores=new ClassicCounter();
  for (  String node : nodeRules.keySet()) {
    ArrayList answers=new ArrayList();
    ClassicCounter cntr=(ClassicCounter)nodeRules.get(node);
    double support=(cntr.totalCount());
    System.out.println("Node " + node + " support is "+ support);
    for (Iterator<List<String>> it2=pRules.keySet().iterator(); it2.hasNext(); ) {
      List<String> key=it2.next();
      if (key.get(0).equals(node)) {
        ClassicCounter cntr2=pRules.get(key);
        double support2=(cntr2.totalCount());
        double kl=Counters.klDivergence(cntr2,cntr);
        System.out.println("KL(" + key + "||"+ node+ ") = "+ nf.format(kl)+ "\t"+ "support("+ key+ ") = "+ support2);
        double score=kl * support2;
        answers.add(new Pair<List<String>,Double>(key,new Double(score)));
        allScores.setCount(key,score);
      }
    }
    System.out.println("----");
    System.out.println("Sorted descending support * KL");
    Collections.sort(answers,new Comparator(){
      public int compare(      Object o1,      Object o2){
        Pair p1=(Pair)o1;
        Pair p2=(Pair)o2;
        Double p12=(Double)p1.second();
        Double p22=(Double)p2.second();
        return p22.compareTo(p12);
      }
    }
);
    for (int i=0, size=answers.size(); i < size; i++) {
      Pair p=(Pair)answers.get(i);
      double psd=((Double)p.second()).doubleValue();
      System.out.println(p.first() + ": " + nf.format(psd));
      if (psd >= CUTOFFS[0]) {
        List lst=(List)p.first();
        String nd=(String)lst.get(0);
        String par=(String)lst.get(1);
        for (int j=0; j < CUTOFFS.length; j++) {
          if (psd >= CUTOFFS[j]) {
            javaSB[j].append("\"").append(nd).append("^");
            javaSB[j].append(par).append("\", ");
          }
        }
      }
    }
    System.out.println();
  }
  for (Iterator it=pRules.keySet().iterator(); it.hasNext(); ) {
    List node=(List)it.next();
    ArrayList answers=new ArrayList();
    ClassicCounter cntr=(ClassicCounter)pRules.get(node);
    double support=(cntr.totalCount());
    if (support < SUPPCUTOFF) {
      continue;
    }
    System.out.println("Node " + node + " support is "+ support);
    for (Iterator it2=gPRules.keySet().iterator(); it2.hasNext(); ) {
      List key=(List)it2.next();
      if (key.get(0).equals(node.get(0)) && key.get(1).equals(node.get(1))) {
        ClassicCounter cntr2=(ClassicCounter)gPRules.get(key);
        double support2=(cntr2.totalCount());
        double kl=Counters.klDivergence(cntr2,cntr);
        System.out.println("KL(" + key + "||"+ node+ ") = "+ nf.format(kl)+ "\t"+ "support("+ key+ ") = "+ support2);
        double score=kl * support2;
        answers.add(new Pair(key,new Double(score)));
        allScores.setCount(key,score);
      }
    }
    System.out.println("----");
    System.out.println("Sorted descending support * KL");
    Collections.sort(answers,new Comparator(){
      public int compare(      Object o1,      Object o2){
        Pair p1=(Pair)o1;
        Pair p2=(Pair)o2;
        Double p12=(Double)p1.second();
        Double p22=(Double)p2.second();
        return p22.compareTo(p12);
      }
    }
);
    for (int i=0, size=answers.size(); i < size; i++) {
      Pair p=(Pair)answers.get(i);
      double psd=((Double)p.second()).doubleValue();
      System.out.println(p.first() + ": " + nf.format(psd));
      if (psd >= CUTOFFS[0]) {
        List lst=(List)p.first();
        String nd=(String)lst.get(0);
        String par=(String)lst.get(1);
        String gpar=(String)lst.get(2);
        for (int j=0; j < CUTOFFS.length; j++) {
          if (psd >= CUTOFFS[j]) {
            javaSB[j].append("\"").append(nd).append("^");
            javaSB[j].append(par).append("~");
            javaSB[j].append(gpar).append("\", ");
          }
        }
      }
    }
    System.out.println();
  }
  System.out.println();
  System.out.println("All scores:");
  edu.stanford.nlp.util.PriorityQueue pq=Counters.toPriorityQueue(allScores);
  while (!pq.isEmpty()) {
    Object key=pq.getFirst();
    double score=pq.getPriority(key);
    pq.removeFirst();
    System.out.println(key + "\t" + score);
  }
  System.out.println("  // Automatically generated by ParentAnnotationStats -- preferably don't edit");
  for (int i=0; i < CUTOFFS.length; i++) {
    int len=javaSB[i].length();
    javaSB[i].replace(len - 2,len,"};");
    System.out.println(javaSB[i]);
  }
  System.out.print("  public static HashSet splitters = new HashSet(Arrays.asList(");
  for (int i=CUTOFFS.length; i > 0; i--) {
    if (i == 1) {
      System.out.print("splitters1");
    }
 else {
      System.out.print("selectiveSplit" + i + " ? splitters"+ i+ " : (");
    }
  }
  for (int i=CUTOFFS.length; i >= 0; i--) {
    System.out.print(")");
  }
  System.out.println(";");
}
