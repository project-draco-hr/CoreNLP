{
  NumberFormat nf=NumberFormat.getNumberInstance();
  nf.setMaximumFractionDigits(2);
  StringBuffer[] javaSB=new StringBuffer[CUTOFFS.length];
  for (int i=0; i < CUTOFFS.length; i++) {
    javaSB[i]=new StringBuffer("  private static String[] splitters" + (i + 1) + " = new String[] {");
  }
  ClassicCounter<List<String>> allScores=new ClassicCounter<List<String>>();
  for (  String node : nodeRules.keySet()) {
    ArrayList<Pair<List<String>,Double>> answers=Generics.newArrayList();
    ClassicCounter<List<String>> cntr=nodeRules.get(node);
    double support=(cntr.totalCount());
    System.out.println("Node " + node + " support is "+ support);
    for (Iterator<List<String>> it2=pRules.keySet().iterator(); it2.hasNext(); ) {
      List<String> key=it2.next();
      if (key.get(0).equals(node)) {
        ClassicCounter<List<String>> cntr2=pRules.get(key);
        double support2=(cntr2.totalCount());
        double kl=Counters.klDivergence(cntr2,cntr);
        System.out.println("KL(" + key + "||"+ node+ ") = "+ nf.format(kl)+ "\t"+ "support("+ key+ ") = "+ support2);
        double score=kl * support2;
        answers.add(new Pair<List<String>,Double>(key,new Double(score)));
        allScores.setCount(key,score);
      }
    }
    System.out.println("----");
    System.out.println("Sorted descending support * KL");
    Collections.sort(answers,new Comparator<Pair<List<String>,Double>>(){
      public int compare(      Pair<List<String>,Double> o1,      Pair<List<String>,Double> o2){
        return o2.second().compareTo(o1.second());
      }
    }
);
    for (int i=0, size=answers.size(); i < size; i++) {
      Pair p=(Pair)answers.get(i);
      double psd=((Double)p.second()).doubleValue();
      System.out.println(p.first() + ": " + nf.format(psd));
      if (psd >= CUTOFFS[0]) {
        List lst=(List)p.first();
        String nd=(String)lst.get(0);
        String par=(String)lst.get(1);
        for (int j=0; j < CUTOFFS.length; j++) {
          if (psd >= CUTOFFS[j]) {
            javaSB[j].append("\"").append(nd).append("^");
            javaSB[j].append(par).append("\", ");
          }
        }
      }
    }
    System.out.println();
  }
  for (  List<String> node : pRules.keySet()) {
    ArrayList<Pair<List<String>,Double>> answers=Generics.newArrayList();
    ClassicCounter<List<String>> cntr=pRules.get(node);
    double support=(cntr.totalCount());
    if (support < SUPPCUTOFF) {
      continue;
    }
    System.out.println("Node " + node + " support is "+ support);
    for (    List<String> key : gPRules.keySet()) {
      if (key.get(0).equals(node.get(0)) && key.get(1).equals(node.get(1))) {
        ClassicCounter<List<String>> cntr2=gPRules.get(key);
        double support2=(cntr2.totalCount());
        double kl=Counters.klDivergence(cntr2,cntr);
        System.out.println("KL(" + key + "||"+ node+ ") = "+ nf.format(kl)+ "\t"+ "support("+ key+ ") = "+ support2);
        double score=kl * support2;
        answers.add(Pair.makePair(key,new Double(score)));
        allScores.setCount(key,score);
      }
    }
    System.out.println("----");
    System.out.println("Sorted descending support * KL");
    Collections.sort(answers,new Comparator<Pair<List<String>,Double>>(){
      public int compare(      Pair<List<String>,Double> o1,      Pair<List<String>,Double> o2){
        return o2.second().compareTo(o1.second());
      }
    }
);
    for (int i=0, size=answers.size(); i < size; i++) {
      Pair p=(Pair)answers.get(i);
      double psd=((Double)p.second()).doubleValue();
      System.out.println(p.first() + ": " + nf.format(psd));
      if (psd >= CUTOFFS[0]) {
        List lst=(List)p.first();
        String nd=(String)lst.get(0);
        String par=(String)lst.get(1);
        String gpar=(String)lst.get(2);
        for (int j=0; j < CUTOFFS.length; j++) {
          if (psd >= CUTOFFS[j]) {
            javaSB[j].append("\"").append(nd).append("^");
            javaSB[j].append(par).append("~");
            javaSB[j].append(gpar).append("\", ");
          }
        }
      }
    }
    System.out.println();
  }
  System.out.println();
  System.out.println("All scores:");
  edu.stanford.nlp.util.PriorityQueue<List<String>> pq=Counters.toPriorityQueue(allScores);
  while (!pq.isEmpty()) {
    List<String> key=pq.getFirst();
    double score=pq.getPriority(key);
    pq.removeFirst();
    System.out.println(key + "\t" + score);
  }
  System.out.println("  // Automatically generated by ParentAnnotationStats -- preferably don't edit");
  for (int i=0; i < CUTOFFS.length; i++) {
    int len=javaSB[i].length();
    javaSB[i].replace(len - 2,len,"};");
    System.out.println(javaSB[i]);
  }
  System.out.print("  public static HashSet splitters = new HashSet(Arrays.asList(");
  for (int i=CUTOFFS.length; i > 0; i--) {
    if (i == 1) {
      System.out.print("splitters1");
    }
 else {
      System.out.print("selectiveSplit" + i + " ? splitters"+ i+ " : (");
    }
  }
  for (int i=CUTOFFS.length; i >= 0; i--) {
    System.out.print(")");
  }
  System.out.println(";");
}
