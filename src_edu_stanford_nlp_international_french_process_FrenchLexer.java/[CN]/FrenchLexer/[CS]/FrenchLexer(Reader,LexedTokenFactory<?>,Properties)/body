{
  this(r);
  this.tokenFactory=tf;
  for (  String key : props.stringPropertyNames()) {
    String value=props.getProperty(key);
    boolean val=Boolean.valueOf(value);
switch (key) {
case "":
      break;
case "noSGML":
    noSGML=val;
  break;
case "invertible":
invertible=val;
break;
case "tokenizeNLs":
tokenizeNLs=val;
break;
case "ptb3Escaping":
normalizeAmpersandEntity=val;
normalizeFractions=val;
normalizeParentheses=val;
normalizeOtherBrackets=val;
ptb3Ellipsis=val;
unicodeEllipsis=val;
ptb3Dashes=val;
break;
case "normalizeAmpersandEntity":
normalizeAmpersandEntity=val;
break;
case "normalizeFractions":
normalizeFractions=val;
break;
case "normalizeParentheses":
normalizeParentheses=val;
break;
case "normalizeOtherBrackets":
normalizeOtherBrackets=val;
break;
case "ptb3Ellipsis":
ptb3Ellipsis=val;
break;
case "unicodeEllipsis":
unicodeEllipsis=val;
break;
case "ptb3Dashes":
ptb3Dashes=val;
break;
case "escapeForwardSlashAsterisk":
escapeForwardSlashAsterisk=val;
break;
case "untokenizable":
if (value.equals("noneDelete")) {
untokenizable=UntokenizableOptions.NONE_DELETE;
}
 else if (value.equals("firstDelete")) {
untokenizable=UntokenizableOptions.FIRST_DELETE;
}
 else if (value.equals("allDelete")) {
untokenizable=UntokenizableOptions.ALL_DELETE;
}
 else if (value.equals("noneKeep")) {
untokenizable=UntokenizableOptions.NONE_KEEP;
}
 else if (value.equals("firstKeep")) {
untokenizable=UntokenizableOptions.FIRST_KEEP;
}
 else if (value.equals("allKeep")) {
untokenizable=UntokenizableOptions.ALL_KEEP;
}
 else {
throw new IllegalArgumentException("FrenchLexer: Invalid option value in constructor: " + key + ": "+ value);
}
break;
case "strictTreebank3":
strictTreebank3=val;
break;
default :
System.err.printf("%s: Invalid options key in constructor: %s%n",this.getClass().getName(),key);
break;
}
}
if (invertible) {
if (!(tf instanceof CoreLabelTokenFactory)) {
throw new IllegalArgumentException("FrenchLexer: the invertible option requires a CoreLabelTokenFactory");
}
prevWord=(CoreLabel)tf.makeToken("",0,0);
prevWordAfter=new StringBuilder();
}
}
