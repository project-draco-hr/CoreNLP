{
  Map<T,Integer> outLinkSizes=new HashMap<T,Integer>();
  Set<T> noOutLinkNodes=new HashSet<T>();
  Map<T,Set<T>> inLinks=DefaultValuedMap.hashSetValuedMap();
  for (  Map.Entry<T,? extends Collection<T>> entry : outLinks.entrySet()) {
    T node=entry.getKey();
    Collection<T> targetNodes=entry.getValue();
    if (targetNodes.size() == 0) {
      noOutLinkNodes.add(node);
    }
    outLinkSizes.put(node,targetNodes.size());
    for (    T targetNode : targetNodes) {
      if (!outLinks.containsKey(targetNode)) {
        String format="found an edge to a node which was not a key in the map: %s";
        throw new RuntimeException(String.format(format,targetNode));
      }
      inLinks.get(targetNode).add(node);
    }
  }
  int nodeCount=outLinks.size();
  Counter<T> pageRanks=new ClassicCounter<T>();
  for (  T node : outLinks.keySet()) {
    pageRanks.setCount(node,1.0 / nodeCount);
  }
  for (int i=0; i < iterations; ++i) {
    Counter<T> newRanks=new ClassicCounter<T>();
    double noReferenceSum=0;
    for (    T node : noOutLinkNodes) {
      noReferenceSum+=pageRanks.getCount(node) / nodeCount;
    }
    for (    T node : outLinks.keySet()) {
      double sum=noReferenceSum;
      for (      T sourceNode : inLinks.get(node)) {
        int sourceOutLinkCount=outLinkSizes.get(sourceNode);
        sum+=pageRanks.getCount(sourceNode) / sourceOutLinkCount;
      }
      double pageRank=(1 - dampingFactor) / nodeCount + dampingFactor * sum;
      newRanks.setCount(node,pageRank);
    }
    pageRanks=newRanks;
  }
  return pageRanks;
}
