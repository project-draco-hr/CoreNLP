{
  final AtomicBoolean haveStarted=new AtomicBoolean(false);
  final ReentrantLock metaInfoLock=new ReentrantLock();
  final AtomicInteger numPending=new AtomicInteger(0);
  final Iterator<Runnable> iter=runnables.iterator();
  return new IterableIterator<>(new Iterator<Runnable>(){
    @Override public boolean hasNext(){
synchronized (iter) {
        return iter.hasNext();
      }
    }
    @Override public synchronized Runnable next(){
      final Runnable runnable;
synchronized (iter) {
        runnable=iter.next();
      }
      while (numPending.get() > 100) {
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          throw new RuntimeInterruptedException(e);
        }
      }
      numPending.incrementAndGet();
      Runnable toReturn=new Runnable(){
        public void run(){
          boolean threadFinished=false;
          try {
            metaInfoLock.lock();
            if (!haveStarted.getAndSet(true)) {
              startThreads(title);
            }
            metaInfoLock.unlock();
            try {
              runnable.run();
            }
 catch (            Exception|AssertionError e) {
              e.printStackTrace();
              System.exit(1);
            }
            finishThread();
            threadFinished=true;
            int numStillPending=numPending.decrementAndGet();
synchronized (iter) {
              if (numStillPending <= 0 && !iter.hasNext()) {
                endThreads(title);
              }
            }
          }
 catch (          Throwable t) {
            t.printStackTrace();
            if (!threadFinished) {
              finishThread();
            }
          }
        }
      }
;
      return toReturn;
    }
    @Override public void remove(){
synchronized (iter) {
        iter.remove();
      }
    }
  }
);
}
