{
  factors=new double[dataset.numDatums()][];
  double[][] messages=new double[factors.length - 1][];
  boolean init=false;
  if (messageFromLeft == null) {
    init=true;
    messageFromLeft=new int[messages.length][];
    messageFromRight=new int[messages.length][];
    toPassMessagesRight=new int[messages.length][][];
    toPassMessagesLeft=new int[messages.length][][];
  }
  for (int i=0; i < factors.length; i++) {
    int size=cliqueLabels[i].size();
    factors[i]=new double[size];
    if (i > 0 && messageFromLeft[i - 1] == null) {
      messageFromLeft[i - 1]=new int[size];
      Arrays.fill(messageFromLeft[i - 1],-1);
    }
    if (i < messageFromRight.length && messageFromRight[i] == null) {
      messageFromRight[i]=new int[size];
      Arrays.fill(messageFromRight[i],-1);
    }
    for (int j=0; j < size; j++) {
      LabeledClique lc=cliqueLabels[i].get(j);
      Features labelInfo=dataset.features[i].get(lc);
      int[] features=labelInfo.features;
      double score=0.0f;
      for (int k=0; k < features.length; k++) {
        score+=labelInfo.value(k) * weights[features[k]] * weightsScale;
      }
      if (i > 0) {
        if (messageFromLeft[i - 1][j] < 0) {
          LabeledClique message=lc.leftMessage();
          messageFromLeft[i - 1][j]=messageLabels[i - 1].indexOf(message);
          if (messageFromLeft[i - 1][j] < 0) {
            System.err.println(i + "\n" + lc+ "\n"+ message+ "\n"+ messageLabels[i - 1]+ "\n------\n"+ cliqueLabels[i - 1]+ "\n========\n"+ cliqueLabels[i]);
          }
        }
        score+=messages[i - 1][messageFromLeft[i - 1][j]];
      }
      factors[i][j]=score;
    }
    if (init && i > 1 && memorySave) {
      boolean same=true;
      for (int j=0; j < messageFromLeft[i - 1].length; j++) {
        if (messageFromLeft[i - 1][j] != messageFromLeft[i - 2][j]) {
          same=false;
          break;
        }
      }
      if (same) {
        messageFromLeft[i - 1]=messageFromLeft[i - 2];
      }
    }
    if (i < messages.length) {
      if (toPassMessagesRight[i] == null) {
        toPassMessagesRight[i]=new int[messageLabels[i].size()][];
        CollectionValuedMap<LabeledClique,Integer> messageMap=new CollectionValuedMap<LabeledClique,Integer>();
        for (int j=0; j < cliqueLabels[i].size(); j++) {
          LabeledClique lc=cliqueLabels[i].get(j);
          LabeledClique message=lc.rightMessage();
          messageMap.add(message,j);
        }
        for (        LabeledClique message : messageMap.keySet()) {
          int messageIndex=messageLabels[i].indexOf(message);
          Collection<Integer> lcs=messageMap.get(message);
          toPassMessagesRight[i][messageIndex]=new int[lcs.size()];
          int j=0;
          for (          int lcIndex : lcs) {
            toPassMessagesRight[i][messageIndex][j++]=lcIndex;
          }
        }
        if (i > 0 && memorySave) {
          boolean same=true;
          LOOP:           for (int j=0; j < toPassMessagesRight[i].length; j++) {
            if (toPassMessagesRight[i][j] == null || toPassMessagesRight[i - 1][j] == null) {
              same=false;
              break;
            }
            if (toPassMessagesRight[i][j].length != toPassMessagesRight[i - 1][j].length) {
              same=false;
              break;
            }
            for (int k=0; k < toPassMessagesRight[i][j].length; k++) {
              if (toPassMessagesRight[i][j][k] != toPassMessagesRight[i - 1][j][k]) {
                same=false;
                break LOOP;
              }
            }
          }
          if (same) {
            toPassMessagesRight[i]=toPassMessagesRight[i - 1];
          }
        }
      }
      if (messages[i] == null) {
        messages[i]=new double[messageLabels[i].size()];
      }
      for (int j=0; j < toPassMessagesRight[i].length; j++) {
        if (toPassMessagesRight[i][j] == null) {
          messages[i][j]=Double.NEGATIVE_INFINITY;
        }
 else {
          double[] toSum=new double[toPassMessagesRight[i][j].length];
          for (int k=0; k < toSum.length; k++) {
            toSum[k]=factors[i][toPassMessagesRight[i][j][k]];
          }
          messages[i][j]=ArrayMath.logSum(toSum);
        }
      }
    }
  }
  for (int i=factors.length - 1; i >= 0; i--) {
    if (i < messages.length) {
      int size=cliqueLabels[i].size();
      for (int j=0; j < size; j++) {
        if (messageFromRight[i][j] < 0) {
          LabeledClique lc=cliqueLabels[i].get(j);
          LabeledClique message=lc.rightMessage();
          messageFromRight[i][j]=messageLabels[i].indexOf(message);
        }
        factors[i][j]+=messages[i][messageFromRight[i][j]];
      }
      if (init && i < messageFromLeft.length - 1 && memorySave) {
        boolean same=true;
        for (int j=0; j < messageFromRight[i].length; j++) {
          if (messageFromRight[i][j] != messageFromRight[i + 1][j]) {
            same=false;
            break;
          }
        }
        if (same) {
          messageFromRight[i]=messageFromRight[i + 1];
        }
      }
    }
    if (i > 0) {
      if (toPassMessagesLeft[i - 1] == null) {
        toPassMessagesLeft[i - 1]=new int[messageLabels[i - 1].size()][];
        CollectionValuedMap<LabeledClique,Integer> messageMap=new CollectionValuedMap<LabeledClique,Integer>();
        for (int j=0; j < cliqueLabels[i].size(); j++) {
          LabeledClique lc=cliqueLabels[i].get(j);
          LabeledClique message=lc.leftMessage();
          messageMap.add(message,j);
        }
        for (        LabeledClique message : messageMap.keySet()) {
          int messageIndex=messageLabels[i - 1].indexOf(message);
          Collection<Integer> lcs=messageMap.get(message);
          toPassMessagesLeft[i - 1][messageIndex]=new int[lcs.size()];
          int j=0;
          for (          int lcIndex : lcs) {
            toPassMessagesLeft[i - 1][messageIndex][j++]=lcIndex;
          }
        }
        if (i > 0 && i < toPassMessagesLeft.length && memorySave) {
          boolean same=true;
          LOOP:           for (int j=0; j < toPassMessagesLeft[i - 1].length; j++) {
            if (toPassMessagesLeft[i][j] == null || toPassMessagesLeft[i - 1][j] == null) {
              same=false;
              break;
            }
            if (toPassMessagesLeft[i - 1][j].length != toPassMessagesLeft[i][j].length) {
              same=false;
              break;
            }
            for (int k=0; k < toPassMessagesLeft[i - 1][j].length; k++) {
              if (toPassMessagesLeft[i - 1][j][k] != toPassMessagesLeft[i][j][k]) {
                same=false;
                break LOOP;
              }
            }
          }
          if (same) {
            toPassMessagesLeft[i - 1]=toPassMessagesLeft[i];
          }
        }
      }
      for (int j=0; j < toPassMessagesLeft[i - 1].length; j++) {
        if (toPassMessagesLeft[i - 1][j] == null) {
          messages[i - 1][j]=Double.NEGATIVE_INFINITY;
        }
 else {
          double[] toSum=new double[toPassMessagesLeft[i - 1][j].length];
          for (int k=0; k < toSum.length; k++) {
            toSum[k]=factors[i][toPassMessagesLeft[i - 1][j][k]];
          }
          double m=ArrayMath.logSum(toSum);
          if (!(m == Double.NEGATIVE_INFINITY && messages[i - 1][j] == Double.NEGATIVE_INFINITY)) {
            messages[i - 1][j]=ArrayMath.logSum(toSum) - messages[i - 1][j];
          }
        }
      }
    }
  }
  if (factors.length > 0) {
    double Z=ArrayMath.logSum(factors[0]);
    for (int i=0; i < factors.length; i++) {
      for (int j=0; j < factors[i].length; j++) {
        factors[i][j]-=Z;
      }
    }
  }
}
