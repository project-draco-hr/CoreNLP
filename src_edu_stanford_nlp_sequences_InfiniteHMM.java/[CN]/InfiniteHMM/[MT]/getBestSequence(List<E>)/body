{
  System.err.print("Getting best sequence using Viterbi");
  int[] fields=new int[observations.size()];
  int[][] backPointers=new int[observations.size()][newK];
  double[] thisProbs=new double[newK];
  double[] lastProbs=new double[newK];
  for (int i=0; i < observations.size(); i++) {
    E e=observations.get(i);
    Arrays.fill(thisProbs,0.0);
    if (e == boundarySymbol) {
      Arrays.fill(thisProbs,Double.NEGATIVE_INFINITY);
      thisProbs[boundaryK]=0.0;
      int maxIndex=ArrayMath.argmax(lastProbs);
      backPointers[i][boundaryK]=maxIndex;
    }
 else {
      for (int curr=0; curr < newK; curr++) {
        if (curr == boundaryK) {
          thisProbs[curr]=Double.NEGATIVE_INFINITY;
        }
 else {
          double maxProb=Double.NEGATIVE_INFINITY;
          int maxIndex=-1;
          double logEmissionProb=getLogEmissionProb(curr,e);
          for (int prev=0; prev < newK; prev++) {
            double logTransitionProb=Math.log(getTransitionProb(prev,curr));
            double prob=lastProbs[prev] + logTransitionProb + logEmissionProb;
            if (prob > maxProb) {
              maxProb=prob;
              maxIndex=prev;
            }
          }
          backPointers[i][curr]=maxIndex;
          thisProbs[curr]=maxProb;
        }
      }
    }
    double max=ArrayMath.max(thisProbs);
    ArrayMath.addInPlace(thisProbs,-max);
    double[] temp=lastProbs;
    lastProbs=thisProbs;
    thisProbs=temp;
    if (i % 100 == 0)     System.err.print(".");
  }
  fields[fields.length - 1]=ArrayMath.argmax(lastProbs);
  for (int i=fields.length - 2; i >= 0; i--) {
    fields[i]=backPointers[i + 1][fields[i + 1]];
    if (fields[i] < 0 || fields[i] >= newK) {
      System.err.println("bad backpointer at " + i);
      for (int j=i; j < observations.size(); j++) {
        System.err.println(j + ": " + observations.get(j)+ " "+ ArrayMath.toString(backPointers[j]));
      }
      throw new RuntimeException();
    }
  }
  System.err.println("done.");
  return fields;
}
