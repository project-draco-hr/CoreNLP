{
  if (pool == null) {
    pool=new AnnotatorPool();
  }
  pool.register(STANFORD_TOKENIZE,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      if (Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"))) {
        return new WhitespaceTokenizerAnnotator(properties);
      }
 else {
        String options=properties.getProperty("tokenize.options",PTBTokenizerAnnotator.DEFAULT_OPTIONS);
        boolean keepNewline=Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"));
        if (keepNewline) {
          options="tokenizeNLs," + options;
        }
        return new PTBTokenizerAnnotator(false,options);
      }
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("tokenize.whitespace:" + properties.getProperty("tokenize.whitespace","false"));
      if (Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"))) {
        os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + ":" + properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,"false"));
        os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + ":" + properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,"false"));
        return os.toString();
      }
 else {
        os.append(NEWLINE_SPLITTER_PROPERTY + ":" + Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false")));
      }
      return os.toString();
    }
  }
);
  pool.register(STANFORD_CLEAN_XML,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String xmlTags=properties.getProperty("clean.xmltags",CleanXmlAnnotator.DEFAULT_XML_TAGS);
      String sentenceEndingTags=properties.getProperty("clean.sentenceendingtags",CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);
      String allowFlawedString=properties.getProperty("clean.allowflawedxml");
      boolean allowFlawed=CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;
      if (allowFlawedString != null)       allowFlawed=Boolean.valueOf(allowFlawedString);
      String dateTags=properties.getProperty("clean.datetags",CleanXmlAnnotator.DEFAULT_DATE_TAGS);
      return new CleanXmlAnnotator(xmlTags,sentenceEndingTags,dateTags,allowFlawed);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("clean.xmltags:" + properties.getProperty("clean.xmltags",CleanXmlAnnotator.DEFAULT_XML_TAGS));
      os.append("clean.sentenceendingtags:" + properties.getProperty("clean.sentenceendingtags",CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS));
      os.append("clean.allowflawedxml:" + properties.getProperty("clean.allowflawedxml",""));
      os.append("clean.datetags:" + properties.getProperty("clean.datetags",CleanXmlAnnotator.DEFAULT_DATE_TAGS));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_SSPLIT,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      boolean nlSplitting=Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"));
      if (nlSplitting) {
        boolean whitespaceTokenization=Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"));
        WordsToSentencesAnnotator wts;
        if (whitespaceTokenization) {
          if (System.getProperty("line.separator").equals("\n")) {
            wts=WordsToSentencesAnnotator.newlineSplitter(false,"\n");
          }
 else {
            wts=WordsToSentencesAnnotator.newlineSplitter(false,System.getProperty("line.separator"),"\n");
          }
        }
 else {
          wts=WordsToSentencesAnnotator.newlineSplitter(false,PTBTokenizer.getNewlineToken());
        }
        return wts;
      }
 else {
        WordsToSentencesAnnotator wts;
        String boundaryTokenRegex=properties.getProperty("ssplit.boundaryTokenRegex");
        if (boundaryTokenRegex != null) {
          wts=new WordsToSentencesAnnotator(false,boundaryTokenRegex);
        }
 else {
          wts=new WordsToSentencesAnnotator();
        }
        String bounds=properties.getProperty("ssplit.boundariesToDiscard");
        if (bounds != null) {
          String[] toks=bounds.split(",");
          wts.setSentenceBoundaryToDiscard(new HashSet<String>(Arrays.asList(toks)));
        }
        bounds=properties.getProperty("ssplit.htmlBoundariesToDiscard");
        if (bounds != null) {
          String[] toks=bounds.split(",");
          wts.addHtmlSentenceBoundaryToDiscard(new HashSet<String>(Arrays.asList(toks)));
        }
        String isOneSentence=properties.getProperty("ssplit.isOneSentence");
        if (isOneSentence != null) {
          wts.setOneSentence(Boolean.parseBoolean(isOneSentence));
        }
        return wts;
      }
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append(NEWLINE_SPLITTER_PROPERTY + ":" + properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"));
      if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"))) {
        os.append("tokenize.whitespace:" + properties.getProperty("tokenize.whitespace","false"));
      }
 else {
        os.append("ssplit.boundariesToDiscard:" + properties.getProperty("ssplit.boundariesToDiscard",""));
        os.append("ssplit.htmlBoundariesToDiscard:" + properties.getProperty("ssplit.htmlBoundariesToDiscard",""));
        os.append("ssplit.isOneSentence:" + properties.getProperty("ssplit.isOneSentence",""));
      }
      return os.toString();
    }
  }
);
  pool.register(STANFORD_POS,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      try {
        String maxLenStr=properties.getProperty("pos.maxlen");
        int maxLen=Integer.MAX_VALUE;
        if (maxLenStr != null)         maxLen=Integer.parseInt(maxLenStr);
        return new POSTaggerAnnotator(properties.getProperty("pos.model",DefaultPaths.DEFAULT_POS_MODEL),false,maxLen);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("pos.maxlen:" + properties.getProperty("pos.maxlen",""));
      os.append("pos.model:" + properties.getProperty("pos.model",DefaultPaths.DEFAULT_POS_MODEL));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_LEMMA,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return new MorphaAnnotator(false);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      return os.toString();
    }
  }
);
  pool.register(STANFORD_NER,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      List<String> models=new ArrayList<String>();
      String modelNames=properties.getProperty("ner.model");
      if (modelNames == null) {
        modelNames=DefaultPaths.DEFAULT_NER_THREECLASS_MODEL + "," + DefaultPaths.DEFAULT_NER_MUC_MODEL+ ","+ DefaultPaths.DEFAULT_NER_CONLL_MODEL;
      }
      if (modelNames.length() > 0) {
        models.addAll(Arrays.asList(modelNames.split(",")));
      }
      if (models.isEmpty()) {
        System.err.println("WARNING: no NER models specified");
      }
      NERClassifierCombiner nerCombiner;
      try {
        boolean applyNumericClassifiers=PropertiesUtils.getBool(properties,NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT);
        boolean useSUTime=PropertiesUtils.getBool(properties,NumberSequenceClassifier.USE_SUTIME_PROPERTY,NumberSequenceClassifier.USE_SUTIME_DEFAULT);
        nerCombiner=new NERClassifierCombiner(applyNumericClassifiers,useSUTime,properties,models.toArray(new String[models.size()]));
      }
 catch (      FileNotFoundException e) {
        throw new RuntimeException(e);
      }
      return new NERCombinerAnnotator(nerCombiner,false);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("ner.model:" + properties.getProperty("ner.model",""));
      os.append("ner.model.3class:" + properties.getProperty("ner.model.3class",DefaultPaths.DEFAULT_NER_THREECLASS_MODEL));
      os.append("ner.model.7class:" + properties.getProperty("ner.model.7class",DefaultPaths.DEFAULT_NER_MUC_MODEL));
      os.append("ner.model.MISCclass:" + properties.getProperty("ner.model.MISCclass",DefaultPaths.DEFAULT_NER_CONLL_MODEL));
      os.append(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY + ":" + properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT)));
      os.append(NumberSequenceClassifier.USE_SUTIME_PROPERTY + ":" + properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT)));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_REGEXNER,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String mapping=properties.getProperty("regexner.mapping",DefaultPaths.DEFAULT_REGEXNER_RULES);
      String ignoreCase=properties.getProperty("regexner.ignorecase","false");
      String validPosPattern=properties.getProperty("regexner.validpospattern",RegexNERSequenceClassifier.DEFAULT_VALID_POS);
      return new RegexNERAnnotator(mapping,Boolean.valueOf(ignoreCase),validPosPattern);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("regexner.mapping:" + properties.getProperty("regexner.mapping",DefaultPaths.DEFAULT_REGEXNER_RULES));
      os.append("regexner.ignorecase:" + properties.getProperty("regexner.ignorecase","false"));
      os.append("regexner.validpospattern:" + properties.getProperty("regexner.validpospattern",RegexNERSequenceClassifier.DEFAULT_VALID_POS));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_GENDER,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return new GenderAnnotator(false,properties.getProperty("gender.firstnames",DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("gender.firstnames:" + properties.getProperty("gender.firstnames",DefaultPaths.DEFAULT_GENDER_FIRST_NAMES));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_TRUECASE,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String model=properties.getProperty("truecase.model",DefaultPaths.DEFAULT_TRUECASE_MODEL);
      String bias=properties.getProperty("truecase.bias",TrueCaseAnnotator.DEFAULT_MODEL_BIAS);
      String mixed=properties.getProperty("truecase.mixedcasefile",DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);
      return new TrueCaseAnnotator(model,bias,mixed,false);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("truecase.model:" + properties.getProperty("truecase.model",DefaultPaths.DEFAULT_TRUECASE_MODEL));
      os.append("truecase.bias:" + properties.getProperty("truecase.bias",TrueCaseAnnotator.DEFAULT_MODEL_BIAS));
      os.append("truecase.mixedcasefile:" + properties.getProperty("truecase.mixedcasefile",DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_NFL_TOKENIZE,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      final String className="edu.stanford.nlp.pipeline.NFLTokenizerAnnotator";
      return ReflectionLoading.loadByReflection(className);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      return os.toString();
    }
  }
);
  pool.register(STANFORD_NFL,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      final String className="edu.stanford.nlp.pipeline.NFLAnnotator";
      return ReflectionLoading.loadByReflection(className,properties);
    }
    @Override public String signature(){
      StringBuilder os=new StringBuilder();
      os.append("nfl.verbose:" + properties.getProperty("nfl.verbose","false"));
      os.append("nfl.relations.use.max.recall:" + properties.getProperty("nfl.relations.use.max.recall","false"));
      os.append("nfl.relations.use.model.merging:" + properties.getProperty("nfl.relations.use.model.merging","false"));
      os.append("nfl.relations.use.basic.inference:" + properties.getProperty("nfl.relations.use.basic.inference","true"));
      os.append("nfl.gazetteer:" + properties.getProperty("nfl.gazetteer",DefaultPaths.DEFAULT_NFL_GAZETTEER));
      os.append("nfl.entity.model:" + properties.getProperty("nfl.entity.model",DefaultPaths.DEFAULT_NFL_ENTITY_MODEL));
      os.append("nfl.relation.model:" + properties.getProperty("nfl.relation.model",DefaultPaths.DEFAULT_NFL_RELATION_MODEL));
      return os.toString();
    }
  }
);
  pool.register(STANFORD_PARSE,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String parserType=properties.getProperty("parse.type","stanford");
      String maxLenStr=properties.getProperty("parse.maxlen");
      if (parserType.equalsIgnoreCase("stanford")) {
        ParserAnnotator anno=new ParserAnnotator("parse",properties);
        return anno;
      }
 else       if (parserType.equalsIgnoreCase("charniak")) {
        String model=properties.getProperty("parse.model");
        String parserExecutable=properties.getProperty("parse.executable");
        if (model == null || parserExecutable == null) {
          throw new RuntimeException("Both parse.model and parse.executable properties must be specified if parse.type=charniak");
        }
        int maxLen=399;
        if (maxLenStr != null) {
          maxLen=Integer.parseInt(maxLenStr);
        }
        CharniakParserAnnotator anno=new CharniakParserAnnotator(model,parserExecutable,false,maxLen);
        return anno;
      }
 else {
        throw new RuntimeException("Unknown parser type: " + parserType + " (currently supported: stanford and charniak)");
      }
    }
    @Override public String signature(){
      String type=properties.getProperty("parse.type","stanford");
      if (type.equalsIgnoreCase("stanford")) {
        return ParserAnnotator.signature("parser",properties);
      }
 else       if (type.equalsIgnoreCase("charniak")) {
        StringBuilder os=new StringBuilder();
        os.append("parse.model:" + properties.getProperty("parse.model",""));
        os.append("parse.executable:" + properties.getProperty("parse.executable",""));
        os.append("parse.maxlen:" + properties.getProperty("parse.maxlen",""));
        return os.toString();
      }
 else {
        throw new RuntimeException("Unknown parser type: " + type + " (currently supported: stanford and charniak)");
      }
    }
  }
);
  pool.register(STANFORD_DETERMINISTIC_COREF,new AnnotatorFactory(inputProps){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return new DeterministicCorefAnnotator(properties);
    }
    @Override public String signature(){
      return DeterministicCorefAnnotator.signature(properties);
    }
  }
);
  for (  Object propertyKey : inputProps.keySet()) {
    if (!(propertyKey instanceof String))     continue;
    String property=(String)propertyKey;
    if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {
      final String customName=property.substring(CUSTOM_ANNOTATOR_PREFIX.length());
      final String customClassName=inputProps.getProperty(property);
      System.err.println("Registering annotator " + customName + " with class "+ customClassName);
      pool.register(customName,new AnnotatorFactory(inputProps){
        private static final long serialVersionUID=1L;
        private final String name=customName;
        private final String className=customClassName;
        @Override public Annotator create(){
          return ReflectionLoading.loadByReflection(className,name,properties);
        }
        @Override public String signature(){
          StringBuilder os=new StringBuilder();
          for (          Object key : properties.keySet()) {
            String skey=(String)key;
            os.append(skey + ":" + properties.getProperty(skey));
          }
          return os.toString();
        }
      }
);
    }
  }
  return pool;
}
