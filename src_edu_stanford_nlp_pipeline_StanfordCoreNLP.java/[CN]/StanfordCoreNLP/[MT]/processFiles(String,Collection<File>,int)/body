{
  List<Runnable> toRun=new LinkedList<Runnable>();
  final String baseOutputDir=properties.getProperty("outputDirectory",".");
  final String baseInputDir=properties.getProperty("inputDirectory",base);
  final OutputFormat outputFormat=OutputFormat.valueOf(properties.getProperty("outputFormat",DEFAULT_OUTPUT_FORMAT).toUpperCase());
  String defaultExtension;
switch (outputFormat) {
case XML:
    defaultExtension=".xml";
  break;
case TEXT:
defaultExtension=".out";
break;
case SERIALIZED:
defaultExtension=".ser.gz";
break;
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
final String serializerClass=properties.getProperty("serializer");
final String inputSerializerClass=properties.getProperty("inputSerializer",serializerClass);
final String outputSerializerClass=properties.getProperty("outputSerializer",serializerClass);
final String extension=properties.getProperty("outputExtension",defaultExtension);
final boolean replaceExtension=Boolean.parseBoolean(properties.getProperty("replaceExtension","false"));
final boolean continueOnAnnotateError=Boolean.parseBoolean(properties.getProperty("continueOnAnnotateError","false"));
final boolean noClobber=Boolean.parseBoolean(properties.getProperty("noClobber","false"));
final boolean randomize=Boolean.parseBoolean(properties.getProperty("randomize","false"));
final MutableInteger totalProcessed=new MutableInteger(0);
final MutableInteger totalSkipped=new MutableInteger(0);
final MutableInteger totalErrorAnnotating=new MutableInteger(0);
for (final File file : files) {
toRun.add(new Runnable(){
@Override public void run(){
try {
String outputDir=baseOutputDir;
if (baseInputDir != null) {
String relDir=file.getParent().replaceFirst(Pattern.quote(baseInputDir),"");
outputDir=outputDir + File.separator + relDir;
}
new File(outputDir).mkdirs();
String outputFilename=new File(outputDir,file.getName()).getPath();
if (replaceExtension) {
int lastDot=outputFilename.lastIndexOf('.');
if (lastDot > 0) {
outputFilename=outputFilename.substring(0,lastDot);
}
}
if (!outputFilename.endsWith(extension)) {
outputFilename+=extension;
}
outputFilename=new File(outputFilename).getCanonicalPath();
if (outputFilename.equals(file.getCanonicalPath())) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " has the same filename as the input file -- assuming you don't actually want to do this.");
synchronized (totalSkipped) {
totalSkipped.incValue(1);
}
return;
}
if (noClobber && new File(outputFilename).exists()) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " as it already exists.  Don't use the noClobber option to override this.");
synchronized (totalSkipped) {
totalSkipped.incValue(1);
}
return;
}
forceTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
Annotation annotation=null;
if (file.getAbsolutePath().endsWith(".ser.gz")) {
try {
if (inputSerializerClass != null) {
  AnnotationSerializer inputSerializer=ReflectionLoading.loadByReflection(inputSerializerClass);
  annotation=inputSerializer.load(new BufferedInputStream(new FileInputStream(file)));
}
 else {
  annotation=IOUtils.readObjectFromFile(file);
}
}
 catch (IOException e) {
}
catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
if (annotation == null) {
String encoding=getEncoding();
String text=IOUtils.slurpFile(file,encoding);
annotation=new Annotation(text);
}
boolean annotationOkay=false;
forceTrack("Annotating file " + file.getAbsoluteFile());
try {
annotate(annotation);
annotationOkay=true;
}
 catch (Exception ex) {
if (continueOnAnnotateError) {
err("Error annotating " + file.getAbsoluteFile(),ex);
annotationOkay=false;
synchronized (totalErrorAnnotating) {
  totalErrorAnnotating.incValue(1);
}
}
 else {
throw new RuntimeException("Error annotating " + file.getAbsoluteFile(),ex);
}
}
 finally {
endTrack("Annotating file " + file.getAbsoluteFile());
}
if (annotationOkay) {
switch (outputFormat) {
case XML:
{
  OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
  xmlPrint(annotation,fos);
  fos.close();
  break;
}
case TEXT:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
prettyPrint(annotation,fos);
fos.close();
break;
}
case SERIALIZED:
{
if (outputSerializerClass != null) {
AnnotationSerializer outputSerializer=ReflectionLoading.loadByReflection(inputSerializerClass);
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
outputSerializer.save(annotation,fos);
fos.close();
}
 else {
IOUtils.writeObjectToFile(annotation,outputFilename);
}
break;
}
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
synchronized (totalProcessed) {
totalProcessed.incValue(1);
if (totalProcessed.intValue() % 1000 == 0) {
log("Processed " + totalProcessed + " documents");
}
}
}
 else {
warn("Error annotating " + file.getAbsoluteFile() + " not saved to "+ outputFilename);
}
endTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
}
 catch (IOException e) {
throw new RuntimeIOException(e);
}
}
}
);
}
if (randomize) {
log("Randomly shuffling input");
Collections.shuffle(toRun);
}
log("Ready to process: " + toRun.size() + " files");
if (numThreads == 1) {
for (Runnable r : toRun) {
r.run();
}
}
 else {
Redwood.Util.threadAndRun("StanfordCoreNLP <" + numThreads + " threads>",toRun,numThreads);
}
log("Processed " + totalProcessed + " documents");
log("Skipped " + totalSkipped + " documents, error annotating "+ totalErrorAnnotating+ " documents");
}
