{
  List<Runnable> toRun=new LinkedList<Runnable>();
  final String baseOutputDir=properties.getProperty("outputDirectory",".");
  final String baseInputDir=properties.getProperty("inputDirectory",base);
  final OutputFormat outputFormat=OutputFormat.valueOf(properties.getProperty("outputFormat",DEFAULT_OUTPUT_FORMAT).toUpperCase());
  String defaultExtension;
switch (outputFormat) {
case XML:
    defaultExtension=".xml";
  break;
case TEXT:
defaultExtension=".out";
break;
case SERIALIZED:
defaultExtension=".ser.gz";
break;
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
String serializerClass=properties.getProperty("serializer");
AnnotationSerializer annotationSerializer=null;
if (serializerClass != null) {
annotationSerializer=ReflectionLoading.loadByReflection(serializerClass);
}
final AnnotationSerializer loadingSerializer=annotationSerializer;
final AnnotationSerializer outputSerializer=annotationSerializer;
final String extension=properties.getProperty("outputExtension",defaultExtension);
final boolean replaceExtension=Boolean.parseBoolean(properties.getProperty("replaceExtension","false"));
final boolean noClobber=Boolean.parseBoolean(properties.getProperty("noClobber","false"));
final MutableInteger totalProcessed=new MutableInteger(0);
for (final File file : files) {
toRun.add(new Runnable(){
@Override public void run(){
try {
String outputDir=baseOutputDir;
if (baseInputDir != null) {
String relDir=file.getParent().replaceFirst(Pattern.quote(baseInputDir),"");
outputDir=outputDir + File.separator + relDir;
}
new File(outputDir).mkdirs();
String outputFilename=new File(outputDir,file.getName()).getPath();
if (replaceExtension) {
int lastDot=outputFilename.lastIndexOf('.');
if (lastDot > 0) {
outputFilename=outputFilename.substring(0,lastDot);
}
}
if (!outputFilename.endsWith(extension)) {
outputFilename+=extension;
}
outputFilename=new File(outputFilename).getCanonicalPath();
if (outputFilename.equals(file.getCanonicalPath())) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " has the same filename as the input file -- assuming you don't actually want to do this.");
return;
}
if (noClobber && new File(outputFilename).exists()) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " as it already exists.  Don't use the noClobber option to override this.");
return;
}
forceTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
Annotation annotation=null;
if (file.getAbsolutePath().endsWith(".ser.gz")) {
try {
if (loadingSerializer != null) {
  annotation=loadingSerializer.load(new BufferedInputStream(new FileInputStream(file)));
}
 else {
  annotation=IOUtils.readObjectFromFile(file);
}
}
 catch (IOException e) {
}
catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
if (annotation == null) {
String encoding=getEncoding();
String text=IOUtils.slurpFile(file,encoding);
annotation=new Annotation(text);
}
forceTrack("Annotating file " + file.getAbsoluteFile());
try {
annotate(annotation);
}
 catch (Exception ex) {
warn("Error annotating " + file.getAbsoluteFile(),ex);
throw new RuntimeException(ex);
}
 finally {
endTrack("Annotating file " + file.getAbsoluteFile());
}
switch (outputFormat) {
case XML:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
xmlPrint(annotation,fos);
fos.close();
break;
}
case TEXT:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
prettyPrint(annotation,fos);
fos.close();
break;
}
case SERIALIZED:
{
if (outputSerializer != null) {
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
outputSerializer.save(annotation,fos);
fos.close();
}
 else {
IOUtils.writeObjectToFile(annotation,outputFilename);
}
break;
}
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
endTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
synchronized (totalProcessed) {
totalProcessed.incValue(1);
if (totalProcessed.intValue() % 1000 == 0) {
log("Processed " + totalProcessed + " documents");
}
}
}
 catch (IOException e) {
throw new RuntimeIOException(e);
}
}
}
);
}
if (numThreads == 1) {
for (Runnable r : toRun) {
r.run();
}
}
 else {
Redwood.Util.threadAndRun("StanfordCoreNLP <" + numThreads + " threads>",toRun,numThreads);
}
log("Processed " + totalProcessed + " documents");
}
