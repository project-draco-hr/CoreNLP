{
  List<Runnable> toRun=new LinkedList<Runnable>();
  final String baseOutputDir=properties.getProperty("outputDirectory",".");
  final String baseInputDir=properties.getProperty("inputDirectory",base);
  final String excludeFilesParam=properties.getProperty("excludeFiles");
  final Set<String> excludeFiles=new HashSet<String>();
  if (excludeFilesParam != null) {
    Iterable<String> lines=IOUtils.readLines(excludeFilesParam);
    for (    String line : lines) {
      String name=line.trim();
      if (!name.isEmpty())       excludeFiles.add(name);
    }
  }
  final OutputFormat outputFormat=OutputFormat.valueOf(properties.getProperty("outputFormat",DEFAULT_OUTPUT_FORMAT).toUpperCase());
  String defaultExtension;
switch (outputFormat) {
case XML:
    defaultExtension=".xml";
  break;
case TEXT:
defaultExtension=".out";
break;
case SERIALIZED:
defaultExtension=".ser.gz";
break;
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
final String serializerClass=properties.getProperty("serializer");
final String inputSerializerClass=properties.getProperty("inputSerializer",serializerClass);
final String inputSerializerName=(serializerClass == inputSerializerClass) ? "serializer" : "inputSerializer";
final String outputSerializerClass=properties.getProperty("outputSerializer",serializerClass);
final String outputSerializerName=(serializerClass == outputSerializerClass) ? "serializer" : "outputSerializer";
final String extension=properties.getProperty("outputExtension",defaultExtension);
final boolean replaceExtension=Boolean.parseBoolean(properties.getProperty("replaceExtension","false"));
final boolean continueOnAnnotateError=Boolean.parseBoolean(properties.getProperty("continueOnAnnotateError","false"));
final boolean noClobber=Boolean.parseBoolean(properties.getProperty("noClobber","false"));
final boolean randomize=Boolean.parseBoolean(properties.getProperty("randomize","false"));
final MutableInteger totalProcessed=new MutableInteger(0);
final MutableInteger totalSkipped=new MutableInteger(0);
final MutableInteger totalErrorAnnotating=new MutableInteger(0);
int nFiles=0;
for (final File file : files) {
nFiles++;
if (excludeFiles.contains(file.getName())) {
err("Skipping excluded file " + file.getName());
totalSkipped.incValue(1);
continue;
}
String outputDir=baseOutputDir;
if (baseInputDir != null) {
String relDir=file.getParent().replaceFirst(Pattern.quote(baseInputDir),"");
outputDir=outputDir + File.separator + relDir;
}
new File(outputDir).mkdirs();
String outputFilename=new File(outputDir,file.getName()).getPath();
if (replaceExtension) {
int lastDot=outputFilename.lastIndexOf('.');
if (lastDot > 0) {
outputFilename=outputFilename.substring(0,lastDot);
}
}
if (!outputFilename.endsWith(extension)) {
outputFilename+=extension;
}
outputFilename=new File(outputFilename).getCanonicalPath();
if (outputFilename.equals(file.getCanonicalPath())) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " has the same filename as the input file -- assuming you don't actually want to do this.");
totalSkipped.incValue(1);
continue;
}
if (noClobber && new File(outputFilename).exists()) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " as it already exists.  Don't use the noClobber option to override this.");
totalSkipped.incValue(1);
continue;
}
final String finalOutputFilename=outputFilename;
toRun.add(new Runnable(){
@Override public void run(){
try {
if (noClobber && new File(finalOutputFilename).exists()) {
err("Skipping " + file.getName() + ": output file "+ finalOutputFilename+ " as it already exists.  Don't use the noClobber option to override this.");
synchronized (totalSkipped) {
totalSkipped.incValue(1);
}
return;
}
forceTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ finalOutputFilename);
Annotation annotation=null;
if (file.getAbsolutePath().endsWith(".ser.gz")) {
try {
if (inputSerializerClass != null) {
  AnnotationSerializer inputSerializer=loadSerializer(inputSerializerClass,inputSerializerName,properties);
  InputStream is=new BufferedInputStream(new FileInputStream(file));
  annotation=inputSerializer.load(is);
  IOUtils.closeIgnoringExceptions(is);
}
 else {
  annotation=IOUtils.readObjectFromFile(file);
}
}
 catch (IOException e) {
}
catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
if (annotation == null) {
String encoding=getEncoding();
String text=IOUtils.slurpFile(file,encoding);
annotation=new Annotation(text);
}
boolean annotationOkay=false;
forceTrack("Annotating file " + file.getAbsoluteFile());
try {
annotate(annotation);
annotationOkay=true;
}
 catch (Exception ex) {
if (continueOnAnnotateError) {
err("Error annotating " + file.getAbsoluteFile(),ex);
annotationOkay=false;
synchronized (totalErrorAnnotating) {
  totalErrorAnnotating.incValue(1);
}
}
 else {
throw new RuntimeException("Error annotating " + file.getAbsoluteFile(),ex);
}
}
 finally {
endTrack("Annotating file " + file.getAbsoluteFile());
}
if (annotationOkay) {
switch (outputFormat) {
case XML:
{
  OutputStream fos=new BufferedOutputStream(new FileOutputStream(finalOutputFilename));
  xmlPrint(annotation,fos);
  fos.close();
  break;
}
case TEXT:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(finalOutputFilename));
prettyPrint(annotation,fos);
fos.close();
break;
}
case SERIALIZED:
{
if (outputSerializerClass != null) {
AnnotationSerializer outputSerializer=loadSerializer(outputSerializerClass,outputSerializerName,properties);
OutputStream fos=new BufferedOutputStream(new FileOutputStream(finalOutputFilename));
outputSerializer.save(annotation,fos);
fos.close();
}
 else {
IOUtils.writeObjectToFile(annotation,finalOutputFilename);
}
break;
}
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
synchronized (totalProcessed) {
totalProcessed.incValue(1);
if (totalProcessed.intValue() % 1000 == 0) {
log("Processed " + totalProcessed + " documents");
}
}
}
 else {
warn("Error annotating " + file.getAbsoluteFile() + " not saved to "+ finalOutputFilename);
}
endTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ finalOutputFilename);
}
 catch (IOException e) {
throw new RuntimeIOException(e);
}
}
}
);
}
if (randomize) {
log("Randomly shuffling input");
Collections.shuffle(toRun);
}
log("Ready to process: " + toRun.size() + " files, skipped "+ totalSkipped+ ", total "+ nFiles);
if (numThreads == 1) {
for (Runnable r : toRun) {
r.run();
}
}
 else {
Redwood.Util.threadAndRun("StanfordCoreNLP <" + numThreads + " threads>",toRun,numThreads);
}
log("Processed " + totalProcessed + " documents");
log("Skipped " + totalSkipped + " documents, error annotating "+ totalErrorAnnotating+ " documents");
}
