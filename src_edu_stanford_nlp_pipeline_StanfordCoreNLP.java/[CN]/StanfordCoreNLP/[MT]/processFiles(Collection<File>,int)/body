{
  List<Runnable> toRun=new LinkedList<Runnable>();
  for (  final File file : files) {
    toRun.add(new Runnable(){
      @Override public void run(){
        try {
          String outputFilename=new File(properties.getProperty("outputDirectory","."),file.getName()).getPath();
          if (properties.getProperty("replaceExtension") != null) {
            int lastDot=outputFilename.lastIndexOf('.');
            if (lastDot > 0) {
              outputFilename=outputFilename.substring(0,lastDot);
            }
          }
          OutputFormat outputFormat=OutputFormat.valueOf(properties.getProperty("outputFormat",DEFAULT_OUTPUT_FORMAT).toUpperCase());
          String defaultExtension;
switch (outputFormat) {
case XML:
            defaultExtension=".xml";
          break;
case TEXT:
        defaultExtension=".out";
      break;
case SERIALIZED:
    defaultExtension=".ser.gz";
  break;
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
String extension=properties.getProperty("outputExtension",defaultExtension);
if (!outputFilename.endsWith(extension)) {
outputFilename+=extension;
}
outputFilename=new File(outputFilename).getCanonicalPath();
if (outputFilename.equals(file.getCanonicalPath())) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " has the same filename as the input file -- assuming you don't actually want to do this.");
return;
}
if (properties.getProperty("noClobber") != null && new File(outputFilename).exists()) {
err("Skipping " + file.getName() + ": output file "+ outputFilename+ " as it already exists.  Don't use the noClobber option to override this.");
return;
}
Annotation annotation=null;
if (file.getAbsolutePath().endsWith(".ser.gz")) {
try {
annotation=IOUtils.readObjectFromFile(file);
}
 catch (IOException e) {
}
catch (ClassNotFoundException e) {
throw new RuntimeException(e);
}
}
if (annotation == null) {
String encoding=getEncoding();
String text=IOUtils.slurpFile(file,encoding);
annotation=new Annotation(text);
}
annotate(annotation);
forceTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
switch (outputFormat) {
case XML:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
xmlPrint(annotation,fos);
fos.close();
break;
}
case TEXT:
{
OutputStream fos=new BufferedOutputStream(new FileOutputStream(outputFilename));
prettyPrint(annotation,fos);
fos.close();
break;
}
case SERIALIZED:
{
IOUtils.writeObjectToFile(annotation,outputFilename);
break;
}
default :
throw new IllegalArgumentException("Unknown output format " + outputFormat);
}
endTrack("Processing file " + file.getAbsolutePath() + " ... writing to "+ outputFilename);
}
 catch (IOException e) {
throw new RuntimeIOException(e);
}
}
}
);
}
if (numThreads == 1) {
for (Runnable r : toRun) {
r.run();
}
}
 else {
Redwood.Util.threadAndRun("StanfordCoreNLP <" + numThreads + " threads>",toRun,numThreads);
}
}
