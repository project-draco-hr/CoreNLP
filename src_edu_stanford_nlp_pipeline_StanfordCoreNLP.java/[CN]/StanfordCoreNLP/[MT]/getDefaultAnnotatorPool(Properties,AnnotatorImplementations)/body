{
  if (pool == null) {
    pool=new AnnotatorPool();
  }
  pool.register(STANFORD_TOKENIZE,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      if (Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"))) {
        return annotatorImplementation.whitespaceTokenizer(properties);
      }
 else {
        String options=properties.getProperty("tokenize.options",null);
        boolean keepNewline=Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"));
        if (properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY) != null) {
          keepNewline=true;
        }
        if (keepNewline) {
          options="tokenizeNLs," + options;
        }
        return annotatorImplementation.ptbTokenizer(properties,false,options);
      }
    }
    @Override public String additionalSignature(){
      StringBuilder os=new StringBuilder();
      os.append("tokenize.whitespace:" + properties.getProperty("tokenize.whitespace","false"));
      if (properties.getProperty("tokenize.options") != null) {
        os.append(":tokenize.options:" + properties.getProperty("tokenize.options"));
      }
      if (Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"))) {
        os.append(WhitespaceTokenizerAnnotator.EOL_PROPERTY + ":" + properties.getProperty(WhitespaceTokenizerAnnotator.EOL_PROPERTY,"false"));
        os.append(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY + ":" + properties.getProperty(StanfordCoreNLP.NEWLINE_SPLITTER_PROPERTY,"false"));
        return os.toString();
      }
 else {
        os.append(NEWLINE_SPLITTER_PROPERTY + ":" + Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false")));
        os.append(NEWLINE_IS_SENTENCE_BREAK_PROPERTY + ":" + properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY,DEFAULT_NEWLINE_IS_SENTENCE_BREAK));
      }
      return os.toString();
    }
  }
);
  pool.register(STANFORD_CLEAN_XML,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String xmlTags=properties.getProperty("clean.xmltags",CleanXmlAnnotator.DEFAULT_XML_TAGS);
      String sentenceEndingTags=properties.getProperty("clean.sentenceendingtags",CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS);
      String singleSentenceTags=properties.getProperty("clean.singlesentencetags",CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS);
      String allowFlawedString=properties.getProperty("clean.allowflawedxml");
      boolean allowFlawed=CleanXmlAnnotator.DEFAULT_ALLOW_FLAWS;
      if (allowFlawedString != null)       allowFlawed=Boolean.valueOf(allowFlawedString);
      String dateTags=properties.getProperty("clean.datetags",CleanXmlAnnotator.DEFAULT_DATE_TAGS);
      String docIdTags=properties.getProperty("clean.docIdtags",CleanXmlAnnotator.DEFAULT_DOCID_TAGS);
      String docTypeTags=properties.getProperty("clean.docTypetags",CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS);
      String utteranceTurnTags=properties.getProperty("clean.turntags",CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS);
      String speakerTags=properties.getProperty("clean.speakertags",CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS);
      String docAnnotations=properties.getProperty("clean.docAnnotations",CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS);
      String tokenAnnotations=properties.getProperty("clean.tokenAnnotations",CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS);
      String sectionTags=properties.getProperty("clean.sectiontags",CleanXmlAnnotator.DEFAULT_SECTION_TAGS);
      String sectionAnnotations=properties.getProperty("clean.sectionAnnotations",CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);
      String ssplitDiscardTokens=properties.getProperty("clean.ssplitDiscardTokens");
      CleanXmlAnnotator annotator=annotatorImplementation.cleanXML(properties,xmlTags,sentenceEndingTags,dateTags,allowFlawed);
      annotator.setSingleSentenceTagMatcher(singleSentenceTags);
      annotator.setDocIdTagMatcher(docIdTags);
      annotator.setDocTypeTagMatcher(docTypeTags);
      annotator.setDiscourseTags(utteranceTurnTags,speakerTags);
      annotator.setDocAnnotationPatterns(docAnnotations);
      annotator.setTokenAnnotationPatterns(tokenAnnotations);
      annotator.setSectionTagMatcher(sectionTags);
      annotator.setSectionAnnotationPatterns(sectionAnnotations);
      annotator.setSsplitDiscardTokensMatcher(ssplitDiscardTokens);
      return annotator;
    }
    @Override public String additionalSignature(){
      return "clean.xmltags:" + properties.getProperty("clean.xmltags",CleanXmlAnnotator.DEFAULT_XML_TAGS) + "clean.sentenceendingtags:"+ properties.getProperty("clean.sentenceendingtags",CleanXmlAnnotator.DEFAULT_SENTENCE_ENDERS)+ "clean.sentenceendingtags:"+ properties.getProperty("clean.singlesentencetags",CleanXmlAnnotator.DEFAULT_SINGLE_SENTENCE_TAGS)+ "clean.allowflawedxml:"+ properties.getProperty("clean.allowflawedxml","")+ "clean.datetags:"+ properties.getProperty("clean.datetags",CleanXmlAnnotator.DEFAULT_DATE_TAGS)+ "clean.docidtags:"+ properties.getProperty("clean.docid",CleanXmlAnnotator.DEFAULT_DOCID_TAGS)+ "clean.doctypetags:"+ properties.getProperty("clean.doctype",CleanXmlAnnotator.DEFAULT_DOCTYPE_TAGS)+ "clean.turntags:"+ properties.getProperty("clean.turntags",CleanXmlAnnotator.DEFAULT_UTTERANCE_TURN_TAGS)+ "clean.speakertags:"+ properties.getProperty("clean.speakertags",CleanXmlAnnotator.DEFAULT_SPEAKER_TAGS)+ "clean.docAnnotations:"+ properties.getProperty("clean.docAnnotations",CleanXmlAnnotator.DEFAULT_DOC_ANNOTATIONS_PATTERNS)+ "clean.tokenAnnotations:"+ properties.getProperty("clean.tokenAnnotations",CleanXmlAnnotator.DEFAULT_TOKEN_ANNOTATIONS_PATTERNS)+ "clean.sectiontags:"+ properties.getProperty("clean.sectiontags",CleanXmlAnnotator.DEFAULT_SECTION_TAGS)+ "clean.sectionAnnotations:"+ properties.getProperty("clean.sectionAnnotations",CleanXmlAnnotator.DEFAULT_SECTION_ANNOTATIONS_PATTERNS);
    }
  }
);
  pool.register(STANFORD_SSPLIT,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      System.err.println(signature());
      boolean nlSplitting=Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"));
      if (nlSplitting) {
        boolean whitespaceTokenization=Boolean.valueOf(properties.getProperty("tokenize.whitespace","false"));
        if (whitespaceTokenization) {
          if (System.getProperty("line.separator").equals("\n")) {
            return WordsToSentencesAnnotator.newlineSplitter(false,"\n");
          }
 else {
            return WordsToSentencesAnnotator.newlineSplitter(false,System.getProperty("line.separator"),"\n");
          }
        }
 else {
          return WordsToSentencesAnnotator.newlineSplitter(false,PTBTokenizer.getNewlineToken());
        }
      }
 else {
        String isOneSentence=properties.getProperty("ssplit.isOneSentence");
        if (Boolean.parseBoolean(isOneSentence)) {
          return WordsToSentencesAnnotator.nonSplitter(false);
        }
        String boundaryMultiTokenRegex=properties.getProperty("ssplit.boundaryMultiTokenRegex");
        String tokenPatternsToDiscardProp=properties.getProperty("ssplit.tokenPatternsToDiscard");
        Set<String> tokenRegexesToDiscard=null;
        if (tokenPatternsToDiscardProp != null) {
          String[] toks=tokenPatternsToDiscardProp.split(",");
          tokenRegexesToDiscard=Generics.newHashSet(Arrays.asList(toks));
        }
        String boundaryTokenRegex=properties.getProperty("ssplit.boundaryTokenRegex");
        Set<String> boundariesToDiscard=null;
        String bounds=properties.getProperty("ssplit.boundariesToDiscard");
        if (bounds != null) {
          String[] toks=bounds.split(",");
          boundariesToDiscard=Generics.newHashSet(Arrays.asList(toks));
        }
        Set<String> htmlElementsToDiscard=null;
        bounds=properties.getProperty("ssplit.htmlBoundariesToDiscard");
        if (bounds != null) {
          String[] elements=bounds.split(",");
          htmlElementsToDiscard=Generics.newHashSet(Arrays.asList(elements));
        }
        String nlsb=properties.getProperty(NEWLINE_IS_SENTENCE_BREAK_PROPERTY,DEFAULT_NEWLINE_IS_SENTENCE_BREAK);
        return annotatorImplementation.wordToSentences(properties,false,boundaryTokenRegex,boundariesToDiscard,htmlElementsToDiscard,nlsb,boundaryMultiTokenRegex,tokenRegexesToDiscard);
      }
    }
    @Override public String additionalSignature(){
      StringBuilder os=new StringBuilder();
      if (Boolean.valueOf(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false"))) {
        os.append(NEWLINE_SPLITTER_PROPERTY + "=").append(properties.getProperty(NEWLINE_SPLITTER_PROPERTY,"false")).append("\n");
        os.append("tokenize.whitespace=").append(properties.getProperty("tokenize.whitespace","false")).append("\n");
      }
 else {
        os.append(baseSignature(properties,STANFORD_SSPLIT));
      }
      return os.toString();
    }
  }
);
  pool.register(STANFORD_POS,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      try {
        return annotatorImplementation.posTagger(properties);
      }
 catch (      Exception e) {
        throw new RuntimeException(e);
      }
    }
    @Override public String additionalSignature(){
      return POSTaggerAnnotator.signature(properties);
    }
  }
);
  pool.register(STANFORD_LEMMA,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.morpha(properties,false);
    }
    @Override public String additionalSignature(){
      return "";
    }
  }
);
  pool.register(STANFORD_NER,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      try {
        return annotatorImplementation.ner(properties);
      }
 catch (      FileNotFoundException e) {
        throw new RuntimeIOException(e);
      }
    }
    @Override public String additionalSignature(){
      return "ner.model:" + properties.getProperty("ner.model","") + NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY+ ":"+ properties.getProperty(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_PROPERTY,Boolean.toString(NERClassifierCombiner.APPLY_NUMERIC_CLASSIFIERS_DEFAULT))+ NumberSequenceClassifier.USE_SUTIME_PROPERTY+ ":"+ properties.getProperty(NumberSequenceClassifier.USE_SUTIME_PROPERTY,Boolean.toString(NumberSequenceClassifier.USE_SUTIME_DEFAULT));
    }
  }
);
  pool.register(STANFORD_REGEXNER,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.tokensRegexNER(properties,"regexner");
    }
    @Override public String additionalSignature(){
      return PropertiesUtils.getSignature("regexner",properties,TokensRegexNERAnnotator.SUPPORTED_PROPERTIES);
    }
  }
);
  pool.register(STANFORD_GENDER,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.gender(properties,false);
    }
    @Override public String additionalSignature(){
      return "gender.firstnames:" + properties.getProperty("gender.firstnames",DefaultPaths.DEFAULT_GENDER_FIRST_NAMES);
    }
  }
);
  pool.register(STANFORD_TRUECASE,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      String model=properties.getProperty("truecase.model",DefaultPaths.DEFAULT_TRUECASE_MODEL);
      String bias=properties.getProperty("truecase.bias",TrueCaseAnnotator.DEFAULT_MODEL_BIAS);
      String mixed=properties.getProperty("truecase.mixedcasefile",DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);
      return annotatorImplementation.trueCase(properties,model,bias,mixed,false);
    }
    @Override public String additionalSignature(){
      return "truecase.model:" + properties.getProperty("truecase.model",DefaultPaths.DEFAULT_TRUECASE_MODEL) + "truecase.bias:"+ properties.getProperty("truecase.bias",TrueCaseAnnotator.DEFAULT_MODEL_BIAS)+ "truecase.mixedcasefile:"+ properties.getProperty("truecase.mixedcasefile",DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);
    }
  }
);
  pool.register(STANFORD_PARSE,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.parse(properties);
    }
    @Override public String additionalSignature(){
      String type=properties.getProperty("parse.type","stanford");
      if (type.equalsIgnoreCase("stanford")) {
        return ParserAnnotator.signature("parse",properties);
      }
 else       if (type.equalsIgnoreCase("charniak")) {
        return "parse.model:" + properties.getProperty("parse.model","") + "parse.executable:"+ properties.getProperty("parse.executable","")+ "parse.maxlen:"+ properties.getProperty("parse.maxlen","");
      }
 else {
        throw new RuntimeException("Unknown parser type: " + type + " (currently supported: stanford and charniak)");
      }
    }
  }
);
  pool.register(STANFORD_DETERMINISTIC_COREF,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.coref(properties);
    }
    @Override public String additionalSignature(){
      return DeterministicCorefAnnotator.signature(properties);
    }
  }
);
  for (  Object propertyKey : inputProps.stringPropertyNames()) {
    if (!(propertyKey instanceof String))     continue;
    final String property=(String)propertyKey;
    if (property.startsWith(CUSTOM_ANNOTATOR_PREFIX)) {
      final String customName=property.substring(CUSTOM_ANNOTATOR_PREFIX.length());
      final String customClassName=inputProps.getProperty(property);
      System.err.println("Registering annotator " + customName + " with class "+ customClassName);
      pool.register(customName,new AnnotatorFactory(inputProps,annotatorImplementation){
        private static final long serialVersionUID=1L;
        @Override public Annotator create(){
          return annotatorImplementation.custom(properties,property);
        }
        @Override public String additionalSignature(){
          StringBuilder os=new StringBuilder();
          for (          Object key : properties.keySet()) {
            String skey=(String)key;
            os.append(skey + ":" + properties.getProperty(skey));
          }
          return os.toString();
        }
      }
);
    }
  }
  pool.register(STANFORD_RELATION,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.relations(properties);
    }
    @Override public String additionalSignature(){
      return "sup.relation.verbose:" + properties.getProperty("sup.relation.verbose","false") + properties.getProperty("sup.relation.model",DefaultPaths.DEFAULT_SUP_RELATION_EX_RELATION_MODEL);
    }
  }
);
  pool.register(STANFORD_SENTIMENT,new AnnotatorFactory(inputProps,annotatorImplementation){
    private static final long serialVersionUID=1L;
    @Override public Annotator create(){
      return annotatorImplementation.sentiment(properties,STANFORD_SENTIMENT);
    }
    @Override public String additionalSignature(){
      return "sentiment.model=" + inputProps.get("sentiment.model");
    }
  }
);
  return pool;
}
