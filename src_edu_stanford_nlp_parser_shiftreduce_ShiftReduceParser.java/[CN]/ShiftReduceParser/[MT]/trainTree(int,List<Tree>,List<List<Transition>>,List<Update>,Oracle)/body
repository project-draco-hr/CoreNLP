{
  int numCorrect=0;
  int numWrong=0;
  Tree tree=binarizedTrees.get(index);
  State state=ShiftReduceParser.initialStateFromGoldTagTree(tree);
  if (op.trainingErrorHandling == ShiftReduceOptions.TrainingErrorHandling.ORACLE) {
    while (!state.isFinished()) {
      List<String> features=featureFactory.featurize(state);
      ScoredObject<Integer> prediction=findHighestScoringTransition(state,features,true);
      if (prediction == null) {
        break;
      }
      int predictedNum=prediction.object();
      Transition predicted=transitionIndex.get(predictedNum);
      OracleTransition gold=oracle.goldTransition(index,state);
      if (gold.isCorrect(predicted)) {
        numCorrect++;
        if (gold.transition != null && !gold.transition.equals(predicted)) {
          int transitionNum=transitionIndex.indexOf(gold.transition);
          if (transitionNum < 0) {
            continue;
          }
          updates.add(new Update(features,transitionNum,-1,1.0));
        }
      }
 else {
        numWrong++;
        int transitionNum=-1;
        if (gold.transition != null) {
          transitionNum=transitionIndex.indexOf(gold.transition);
        }
        updates.add(new Update(features,transitionNum,predictedNum,1.0));
      }
      state=predicted.apply(state);
    }
  }
 else {
    List<Transition> transitions=transitionLists.get(index);
    for (    Transition transition : transitions) {
      int transitionNum=transitionIndex.indexOf(transition);
      List<String> features=featureFactory.featurize(state);
      int predictedNum=findHighestScoringTransition(state,features,false).object();
      Transition predicted=transitionIndex.get(predictedNum);
      if (transitionNum == predictedNum) {
        numCorrect++;
      }
 else {
        numWrong++;
        updates.add(new Update(features,transitionNum,predictedNum,1.0));
      }
      if (op.trainingErrorHandling == ShiftReduceOptions.TrainingErrorHandling.EARLY_TERMINATION && transitionNum != predictedNum) {
        break;
      }
      state=transition.apply(state);
    }
  }
  return Pair.makePair(numCorrect,numWrong);
}
