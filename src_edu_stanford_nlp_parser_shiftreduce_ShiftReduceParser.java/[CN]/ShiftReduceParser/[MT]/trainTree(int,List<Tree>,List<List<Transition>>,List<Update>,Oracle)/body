{
  int numCorrect=0;
  int numWrong=0;
  Tree tree=binarizedTrees.get(index);
  if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.ORACLE) {
    State state=ShiftReduceParser.initialStateFromGoldTagTree(tree);
    while (!state.isFinished()) {
      List<String> features=featureFactory.featurize(state);
      ScoredObject<Integer> prediction=findHighestScoringTransition(state,features,true);
      if (prediction == null) {
        throw new AssertionError("Did not find a legal transition");
      }
      int predictedNum=prediction.object();
      Transition predicted=transitionIndex.get(predictedNum);
      OracleTransition gold=oracle.goldTransition(index,state);
      if (gold.isCorrect(predicted)) {
        numCorrect++;
        if (gold.transition != null && !gold.transition.equals(predicted)) {
          int transitionNum=transitionIndex.indexOf(gold.transition);
          if (transitionNum < 0) {
            continue;
          }
          updates.add(new Update(features,transitionNum,-1,1.0f));
        }
      }
 else {
        numWrong++;
        int transitionNum=-1;
        if (gold.transition != null) {
          transitionNum=transitionIndex.indexOf(gold.transition);
        }
        updates.add(new Update(features,transitionNum,predictedNum,1.0f));
      }
      state=predicted.apply(state);
    }
  }
 else   if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.BEAM) {
    if (op.trainOptions().beamSize <= 0) {
      throw new IllegalArgumentException("Illegal beam size " + op.trainOptions().beamSize);
    }
    List<Transition> transitions=transitionLists.get(index);
    PriorityQueue<State> agenda=new PriorityQueue<State>(op.trainOptions().beamSize + 1,ScoredComparator.ASCENDING_COMPARATOR);
    State goldState=ShiftReduceParser.initialStateFromGoldTagTree(tree);
    agenda.add(goldState);
    int transitionCount=0;
    for (    Transition goldTransition : transitions) {
      PriorityQueue<State> newAgenda=new PriorityQueue<State>(op.trainOptions().beamSize + 1,ScoredComparator.ASCENDING_COMPARATOR);
      State highestScoringState=null;
      State highestCurrentState=null;
      for (      State currentState : agenda) {
        List<String> features=featureFactory.featurize(currentState);
        Collection<ScoredObject<Integer>> stateTransitions=findHighestScoringTransitions(currentState,features,true,op.trainOptions().beamSize);
        for (        ScoredObject<Integer> transition : stateTransitions) {
          State newState=transitionIndex.get(transition.object()).apply(currentState,transition.score());
          newAgenda.add(newState);
          if (newAgenda.size() > op.trainOptions().beamSize) {
            newAgenda.poll();
          }
          if (highestScoringState == null || highestScoringState.score() < newState.score()) {
            highestScoringState=newState;
            highestCurrentState=currentState;
          }
        }
      }
      List<String> goldFeatures=featureFactory.featurize(goldState);
      goldState=goldTransition.apply(goldState,0.0);
      if (!goldState.areTransitionsEqual(highestScoringState)) {
        ++numWrong;
        int lastTransition=transitionIndex.indexOf(highestScoringState.transitions.peek());
        updates.add(new Update(featureFactory.featurize(highestCurrentState),-1,lastTransition,1.0f));
        updates.add(new Update(goldFeatures,transitionIndex.indexOf(goldTransition),-1,1.0f));
      }
 else {
        ++numCorrect;
      }
      boolean found=false;
      for (      State otherState : newAgenda) {
        if (otherState.areTransitionsEqual(goldState)) {
          found=true;
          break;
        }
      }
      if (!found) {
        break;
      }
      agenda=newAgenda;
    }
  }
 else {
    State state=ShiftReduceParser.initialStateFromGoldTagTree(tree);
    List<Transition> transitions=transitionLists.get(index);
    for (    Transition transition : transitions) {
      int transitionNum=transitionIndex.indexOf(transition);
      List<String> features=featureFactory.featurize(state);
      int predictedNum=findHighestScoringTransition(state,features,false).object();
      Transition predicted=transitionIndex.get(predictedNum);
      if (transitionNum == predictedNum) {
        numCorrect++;
      }
 else {
        numWrong++;
        updates.add(new Update(features,transitionNum,predictedNum,1.0f));
      }
      if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.EARLY_TERMINATION && transitionNum != predictedNum) {
        break;
      }
      state=transition.apply(state);
    }
  }
  return Pair.makePair(numCorrect,numWrong);
}
