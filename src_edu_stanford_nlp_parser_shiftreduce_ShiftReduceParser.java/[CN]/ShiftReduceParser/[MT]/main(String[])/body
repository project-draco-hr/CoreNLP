{
  List<String> remainingArgs=Generics.newArrayList();
  String trainTreebankPath=null;
  FileFilter trainTreebankFilter=null;
  String testTreebankPath=null;
  FileFilter testTreebankFilter=null;
  String devTreebankPath=null;
  FileFilter devTreebankFilter=null;
  String serializedPath=null;
  String tlppClass=null;
  for (int argIndex=0; argIndex < args.length; ) {
    if (args[argIndex].equalsIgnoreCase("-trainTreebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-trainTreebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      trainTreebankPath=treebankDescription.first();
      trainTreebankFilter=treebankDescription.second();
    }
 else     if (args[argIndex].equalsIgnoreCase("-testTreebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-testTreebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      testTreebankPath=treebankDescription.first();
      testTreebankFilter=treebankDescription.second();
    }
 else     if (args[argIndex].equalsIgnoreCase("-devTreebank")) {
      Pair<String,FileFilter> treebankDescription=ArgUtils.getTreebankDescription(args,argIndex,"-devTreebank");
      argIndex=argIndex + ArgUtils.numSubArgs(args,argIndex) + 1;
      devTreebankPath=treebankDescription.first();
      devTreebankFilter=treebankDescription.second();
    }
 else     if (args[argIndex].equalsIgnoreCase("-serializedPath")) {
      serializedPath=args[argIndex + 1];
      argIndex+=2;
    }
 else     if (args[argIndex].equalsIgnoreCase("-tlpp")) {
      tlppClass=args[argIndex] + 1;
      argIndex+=2;
    }
 else {
      remainingArgs.add(args[argIndex]);
      ++argIndex;
    }
  }
  String[] newArgs=new String[remainingArgs.size()];
  newArgs=remainingArgs.toArray(newArgs);
  if (trainTreebankPath == null && serializedPath == null) {
    throw new IllegalArgumentException("Must specify a treebank to train from with -trainTreebank");
  }
  ShiftReduceParser parser=null;
  if (trainTreebankPath != null) {
    ShiftReduceOptions op=buildTrainingOptions(tlppClass,newArgs);
    parser=new ShiftReduceParser(op);
    List<Tree> binarizedTrees=parser.readBinarizedTreebank(trainTreebankPath,trainTreebankFilter);
    Index<Transition> transitionIndex=parser.transitionIndex;
    int nThreads=op.trainOptions.trainingThreads;
    nThreads=nThreads <= 0 ? Runtime.getRuntime().availableProcessors() : nThreads;
    MaxentTagger tagger=null;
    if (op.testOptions.preTag) {
      Timing retagTimer=new Timing();
      tagger=new MaxentTagger(op.testOptions.taggerSerializedFile);
      redoTags(binarizedTrees,tagger,nThreads);
      retagTimer.done("Retagging");
    }
    Timing transitionTimer=new Timing();
    List<List<Transition>> transitionLists=parser.createTransitionSequences(binarizedTrees);
    for (    List<Transition> transitions : transitionLists) {
      transitionIndex.addAll(transitions);
    }
    transitionTimer.done("Converting trees into transition lists");
    System.err.println("Number of transitions: " + transitionIndex.size());
    FeatureFactory featureFactory=parser.featureFactory;
    Map<String,List<ScoredObject<Integer>>> featureWeights=parser.featureWeights;
    Random random=new Random(parser.op.trainOptions.randomSeed);
    Treebank devTreebank=null;
    if (devTreebankPath != null) {
      devTreebank=parser.readTreebank(devTreebankPath,devTreebankFilter);
    }
    double bestScore=0.0;
    int bestIteration=0;
    PriorityQueue<ScoredObject<ShiftReduceParser>> bestModels=null;
    if (parser.op.averagedModels > 0) {
      bestModels=new PriorityQueue<ScoredObject<ShiftReduceParser>>(parser.op.averagedModels + 1,ScoredComparator.ASCENDING_COMPARATOR);
    }
    List<Integer> indices=Generics.newArrayList();
    for (int i=0; i < binarizedTrees.size(); ++i) {
      indices.add(i);
    }
    for (int iteration=1; iteration <= parser.op.trainOptions.trainingIterations; ++iteration) {
      Timing trainingTimer=new Timing();
      int numCorrect=0;
      int numWrong=0;
      Collections.shuffle(indices,random);
      for (int i=0; i < indices.size(); ++i) {
        int index=indices.get(i);
        Tree tree=binarizedTrees.get(index);
        List<Transition> transitions=transitionLists.get(index);
        State state=ShiftReduceParser.initialStateFromGoldTagTree(tree);
        for (        Transition transition : transitions) {
          int transitionNum=transitionIndex.indexOf(transition);
          List<String> features=featureFactory.featurize(state);
          int predictedNum=parser.findHighestScoringTransition(state,features,false).object();
          Transition predicted=transitionIndex.get(predictedNum);
          if (transitionNum == predictedNum) {
            numCorrect++;
          }
 else {
            numWrong++;
            for (            String feature : features) {
              List<ScoredObject<Integer>> weights=featureWeights.get(feature);
              if (weights == null) {
                weights=Generics.newArrayList();
                featureWeights.put(feature,weights);
              }
              ShiftReduceParser.updateWeight(weights,transitionNum,1.0);
              ShiftReduceParser.updateWeight(weights,predictedNum,-1.0);
            }
          }
          state=transition.apply(state);
        }
      }
      trainingTimer.done("Iteration " + iteration);
      System.err.println("While training, got " + numCorrect + " transitions correct and "+ numWrong+ " transitions wrong");
      System.err.println("Number of weight vectors: " + featureWeights.size());
      double labelF1=0.0;
      if (devTreebank != null) {
        EvaluateTreebank evaluator=new EvaluateTreebank(parser.op,null,parser,tagger);
        evaluator.testOnTreebank(devTreebank);
        labelF1=evaluator.getLBScore();
        System.err.println("Label F1 after " + iteration + " iterations: "+ labelF1);
        if (labelF1 > bestScore) {
          System.err.println("New best dev score (previous best " + bestScore + ")");
          bestScore=labelF1;
          bestIteration=iteration;
        }
 else {
          System.err.println("Failed to improve for " + (iteration - bestIteration) + " iteration(s) on previous best score of "+ bestScore);
          if (op.trainOptions.stalledIterationLimit > 0 && (iteration - bestIteration >= op.trainOptions.stalledIterationLimit)) {
            System.err.println("Failed to improve for too long, stopping training");
            break;
          }
        }
        if (bestModels != null) {
          bestModels.add(new ScoredObject<ShiftReduceParser>(parser.deepCopy(),labelF1));
          if (bestModels.size() > parser.op.averagedModels) {
            bestModels.poll();
          }
        }
      }
      if (serializedPath != null && parser.op.trainOptions.debugOutputFrequency > 0) {
        String tempName=serializedPath.substring(0,serializedPath.length() - 7) + "-" + FILENAME.format(iteration)+ "-"+ NF.format(labelF1)+ ".ser.gz";
        try {
          IOUtils.writeObjectToFile(parser,tempName);
        }
 catch (        IOException e) {
          throw new RuntimeIOException(e);
        }
      }
    }
    if (bestModels != null) {
      if (op.cvAveragedModels && devTreebank != null) {
        List<ScoredObject<ShiftReduceParser>> models=Generics.newArrayList();
        while (bestModels.size() > 0) {
          models.add(bestModels.poll());
        }
        Collections.reverse(models);
        double bestF1=0.0;
        int bestSize=0;
        for (int i=1; i < models.size(); ++i) {
          System.err.println("Testing with " + i + " models averaged together");
          parser=averageModels(models.subList(0,i));
          EvaluateTreebank evaluator=new EvaluateTreebank(parser.op,null,parser);
          evaluator.testOnTreebank(devTreebank);
          double labelF1=evaluator.getLBScore();
          System.err.println("Label F1 for " + i + " models: "+ labelF1);
          if (labelF1 > bestF1) {
            bestF1=labelF1;
            bestSize=i;
          }
        }
        parser=averageModels(models.subList(0,bestSize));
      }
 else {
        parser=ShiftReduceParser.averageModels(bestModels);
      }
    }
    parser.condenseFeatures();
    if (serializedPath != null) {
      try {
        IOUtils.writeObjectToFile(parser,serializedPath);
      }
 catch (      IOException e) {
        throw new RuntimeIOException(e);
      }
    }
  }
  if (serializedPath != null && parser == null) {
    try {
      parser=IOUtils.readObjectFromFile(serializedPath);
      parser.op.setOptions("-forceTags");
    }
 catch (    IOException e) {
      throw new RuntimeIOException(e);
    }
catch (    ClassNotFoundException e) {
      throw new RuntimeIOException(e);
    }
    parser.op.setOptions(newArgs);
  }
  if (testTreebankPath != null) {
    System.err.println("Loading test trees from " + testTreebankPath);
    Treebank testTreebank=parser.op.tlpParams.memoryTreebank();
    testTreebank.loadPath(testTreebankPath,testTreebankFilter);
    System.err.println("Loaded " + testTreebank.size() + " trees");
    EvaluateTreebank evaluator=new EvaluateTreebank(parser.op,null,parser);
    evaluator.testOnTreebank(testTreebank);
  }
}
