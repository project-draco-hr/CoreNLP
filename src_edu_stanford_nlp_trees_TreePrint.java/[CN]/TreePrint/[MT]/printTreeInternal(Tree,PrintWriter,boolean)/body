{
  Tree outputTree=t;
  if (formats.containsKey("conll2007") || removeEmpty) {
    outputTree=outputTree.prune(new BobChrisTreeNormalizer.EmptyFilter());
  }
  if (formats.containsKey("words")) {
    if (inXml) {
      ArrayList<Label> sentUnstemmed=outputTree.yield();
      pw.println("  <words>");
      int i=1;
      for (      Label w : sentUnstemmed) {
        pw.println("    <word ind=\"" + i + "\">"+ XMLUtils.escapeXML(w.value())+ "</word>");
        i++;
      }
      pw.println("  </words>");
    }
 else {
      String sent=Sentence.listToString(outputTree.yield(),false);
      if (ptb2text) {
        pw.println(PTBTokenizer.ptb2Text(sent));
      }
 else {
        pw.println(sent);
        pw.println();
      }
    }
  }
  if (propertyToBoolean(options,"removeTopBracket")) {
    String s=outputTree.label().value();
    if (tlp.isStartSymbol(s)) {
      if (outputTree.isUnaryRewrite()) {
        outputTree=outputTree.firstChild();
      }
 else {
        System.err.println("TreePrint: can't remove top bracket: not unary");
      }
    }
  }
  if (stemmer != null) {
    stemmer.visitTree(outputTree);
  }
  if (lexicalize) {
    outputTree=Trees.lexicalize(outputTree,hf);
    Function<Tree,Tree> a=TreeFunctions.getLabeledToDescriptiveCoreLabelTreeFunction();
    outputTree=a.apply(outputTree);
  }
  if (formats.containsKey("collocations")) {
    outputTree=getCollocationProcessedTree(outputTree,hf);
  }
  if (!lexicalize) {
    Function<Tree,Tree> a=TreeFunctions.getLabeledTreeToStringLabeledTreeFunction();
    outputTree=a.apply(outputTree);
  }
  Tree outputPSTree=outputTree;
  if (markHeadNodes) {
    outputPSTree=markHeadNodes(outputPSTree);
  }
  if (transChinese) {
    TreeTransformer tt=new TreeTransformer(){
      public Tree transformTree(      Tree t){
        t=t.treeSkeletonCopy();
        for (        Tree subtree : t) {
          if (subtree.isLeaf()) {
            Label oldLabel=subtree.label();
            String translation=ChineseEnglishWordMap.getInstance().getFirstTranslation(oldLabel.value());
            if (translation == null)             translation="[UNK]";
            Label newLabel=new StringLabel(oldLabel.value() + ':' + translation);
            subtree.setLabel(newLabel);
          }
        }
        return t;
      }
    }
;
    outputPSTree=tt.transformTree(outputPSTree);
  }
  if (propertyToBoolean(options,"xml")) {
    if (formats.containsKey("wordsAndTags")) {
      ArrayList<TaggedWord> sent=outputTree.taggedYield();
      pw.println("  <words pos=\"true\">");
      int i=1;
      for (      TaggedWord tw : sent) {
        pw.println("    <word ind=\"" + i + "\" pos=\""+ XMLUtils.escapeXML(tw.tag())+ "\">"+ XMLUtils.escapeXML(tw.word())+ "</word>");
        i++;
      }
      pw.println("  </words>");
    }
    if (formats.containsKey("penn")) {
      pw.println("  <tree style=\"penn\">");
      StringWriter sw=new StringWriter();
      PrintWriter psw=new PrintWriter(sw);
      outputPSTree.pennPrint(psw);
      pw.print(XMLUtils.escapeXML(sw.toString()));
      pw.println("  </tree>");
    }
    if (formats.containsKey("latexTree")) {
      pw.println("    <tree style=\"latexTrees\">");
      pw.println(".[");
      StringWriter sw=new StringWriter();
      PrintWriter psw=new PrintWriter(sw);
      outputTree.indentedListPrint(psw,false);
      pw.print(XMLUtils.escapeXML(sw.toString()));
      pw.println(".]");
      pw.println("  </tree>");
    }
    if (formats.containsKey("xmlTree")) {
      pw.println("<tree style=\"xml\">");
      outputTree.indentedXMLPrint(pw,false);
      pw.println("</tree>");
    }
    if (formats.containsKey("dependencies")) {
      Tree indexedTree=outputTree.deepCopy(outputTree.treeFactory(),CoreLabel.factory());
      indexedTree.indexLeaves();
      Set<Dependency<Label,Label,Object>> depsSet=indexedTree.mapDependencies(dependencyWordFilter,hf);
      List<Dependency<Label,Label,Object>> sortedDeps=new ArrayList<Dependency<Label,Label,Object>>(depsSet);
      Collections.sort(sortedDeps,Dependencies.dependencyIndexComparator());
      pw.println("<dependencies style=\"untyped\">");
      for (      Dependency<Label,Label,Object> d : sortedDeps) {
        pw.println(d.toString("xml"));
      }
      pw.println("</dependencies>");
    }
    if (formats.containsKey("conll2007") || formats.containsKey("conllStyleDependencies")) {
      System.err.println("The \"conll2007\" and \"conllStyleDependencies\" formats are ignored in xml.");
    }
    if (formats.containsKey("typedDependencies")) {
      GrammaticalStructure gs=gsf.newGrammaticalStructure(outputTree);
      if (basicDependencies) {
        print(gs.typedDependencies(),"xml",includeTags,pw);
      }
      if (nonCollapsedDependencies || nonCollapsedDependenciesSeparated) {
        print(gs.allTypedDependencies(),"xml",includeTags,pw);
      }
      if (collapsedDependencies) {
        print(gs.typedDependenciesCollapsed(true),"xml",includeTags,pw);
      }
      if (CCPropagatedDependencies) {
        print(gs.typedDependenciesCCprocessed(),"xml",includeTags,pw);
      }
      if (treeDependencies) {
        print(gs.typedDependenciesCollapsedTree(),"xml",includeTags,pw);
      }
    }
    if (formats.containsKey("typedDependenciesCollapsed")) {
      GrammaticalStructure gs=gsf.newGrammaticalStructure(outputTree);
      print(gs.typedDependenciesCCprocessed(),"xml",includeTags,pw);
    }
  }
 else {
    if (formats.containsKey("wordsAndTags")) {
      pw.println(Sentence.listToString(outputTree.taggedYield(),false));
      pw.println();
    }
    if (formats.containsKey("oneline")) {
      pw.println(outputPSTree.toString());
    }
    if (formats.containsKey("penn")) {
      outputPSTree.pennPrint(pw);
      pw.println();
    }
    if (formats.containsKey(rootLabelOnlyFormat)) {
      pw.println(outputTree.label().value());
    }
    if (formats.containsKey("latexTree")) {
      pw.println(".[");
      outputTree.indentedListPrint(pw,false);
      pw.println(".]");
    }
    if (formats.containsKey("xmlTree")) {
      outputTree.indentedXMLPrint(pw,false);
    }
    if (formats.containsKey("dependencies")) {
      Tree indexedTree=outputTree.deepCopy(outputTree.treeFactory());
      indexedTree.indexLeaves();
      List<Dependency<Label,Label,Object>> sortedDeps=getSortedDeps(indexedTree,dependencyWordFilter);
      for (      Dependency<Label,Label,Object> d : sortedDeps) {
        pw.println(d.toString("predicate"));
      }
      pw.println();
    }
    if (formats.containsKey("conll2007")) {
      Tree it=outputTree.deepCopy(outputTree.treeFactory(),CoreLabel.factory());
      it.indexLeaves();
      List<CoreLabel> tagged=it.taggedLabeledYield();
      List<Dependency<Label,Label,Object>> sortedDeps=getSortedDeps(it,dependencyFilter);
      for (int i=0; i < tagged.size(); i++) {
        CoreLabel w=tagged.get(i);
        Dependency<Label,Label,Object> d=sortedDeps.get(i);
        CoreMap dep=(CoreMap)d.dependent();
        CoreMap gov=(CoreMap)d.governor();
        Integer depi=dep.get(CoreAnnotations.IndexAnnotation.class);
        Integer govi=gov.get(CoreAnnotations.IndexAnnotation.class);
        String tag=PTBTokenizer.ptbToken2Text(w.tag());
        String word=PTBTokenizer.ptbToken2Text(w.word());
        String lemma="_";
        String feats="_";
        String pHead="_";
        String pDepRel="_";
        String depRel;
        if (d.name() != null) {
          depRel=d.name().toString();
        }
 else {
          depRel=(govi == 0) ? "ROOT" : "NULL";
        }
        pw.printf("%d\t%s\t%s\t%s\t%s\t%s\t%d\t%s\t%s\t%s%n",depi,word,lemma,tag,tag,feats,govi,depRel,pHead,pDepRel);
      }
      pw.println();
    }
    if (formats.containsKey("conllStyleDependencies")) {
      BobChrisTreeNormalizer tn=new BobChrisTreeNormalizer();
      Tree indexedTree=outputTree.deepCopy(outputTree.treeFactory(),CoreLabel.factory());
      for (      Tree node : indexedTree) {
        if (node.label().value().startsWith("NML")) {
          node.label().setValue("NP");
        }
      }
      indexedTree=tn.normalizeWholeTree(indexedTree,outputTree.treeFactory());
      indexedTree.indexLeaves();
      Set<Dependency<Label,Label,Object>> depsSet=null;
      boolean failed=false;
      try {
        depsSet=indexedTree.mapDependencies(dependencyFilter,hf);
      }
 catch (      Exception e) {
        failed=true;
      }
      if (failed) {
        System.err.println("failed: ");
        System.err.println(t);
        System.err.println();
      }
 else {
        Map<Integer,Integer> deps=Generics.newHashMap();
        for (        Dependency<Label,Label,Object> dep : depsSet) {
          CoreLabel child=(CoreLabel)dep.dependent();
          CoreLabel parent=(CoreLabel)dep.governor();
          Integer childIndex=child.get(CoreAnnotations.IndexAnnotation.class);
          Integer parentIndex=parent.get(CoreAnnotations.IndexAnnotation.class);
          deps.put(childIndex,parentIndex);
        }
        boolean foundRoot=false;
        int index=1;
        for (        Tree node : indexedTree.getLeaves()) {
          String word=node.label().value();
          String tag=node.parent(indexedTree).label().value();
          int parent=0;
          if (deps.containsKey(index)) {
            parent=deps.get(index);
          }
 else {
            if (foundRoot) {
              throw new RuntimeException();
            }
            foundRoot=true;
          }
          pw.println(index + "\t" + word+ "\t"+ tag+ "\t"+ parent);
          index++;
        }
        pw.println();
      }
    }
    if (formats.containsKey("typedDependencies")) {
      GrammaticalStructure gs=gsf.newGrammaticalStructure(outputTree);
      if (basicDependencies) {
        print(gs.typedDependencies(),includeTags,pw);
      }
      if (nonCollapsedDependencies) {
        print(gs.allTypedDependencies(),includeTags,pw);
      }
      if (nonCollapsedDependenciesSeparated) {
        print(gs.allTypedDependencies(),"separator",includeTags,pw);
      }
      if (collapsedDependencies) {
        print(gs.typedDependenciesCollapsed(true),includeTags,pw);
      }
      if (CCPropagatedDependencies) {
        print(gs.typedDependenciesCCprocessed(),includeTags,pw);
      }
      if (treeDependencies) {
        print(gs.typedDependenciesCollapsedTree(),includeTags,pw);
      }
    }
    if (formats.containsKey("typedDependenciesCollapsed")) {
      GrammaticalStructure gs=gsf.newGrammaticalStructure(outputTree);
      print(gs.typedDependenciesCCprocessed(),includeTags,pw);
    }
  }
  pw.flush();
}
