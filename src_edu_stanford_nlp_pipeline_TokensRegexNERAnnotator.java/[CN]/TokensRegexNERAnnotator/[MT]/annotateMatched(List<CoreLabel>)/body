{
  List<SequenceMatchResult<CoreMap>> matched=multiPatternMatcher.findNonOverlapping(tokens);
  for (  SequenceMatchResult<CoreMap> m : matched) {
    Entry entry=patternToEntry.get(m.pattern());
    int start=m.start();
    int end=m.end();
    int prevNerEndIndex=start - 1;
    int nextNerStartIndex=end;
    String startNer=tokens.get(start).ner();
    String endNer=tokens.get(end - 1).ner();
    if (startNer != null && !myLabels.contains(startNer)) {
      while (prevNerEndIndex >= 0) {
        String ner=tokens.get(prevNerEndIndex).ner();
        if (ner == null || !ner.equals(startNer)) {
          break;
        }
        prevNerEndIndex--;
      }
    }
    if (endNer != null && !myLabels.contains(endNer)) {
      while (nextNerStartIndex < tokens.size()) {
        String ner=tokens.get(nextNerStartIndex).ner();
        if (ner == null || !ner.equals(endNer)) {
          break;
        }
        nextNerStartIndex++;
      }
    }
    boolean overwriteOriginalNer=false;
    if (prevNerEndIndex != (start - 1) && nextNerStartIndex != end) {
    }
 else     if (startNer == null) {
      overwriteOriginalNer=true;
    }
 else {
      for (int i=start + 1; i < end; i++) {
        if (!startNer.equals(tokens.get(i).ner())) {
          overwriteOriginalNer=true;
          break;
        }
      }
      if (!overwriteOriginalNer) {
        if (entry.overwritableTypes.contains(startNer) || myLabels.contains(startNer)) {
          overwriteOriginalNer=true;
        }
      }
    }
    if (overwriteOriginalNer) {
      for (int i=start; i < end; i++) {
        tokens.get(i).set(CoreAnnotations.NamedEntityTagAnnotation.class,entry.type);
      }
    }
 else {
      if (verbose) {
        System.err.println("Not annotating  '" + m.group() + "': "+ StringUtils.joinFields(m.groupNodes(),CoreAnnotations.NamedEntityTagAnnotation.class)+ " with "+ entry.type+ ", sentence is '"+ StringUtils.joinWords(tokens," ")+ "'");
      }
    }
  }
}
