{
  List<SequenceMatchResult<CoreMap>> matched=multiPatternMatcher.findNonOverlapping(tokens);
  for (  SequenceMatchResult<CoreMap> m : matched) {
    Entry entry=patternToEntry.get(m.pattern());
    int start=m.start();
    int end=m.end();
    int prevNerEndIndex=start - 1;
    int nextNerStartIndex=end;
    String startNer=tokens.get(start).ner();
    String endNer=tokens.get(end - 1).ner();
    while (prevNerEndIndex >= 0) {
      String ner=tokens.get(prevNerEndIndex).ner();
      if (ner == null || !ner.equals(startNer)) {
        break;
      }
      prevNerEndIndex--;
    }
    while (nextNerStartIndex < tokens.size()) {
      String ner=tokens.get(nextNerStartIndex).ner();
      if (ner == null || !ner.equals(endNer)) {
        break;
      }
      nextNerStartIndex++;
    }
    boolean overwriteOriginalNer=false;
    if (prevNerEndIndex != (start - 1) && nextNerStartIndex != end) {
    }
 else     if (startNer == null) {
      overwriteOriginalNer=true;
    }
 else {
      for (int i=start + 1; i < end; i++) {
        if (!startNer.equals(tokens.get(i).ner())) {
          overwriteOriginalNer=true;
          break;
        }
      }
      if (!overwriteOriginalNer) {
        if (entry.overwritableTypes.contains(startNer) || myLabels.contains(startNer)) {
          overwriteOriginalNer=true;
        }
      }
    }
    if (overwriteOriginalNer) {
      for (int i=start; i < end; i++) {
        tokens.get(i).set(CoreAnnotations.NamedEntityTagAnnotation.class,entry.type);
      }
    }
  }
}
