{
  String prefix=(name != null && !name.isEmpty()) ? name + "." : "";
  String backgroundSymbol=properties.getProperty(prefix + "backgroundSymbol",DEFAULT_BACKGROUND_SYMBOL);
  String[] backgroundSymbols=COMMA_DELIMITERS_PATTERN.split(backgroundSymbol);
  String mappingFiles=properties.getProperty(prefix + "mapping",DefaultPaths.DEFAULT_REGEXNER_RULES);
  String[] mappings=FILE_DELIMITERS_PATTERN.split(mappingFiles);
  String validPosRegex=properties.getProperty(prefix + "validpospattern");
  this.posMatchType=PosMatchType.valueOf(properties.getProperty(prefix + "posmatchtype",DEFAULT_POS_MATCH_TYPE.name()));
  String commonWordsFile=properties.getProperty(prefix + "commonWords");
  commonWords=new HashSet<String>();
  if (commonWordsFile != null) {
    try {
      BufferedReader reader=IOUtils.getBufferedFileReader(commonWordsFile);
      String line;
      while ((line=reader.readLine()) != null) {
        commonWords.add(line);
      }
      reader.close();
    }
 catch (    IOException ex) {
      throw new RuntimeException("TokensRegexNERAnnotator " + name + ": Error opening the common words file: "+ commonWordsFile,ex);
    }
  }
  String headerProp=properties.getProperty(prefix + "mapping.header",defaultHeader);
  boolean readHeaderFromFile=headerProp.equalsIgnoreCase("true");
  String[] annotationFieldnames=null;
  String[] headerFields=null;
  if (readHeaderFromFile) {
    throw new UnsupportedOperationException("Reading header from file not yet supported!!!");
  }
 else {
    headerFields=COMMA_DELIMITERS_PATTERN.split(headerProp);
    List<String> fieldNames=new ArrayList<String>();
    List<Class> fieldClasses=new ArrayList<Class>();
    for (int i=0; i < headerFields.length; i++) {
      String field=headerFields[i];
      if (!predefinedHeaderFields.contains(field)) {
        Class fieldClass=EnvLookup.lookupAnnotationKeyWithClassname(null,field);
        if (fieldClass == null) {
          String classname=properties.getProperty(prefix + "mapping.field." + field);
          fieldClass=EnvLookup.lookupAnnotationKeyWithClassname(null,classname);
        }
        if (fieldClass != null) {
          fieldNames.add(field);
          fieldClasses.add(fieldClass);
        }
 else {
          logger.warn("TokensRegexNERAnnotator " + name + ": Unknown field: "+ field+ " cannot find suitable annotation class");
        }
      }
    }
    annotationFieldnames=new String[fieldNames.size()];
    fieldNames.toArray(annotationFieldnames);
    annotationFields=fieldClasses;
  }
  String noDefaultOverwriteLabelsProp=properties.getProperty(prefix + "noDefaultOverwriteLabels");
  this.noDefaultOverwriteLabels=(noDefaultOverwriteLabelsProp != null) ? Collections.unmodifiableSet(CollectionUtils.asSet(noDefaultOverwriteLabelsProp.split("\\s*,\\s*"))) : Collections.unmodifiableSet(new HashSet<String>());
  this.ignoreCase=PropertiesUtils.getBool(properties,prefix + "ignorecase",false);
  this.verbose=PropertiesUtils.getBool(properties,prefix + "verbose",false);
  if (validPosRegex != null && !validPosRegex.equals("")) {
    validPosPattern=Pattern.compile(validPosRegex);
  }
 else {
    validPosPattern=null;
  }
  entries=Collections.unmodifiableList(readEntries(name,noDefaultOverwriteLabels,ignoreCase,verbose,headerFields,annotationFieldnames,mappings));
  IdentityHashMap<SequencePattern<CoreMap>,Entry> patternToEntry=new IdentityHashMap<SequencePattern<CoreMap>,Entry>();
  multiPatternMatcher=createPatternMatcher(patternToEntry);
  this.patternToEntry=Collections.unmodifiableMap(patternToEntry);
  Set<String> myLabels=Generics.newHashSet();
  Collections.addAll(myLabels,backgroundSymbols);
  myLabels.add(null);
  for (  Entry entry : entries) {
    for (    String type : entry.types) {
      myLabels.add(type);
    }
  }
  this.myLabels=Collections.unmodifiableSet(myLabels);
}
