{
  double beam=pipeline.getBeamPrintingOption();
  TreePrint constituentTreePrinter=pipeline.getConstituentTreePrinter();
  Element root=new Element("root",NAMESPACE_URI);
  Document xmlDoc=new Document(root);
  ProcessingInstruction pi=new ProcessingInstruction("xml-stylesheet","href=\"" + STYLESHEET_NAME + "\" type=\"text/xsl\"");
  xmlDoc.insertChild(pi,0);
  Element docElem=new Element("document",NAMESPACE_URI);
  root.appendChild(docElem);
  String docId=annotation.get(CoreAnnotations.DocIDAnnotation.class);
  if (docId != null) {
    setSingleElement(docElem,"docId",NAMESPACE_URI,docId);
  }
  String docDate=annotation.get(CoreAnnotations.DocDateAnnotation.class);
  if (docDate != null) {
    setSingleElement(docElem,"docDate",NAMESPACE_URI,docDate);
  }
  Element sentencesElem=new Element("sentences",NAMESPACE_URI);
  docElem.appendChild(sentencesElem);
  if (annotation.get(CoreAnnotations.SentencesAnnotation.class) != null) {
    int sentCount=1;
    for (    CoreMap sentence : annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
      Element sentElem=new Element("sentence",NAMESPACE_URI);
      sentElem.addAttribute(new Attribute("id",Integer.toString(sentCount)));
      Integer lineNumber=sentence.get(CoreAnnotations.LineNumberAnnotation.class);
      if (lineNumber != null) {
        sentElem.addAttribute(new Attribute("line",Integer.toString(lineNumber)));
      }
      sentCount++;
      Element wordTable=new Element("tokens",NAMESPACE_URI);
      List<CoreLabel> tokens=sentence.get(CoreAnnotations.TokensAnnotation.class);
      for (int j=0; j < tokens.size(); j++) {
        Element wordInfo=new Element("token",NAMESPACE_URI);
        addWordInfo(wordInfo,tokens.get(j),j + 1,NAMESPACE_URI);
        wordTable.appendChild(wordInfo);
      }
      sentElem.appendChild(wordTable);
      Tree tree=sentence.get(TreeCoreAnnotations.TreeAnnotation.class);
      if (tree != null) {
        Element parseInfo=new Element("parse",NAMESPACE_URI);
        addConstituentTreeInfo(parseInfo,tree,constituentTreePrinter);
        sentElem.appendChild(parseInfo);
        Element depInfo=buildDependencyTreeInfo("basic-dependencies",sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class),tokens,NAMESPACE_URI);
        if (depInfo != null) {
          sentElem.appendChild(depInfo);
        }
        depInfo=buildDependencyTreeInfo("collapsed-dependencies",sentence.get(SemanticGraphCoreAnnotations.CollapsedDependenciesAnnotation.class),tokens,NAMESPACE_URI);
        if (depInfo != null) {
          sentElem.appendChild(depInfo);
        }
        depInfo=buildDependencyTreeInfo("collapsed-ccprocessed-dependencies",sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class),tokens,NAMESPACE_URI);
        if (depInfo != null) {
          sentElem.appendChild(depInfo);
        }
      }
      List<EntityMention> entities=sentence.get(MachineReadingAnnotations.EntityMentionsAnnotation.class);
      List<RelationMention> relations=sentence.get(MachineReadingAnnotations.RelationMentionsAnnotation.class);
      if (entities != null && entities.size() > 0) {
        Element mrElem=new Element("MachineReading",NAMESPACE_URI);
        Element entElem=new Element("entities",NAMESPACE_URI);
        addEntities(entities,entElem,NAMESPACE_URI);
        mrElem.appendChild(entElem);
        if (relations != null) {
          Element relElem=new Element("relations",NAMESPACE_URI);
          addRelations(relations,relElem,NAMESPACE_URI,beam);
          mrElem.appendChild(relElem);
        }
        sentElem.appendChild(mrElem);
      }
      sentencesElem.appendChild(sentElem);
    }
  }
  Map<Integer,CorefChain> corefChains=annotation.get(CorefCoreAnnotations.CorefChainAnnotation.class);
  if (corefChains != null) {
    Element corefInfo=new Element("coreference",NAMESPACE_URI);
    if (addCorefGraphInfo(corefInfo,corefChains,NAMESPACE_URI))     docElem.appendChild(corefInfo);
  }
  return xmlDoc;
}
