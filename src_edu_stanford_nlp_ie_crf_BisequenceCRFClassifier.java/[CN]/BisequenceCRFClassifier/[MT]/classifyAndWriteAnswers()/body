{
  String testFileEn=flags.bisequenceTestFileEn;
  String testFileCh=flags.bisequenceTestFileCh;
  String testAlignmentFile=flags.bisequenceTestAlignmentFile;
  String testOutEn=flags.bisequenceTestOutputEn;
  String testOutCh=flags.bisequenceTestOutputCh;
  DocumentReaderAndWriter<IN> readerAndWriter=null;
  try {
    readerAndWriter=((DocumentReaderAndWriter<IN>)Class.forName(flags.readerAndWriter).newInstance());
  }
 catch (  Exception e) {
    throw new RuntimeException(String.format("Error loading flags.readerAndWriter: '%s'",flags.readerAndWriter),e);
  }
  readerAndWriter.init(flags);
  ObjectBank<List<IN>> documentsOBEn=crfEn.makeObjectBankFromFile(testFileEn,readerAndWriter);
  ObjectBank<List<IN>> documentsOBCh=crfCh.makeObjectBankFromFile(testFileCh,readerAndWriter);
  List<List<IN>> documentsEn=new ArrayList<List<IN>>();
  List<List<IN>> documentsCh=new ArrayList<List<IN>>();
  Iterator<List<IN>> documentsChOBItr=documentsOBCh.iterator();
  for (  List<IN> enDoc : documentsOBEn) {
    documentsEn.add(enDoc);
    documentsCh.add(documentsChOBItr.next());
  }
  if (documentsEn.size() != documentsCh.size()) {
    throw new RuntimeException("documentsEnSize (" + documentsEn.size() + ") != documentsChSize ("+ documentsCh.size());
  }
  List<List<Triple<Integer,Integer,Double>>> alignments=readAlignments(testAlignmentFile);
  Timing timer=new Timing();
  Iterator<List<IN>> documentsChItr=documentsCh.iterator();
  Iterator<List<Triple<Integer,Integer,Double>>> alignmentItr=alignments.iterator();
  List<List<List<Integer>>> partitions=new ArrayList<List<List<Integer>>>();
  if (flags.useChromaticSampling) {
    System.err.println("\nStart graph coloring");
    timer.start();
    for (    List<IN> enDoc : documentsEn) {
      List<IN> chDoc=documentsChItr.next();
      List<Triple<Integer,Integer,Double>> alignment=alignmentItr.next();
      Map<Integer,Set<Integer>> graph=alignmentToGraph(alignment,enDoc.size(),chDoc.size());
      List<List<Integer>> partition=WelshPowellGraphColoring.colorGraph(graph);
      partitions.add(partition);
    }
    long elapsedMs=timer.stop();
    System.err.println("Graph coloring took: " + Timing.toSecondsString(elapsedMs) + " seconds");
  }
  documentsChItr=documentsCh.iterator();
  alignmentItr=alignments.iterator();
  Iterator<List<List<Integer>>> partitionItr=partitions.iterator();
  PrintWriter enPW=new PrintWriter(new FileOutputStream(testOutEn));
  PrintWriter chPW=new PrintWriter(new FileOutputStream(testOutCh));
  if (flags.bisequencePriorType == BisequenceAlignmentPrior.softPrior) {
    if (flags.bisequenceAlignmentPriorPenaltyEn != null)     softPriorMapEn=BisequenceAlignmentPrior.loadSoftPriorMap(flags.bisequenceAlignmentPriorPenaltyEn,false);
    if (flags.bisequenceAlignmentPriorPenaltyCh != null)     softPriorMapCh=BisequenceAlignmentPrior.loadSoftPriorMap(flags.bisequenceAlignmentPriorPenaltyCh,true);
  }
  if (flags.useBilingualNERPrior) {
    tagIndexEn=new HashIndex<String>();
    for (    String tag : classIndexEn.objectsList()) {
      String[] parts=tag.split("-");
      if (parts.length > 1)       tagIndexEn.add(parts[parts.length - 1]);
    }
    tagIndexEn.add(flags.backgroundSymbol);
    System.err.println("tagIndexEn: " + tagIndexEn.toString());
    entityMatricesEn=BisequenceEmpiricalNERPrior.readEntityMatrices(flags.entityMatrixEn,tagIndexEn);
    tagIndexCh=new HashIndex<String>();
    for (    String tag : classIndexCh.objectsList()) {
      String[] parts=tag.split("-");
      if (parts.length > 1)       tagIndexCh.add(parts[parts.length - 1]);
    }
    tagIndexCh.add(flags.backgroundSymbol);
    System.err.println("tagIndexCh: " + tagIndexCh.toString());
    entityMatricesCh=BisequenceEmpiricalNERPrior.readEntityMatrices(flags.entityMatrixCh,tagIndexCh);
  }
  System.err.println("\nStart sampling");
  timer.start();
  ThreadsafeProcessor<Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>,Pair<List<IN>,List<IN>>> threadProcessor=new ThreadsafeProcessor<Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>,Pair<List<IN>,List<IN>>>(){
    @Override public Pair<List<IN>,List<IN>> process(    Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>> quad){
      List<IN> enDoc=quad.first();
      List<IN> chDoc=quad.second();
      List<Triple<Integer,Integer,Double>> alignment=quad.third();
      List<List<Integer>> partition=quad.fourth();
      try {
        classifyGibbs(enDoc,chDoc,alignment,partition);
      }
 catch (      Exception e) {
        System.err.println("Error running testGibbs inference!");
        e.printStackTrace();
        return null;
      }
      int completedNo=threadCompletionCounter.incrementAndGet();
      System.err.println(completedNo + " examples completed");
      return new Pair<List<IN>,List<IN>>(enDoc,chDoc);
    }
    @Override public ThreadsafeProcessor<Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>,Pair<List<IN>,List<IN>>> newInstance(){
      return this;
    }
  }
;
  MulticoreWrapper<Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>,Pair<List<IN>,List<IN>>> wrapper=null;
  if (flags.multiThreadGibbs > 0) {
    wrapper=new MulticoreWrapper<Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>,Pair<List<IN>,List<IN>>>(flags.multiThreadGibbs,threadProcessor);
  }
  for (  List<IN> enDoc : documentsEn) {
    List<IN> chDoc=documentsChItr.next();
    List<Triple<Integer,Integer,Double>> alignment=alignmentItr.next();
    List<List<Integer>> partition=null;
    if (flags.useChromaticSampling) {
      partition=partitionItr.next();
    }
    Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>> quad=new Quadruple<List<IN>,List<IN>,List<Triple<Integer,Integer,Double>>,List<List<Integer>>>(enDoc,chDoc,alignment,partition);
    if (flags.multiThreadGibbs > 0) {
      wrapper.put(quad);
      while (wrapper.peek()) {
        Pair<List<IN>,List<IN>> results=wrapper.poll();
        List<IN> enResult=results.first();
        List<IN> chResult=results.second();
        crfEn.writeAnswers(enResult,enPW,readerAndWriter);
        crfCh.writeAnswers(chResult,chPW,readerAndWriter);
      }
    }
 else {
      Pair<List<IN>,List<IN>> results=threadProcessor.process(quad);
      List<IN> enResult=results.first();
      List<IN> chResult=results.second();
      crfEn.writeAnswers(enResult,enPW,readerAndWriter);
      crfCh.writeAnswers(chResult,chPW,readerAndWriter);
    }
  }
  if (flags.multiThreadGibbs > 0) {
    wrapper.join();
    while (wrapper.peek()) {
      Pair<List<IN>,List<IN>> results=wrapper.poll();
      List<IN> enResult=results.first();
      List<IN> chResult=results.second();
      crfEn.writeAnswers(enResult,enPW,readerAndWriter);
      crfCh.writeAnswers(chResult,chPW,readerAndWriter);
    }
  }
  long elapsedMs=timer.stop();
  System.err.println("\nSampling process completed for " + threadCompletionCounter.get() + " docs, took: "+ Timing.toSecondsString(elapsedMs)+ " seconds");
}
