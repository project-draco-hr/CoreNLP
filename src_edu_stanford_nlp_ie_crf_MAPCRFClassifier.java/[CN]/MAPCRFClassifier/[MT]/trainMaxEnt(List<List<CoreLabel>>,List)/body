{
  makeAnswerArraysAndTagIndex(docs);
  int[][][][] data=new int[datums.size()][][][];
  int[][] labels=new int[datums.size()][];
  addProcessedData(datums,data,labels,null,0);
  int arraysize=0;
  for (int count=0; count < map.length; count++) {
    arraysize+=labelIndices.get(map[count]).size();
  }
  System.err.println("trainMaxEnt: new arraysize for mean: " + arraysize);
  double[] mean=new double[arraysize];
  double[] sigma=new double[arraysize];
  for (int count=0; count < mean.length; count++) {
    mean[count]=0;
    sigma[count]=1.0;
  }
  if (weights != null) {
    int wIndex=0;
    for (int count=0; count < weights.length; count++) {
      System.arraycopy(weights[count],0,mean,wIndex,weights[count].length);
      wIndex+=weights[count].length;
    }
  }
  GeneralizedCRFLogConditionalObjectiveFunction func=new GeneralizedCRFLogConditionalObjectiveFunction(data,labels,featureIndex,windowSize,classIndex,labelIndices,map,flags.backgroundSymbol,mean,sigma);
  func.crfType=flags.crfType;
  QNMinimizer minimizer;
  if (flags.interimOutputFreq != 0) {
    Function monitor=new ResultStoringMonitor(func);
    minimizer=new QNMinimizer(monitor);
  }
 else {
    minimizer=new QNMinimizer();
  }
  double[] initialWeights;
  if (flags.initialWeights == null) {
    initialWeights=func.initial();
  }
 else {
    try {
      System.err.println("Reading initial weights from file " + flags.initialWeights);
      DataInputStream dis=new DataInputStream(new BufferedInputStream(new GZIPInputStream(new FileInputStream(flags.initialWeights))));
      initialWeights=Convert.readDoubleArr(dis);
    }
 catch (    IOException e) {
      throw new RuntimeException("Could not read from double initial weight file " + flags.initialWeights);
    }
  }
  System.err.println("numWeights: " + initialWeights.length);
  double[] weights=minimizer.minimize(func,flags.tolerance,initialWeights);
  this.weights=func.to2D(weights);
  return docs;
}
