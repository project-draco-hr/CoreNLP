{
  makeAnswerArraysAndTagIndex(docs);
  Random r=new Random();
  for (int i=0; i <= flags.numTimesPruneFeatures; i++) {
    Triple<int[][][][],int[][],double[][][][]> dataAndLabels=documentsToDataAndLabels(docs);
    if (flags.saveFeatureIndexToDisk) {
      try {
        System.err.println("Writing feature index to temporary file.");
        File featIndexFile=File.createTempFile("featIndex" + i,".tmp");
        featIndexFile.deleteOnExit();
        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(featIndexFile))));
        oos.writeObject(featureIndex);
        oos.close();
      }
 catch (      IOException e) {
        throw new RuntimeException("Could not open temporary feature index file for writing.");
      }
    }
    int[][][][] data=dataAndLabels.first();
    int[][] labels=dataAndLabels.second();
    System.err.println("TrainMaxEnt: Loadprocessed: " + flags.loadProcessedData);
    if (flags.loadProcessedData != null) {
      List<List<CRFDatum<Collection<String>,String>>> processedData=loadProcessedData(flags.loadProcessedData);
      if (processedData != null) {
        int[][][][] allData=new int[data.length + processedData.size()][][][];
        int[][] allLabels=new int[labels.length + processedData.size()][];
        System.arraycopy(data,0,allData,0,data.length);
        System.arraycopy(labels,0,allLabels,0,labels.length);
        addProcessedData(processedData,allData,allLabels,null,data.length);
        data=allData;
        labels=allLabels;
      }
    }
    int arraysize=0;
    for (int count=0; count < map.length; count++) {
      arraysize+=labelIndices.get(map[count]).size();
    }
    double[] mean=new double[arraysize];
    double[] sigma=new double[arraysize];
    for (int count=0; count < mean.length; count++) {
      mean[count]=0;
      sigma[count]=1.0;
    }
    if (weights != null) {
      int wIndex=0;
      for (int count=0; count < weights.length; count++) {
        System.arraycopy(weights[count],0,mean,wIndex,weights[count].length);
        wIndex+=weights[count].length;
      }
    }
    GeneralizedCRFLogConditionalObjectiveFunction func=new GeneralizedCRFLogConditionalObjectiveFunction(data,labels,featureIndex,windowSize,classIndex,labelIndices,map,flags.backgroundSymbol,mean,sigma);
    func.crfType=flags.crfType;
    QNMinimizer minimizer;
    if (flags.interimOutputFreq != 0) {
      Function monitor=new ResultStoringMonitor(func);
      minimizer=new QNMinimizer(monitor);
    }
 else {
      minimizer=new QNMinimizer();
    }
    if (i == 0) {
      minimizer.setM(flags.QNsize);
    }
 else {
      minimizer.setM(flags.QNsize2);
    }
    double[] initialWeights;
    if (flags.initialWeights == null) {
      initialWeights=func.initial();
    }
 else {
      try {
        System.err.println("Reading initial weights from file " + flags.initialWeights);
        DataInputStream dis=new DataInputStream(new BufferedInputStream(new GZIPInputStream(new FileInputStream(flags.initialWeights))));
        initialWeights=Convert.readDoubleArr(dis);
      }
 catch (      IOException e) {
        throw new RuntimeException("Could not read from double initial weight file " + flags.initialWeights);
      }
    }
    System.err.println("numWeights: " + initialWeights.length);
    double[] weights=minimizer.minimize(func,flags.tolerance,initialWeights);
    this.weights=func.to2D(weights);
    if (i != flags.numTimesPruneFeatures) {
      dropFeaturesBelowThreshold(flags.featureDiffThresh);
      System.err.println("Removing features with weight below " + flags.featureDiffThresh + " and retraining...");
    }
  }
  return docs;
}
