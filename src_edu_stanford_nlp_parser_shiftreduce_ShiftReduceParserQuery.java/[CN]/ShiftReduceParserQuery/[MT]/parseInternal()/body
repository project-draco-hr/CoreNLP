{
  success=true;
  unparsable=false;
  PriorityQueue<State> beam=new PriorityQueue<State>(BEAM_SIZE + 1,ScoredComparator.ASCENDING_COMPARATOR);
  beam.add(initialState);
  while (beam.size() > 0) {
    PriorityQueue<State> oldBeam=beam;
    beam=new PriorityQueue<State>(BEAM_SIZE + 1,ScoredComparator.ASCENDING_COMPARATOR);
    State bestState=null;
    for (    State state : oldBeam) {
      Set<String> features=parser.featureFactory.featurize(state);
      Collection<ScoredObject<Integer>> predictedTransitions=parser.findHighestScoringTransitions(state,features,true,BEAM_SIZE);
      for (      ScoredObject<Integer> predictedTransition : predictedTransitions) {
        Transition transition=parser.transitionIndex.get(predictedTransition.object());
        State newState=transition.apply(state,predictedTransition.score());
        if (bestState == null || newState.score() < bestState.score()) {
          bestState=newState;
        }
        beam.add(newState);
        if (beam.size() > BEAM_SIZE) {
          beam.poll();
        }
      }
    }
    if (bestState == null || bestState.isFinished()) {
      break;
    }
  }
  if (beam.size() == 0) {
    success=false;
    unparsable=true;
  }
 else {
    bestParses=Generics.newArrayList(beam);
    Collections.reverse(bestParses);
    finalState=bestParses.get(0);
    debinarized=debinarizer.transformTree(finalState.stack.peek());
  }
  return success;
}
