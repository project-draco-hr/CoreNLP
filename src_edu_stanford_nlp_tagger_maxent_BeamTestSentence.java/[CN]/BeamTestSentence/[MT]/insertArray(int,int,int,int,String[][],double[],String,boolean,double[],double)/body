{
  if (DBG) {
    System.err.println(" inserting tag " + tag + " for word "+ sent.get(current));
  }
  double p;
  if (hasHistory) {
    p=maxentTagger.getLambdaSolve().pcond(y,x) * pBest[hyp];
  }
 else {
    p=Math.log(histories[y]) - Math.log(sum) + pBest[hyp];
  }
  if (Double.isNaN(p)) {
    System.err.println(" p ia NaN " + pBest[hyp] + ' '+ p+ " current is"+ current+ " tag "+ tag);
    return;
  }
  if (p == 0.0) {
    System.err.println(" p is 0 inside insertArray");
    return;
  }
  for (int i=0; i < kBestSize; i++) {
    if (p == pCurrent[i]) {
      boolean isDifferent=false;
      for (int j=0; j < current; j++) {
        if (!(hCurrent[i][j].equals(nBest[hyp][j]))) {
          isDifferent=true;
        }
      }
      if (!(hCurrent[i][current].equals(tag))) {
        isDifferent=true;
      }
      if (!isDifferent) {
        return;
      }
    }
  }
  if (p < pCurrent[kBestSize - 1]) {
    if (DBG) {
      System.err.println(" for word " + current + " did not insert tag "+ tag+ " prob "+ (Math.log(histories[y]) - Math.log(sum))+ " total "+ p);
    }
    return;
  }
  int i=kBestSize - 2;
  while (true) {
    if ((i == -1) || (p < pCurrent[i])) {
      pCurrent[i + 1]=p;
      hCurrent[i + 1][current]=tag;
      if (DBG) {
        System.err.println(" added for word " + current + " tag "+ tag+ " prob "+ (Math.log(histories[y]) - Math.log(sum))+ " total "+ p+ " at place "+ (i + 1));
      }
      System.arraycopy(nBest[hyp],0,hCurrent[i + 1],0,current);
      return;
    }
    pCurrent[i + 1]=pCurrent[i];
    System.arraycopy(hCurrent[i],0,hCurrent[i + 1],0,current + 1);
    i--;
  }
}
